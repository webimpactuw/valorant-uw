{"version":3,"file":"deleteSchemaAction.js","sources":["../../src/_internal/cli/actions/schema/deleteSchemaAction.ts"],"sourcesContent":["import {type CliCommandContext} from '@sanity/cli'\nimport chalk from 'chalk'\nimport uniq from 'lodash/uniq'\n\nimport {isDefined} from '../../../manifest/manifestTypeHelpers'\nimport {type SchemaStoreActionResult, type SchemaStoreContext} from './schemaStoreTypes'\nimport {createManifestExtractor, ensureManifestExtractSatisfied} from './utils/mainfestExtractor'\nimport {createManifestReader} from './utils/manifestReader'\nimport {createSchemaApiClient} from './utils/schemaApiClient'\nimport {getDatasetsOutString, getStringList} from './utils/schemaStoreOutStrings'\nimport {\n  filterLogReadProjectIdMismatch,\n  parseDeleteSchemasConfig,\n  type SchemaStoreCommonFlags,\n} from './utils/schemaStoreValidation'\n\nexport interface DeleteSchemaFlags extends SchemaStoreCommonFlags {\n  ids?: string\n  dataset?: string\n}\n\ninterface DeleteResult {\n  dataset: string\n  schemaId: string\n  deleted: boolean\n}\n\nclass DeleteIdError extends Error {\n  public id: string\n  public dataset: string\n  constructor(id: string, dataset: string, options?: ErrorOptions) {\n    super((options?.cause as {message?: string})?.message, options)\n    this.name = 'DeleteIdError'\n    this.id = id\n    this.dataset = dataset\n  }\n}\n\nexport default function deleteSchemasActionForCommand(\n  flags: DeleteSchemaFlags,\n  context: CliCommandContext,\n): Promise<SchemaStoreActionResult> {\n  return deleteSchemaAction(flags, {\n    ...context,\n    manifestExtractor: createManifestExtractor(context),\n  })\n}\n\n/**\n * Deletes all stored schemas matching --ids in workspace datasets.\n *\n * Workspaces are determined by on-disk manifest file â€“ not directly from sanity.config.\n * All schema store actions require a manifest to exist, so we regenerate it by default.\n * Manifest generation can be optionally disabled with --no-manifest-extract.\n * In this case the command uses and existing file or throws when missing.\n */\nexport async function deleteSchemaAction(\n  flags: DeleteSchemaFlags,\n  context: SchemaStoreContext,\n): Promise<SchemaStoreActionResult> {\n  const {ids, dataset, extractManifest, manifestDir, verbose} = parseDeleteSchemasConfig(\n    flags,\n    context,\n  )\n  const {output, apiClient, jsonReader, manifestExtractor} = context\n\n  // prettier-ignore\n  if (!(await ensureManifestExtractSatisfied({schemaRequired: true, extractManifest, manifestDir,  manifestExtractor, output,}))) {\n    return 'failure'\n  }\n\n  const {client, projectId} = createSchemaApiClient(apiClient)\n  const manifest = await createManifestReader({manifestDir, output, jsonReader}).getManifest()\n\n  const workspaces = manifest.workspaces\n    .filter((workspace) => !dataset || workspace.dataset === dataset)\n    .filter((workspace) => filterLogReadProjectIdMismatch(workspace, projectId, output))\n\n  const datasets = uniq(workspaces.map((w) => w.dataset))\n\n  const results = await Promise.allSettled(\n    datasets.flatMap((targetDataset: string) => {\n      return ids.map(async ({schemaId}): Promise<DeleteResult> => {\n        try {\n          const deletedSchema = await client.withConfig({dataset: targetDataset}).delete(schemaId)\n          return {dataset: targetDataset, schemaId, deleted: deletedSchema.results.length}\n        } catch (err) {\n          throw new DeleteIdError(schemaId, targetDataset, {cause: err})\n        }\n      })\n    }),\n  )\n\n  const deletedIds = results\n    .filter((r): r is PromiseFulfilledResult<DeleteResult> => r.status === 'fulfilled')\n    .filter((r) => r.value.deleted)\n    .map((r) => r.value)\n\n  const notFound = uniq(\n    results\n      .filter((r): r is PromiseFulfilledResult<DeleteResult> => r.status === 'fulfilled')\n      .filter((r) => !r.value.deleted)\n      .filter((r) => !deletedIds.map(({schemaId}) => schemaId).includes(r.value.schemaId))\n      .map((r) => r.value.schemaId),\n  )\n\n  const deleteFailureIds = uniq(\n    results\n      .filter((r) => r.status === 'rejected')\n      .map((result) => {\n        const error = result.reason\n        if (error instanceof DeleteIdError) {\n          output.error(\n            chalk.red(\n              `Failed to delete schema \"${error.id}\" in dataset \"${error.dataset}\":\\n${error.message}`,\n            ),\n          )\n          if (verbose) output.error(error)\n          return error.id\n        }\n        //hubris inc: given the try-catch wrapping the full promise \"this should never happen\"\n        throw error\n      }),\n  )\n\n  const success = deletedIds.length === ids.length\n  if (success) {\n    output.success(`Successfully deleted ${deletedIds.length}/${ids.length} schemas`)\n  } else {\n    output.error(\n      [\n        `Deleted ${deletedIds.length}/${ids.length} schemas.`,\n        deletedIds.length\n          ? `Successfully deleted ids:\\n${deletedIds\n              .map(\n                ({schemaId, dataset: targetDataset}) =>\n                  `- \"${schemaId}\" (in ${getDatasetsOutString([targetDataset])})`,\n              )\n              .join('\\n')}`\n          : undefined,\n        notFound.length\n          ? `Ids not found in ${getDatasetsOutString(datasets)}:\\n${getStringList(notFound)}`\n          : undefined,\n        ...(deleteFailureIds.length\n          ? [`Failed to delete ids:\\n${getStringList(deleteFailureIds)}`, 'Check logs for errors.']\n          : []),\n      ]\n        .filter(isDefined)\n        .join('\\n'),\n    )\n  }\n\n  return success ? 'success' : 'failure'\n}\n"],"names":["DeleteIdError","Error","constructor","id","dataset","options","cause","message","name","deleteSchemasActionForCommand","flags","context","deleteSchemaAction","manifestExtractor","createManifestExtractor","ids","extractManifest","manifestDir","verbose","parseDeleteSchemasConfig","output","apiClient","jsonReader","ensureManifestExtractSatisfied","schemaRequired","client","projectId","createSchemaApiClient","workspaces","createManifestReader","getManifest","filter","workspace","filterLogReadProjectIdMismatch","datasets","uniq","map","w","results","Promise","allSettled","flatMap","targetDataset","schemaId","deletedSchema","withConfig","delete","deleted","length","err","deletedIds","r","status","value","notFound","includes","deleteFailureIds","result","error","reason","chalk","red","success","getDatasetsOutString","join","undefined","getStringList","isDefined"],"mappings":"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"}