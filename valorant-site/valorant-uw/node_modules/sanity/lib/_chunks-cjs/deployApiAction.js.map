{"version":3,"file":"deployApiAction.js","sources":["../../src/_internal/cli/util/getUrlHeaders.ts","../../src/_internal/cli/actions/graphql/helpUrls.ts","../../src/_internal/cli/actions/graphql/SchemaError.ts","../../src/_internal/cli/actions/graphql/extractFromSanitySchema.ts","../../src/_internal/cli/actions/graphql/helpers.ts","../../src/_internal/cli/actions/graphql/gen1/generateTypeFilters.ts","../../src/_internal/cli/actions/graphql/gen1/generateTypeQueries.ts","../../src/_internal/cli/actions/graphql/gen1/index.ts","../../src/_internal/cli/actions/graphql/gen2/filters/booleanFilters.ts","../../src/_internal/cli/actions/graphql/gen2/filters/dateFilters.ts","../../src/_internal/cli/actions/graphql/gen2/filters/dateTimeFilters.ts","../../src/_internal/cli/actions/graphql/gen2/filters/documentFilters.ts","../../src/_internal/cli/actions/graphql/gen2/filters/floatFilters.ts","../../src/_internal/cli/actions/graphql/gen2/filters/idFilters.ts","../../src/_internal/cli/actions/graphql/gen2/filters/integerFilters.ts","../../src/_internal/cli/actions/graphql/gen2/filters/stringFilters.ts","../../src/_internal/cli/actions/graphql/gen2/generateTypeFilters.ts","../../src/_internal/cli/actions/graphql/gen2/generateTypeQueries.ts","../../src/_internal/cli/actions/graphql/gen2/generateTypeSortings.ts","../../src/_internal/cli/actions/graphql/gen2/index.ts","../../src/_internal/cli/actions/graphql/gen3/filters/documentFilters.ts","../../src/_internal/cli/actions/graphql/gen3/utils.ts","../../src/_internal/cli/actions/graphql/gen3/generateTypeFilters.ts","../../src/_internal/cli/actions/graphql/gen3/generateTypeQueries.ts","../../src/_internal/cli/actions/graphql/gen3/generateTypeSortings.ts","../../src/_internal/cli/actions/graphql/gen3/index.ts","../../src/_internal/cli/actions/graphql/deployApiAction.ts"],"sourcesContent":["import {getIt} from 'get-it'\n// eslint-disable-next-line import/extensions\nimport {promise} from 'get-it/middleware'\n\nconst request = getIt([promise()])\n\nexport class HttpError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'HttpError'\n  }\n\n  statusCode?: number\n}\n\nexport async function getUrlHeaders(url: string, headers = {}): Promise<Record<string, string>> {\n  const response = await request({\n    url,\n    stream: true,\n    maxRedirects: 0,\n    method: 'HEAD',\n    headers,\n  })\n\n  if (response.statusCode >= 400) {\n    const error = new HttpError(`Request returned HTTP ${response.statusCode}`)\n    error.statusCode = response.statusCode\n    throw error\n  }\n\n  response.body.resume()\n  return response.headers\n}\n","export const SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE = 'schema-lift-anonymous-object-type'\n","import {type CliOutputter} from '@sanity/cli'\nimport {generateHelpUrl} from '@sanity/generate-help-url'\nimport {type SchemaValidationProblemGroup} from '@sanity/types'\nimport {upperFirst} from 'lodash'\nimport logSymbols from 'log-symbols'\n\n// eslint-disable-next-line no-console\nconst consoleOutputter = {error: (...args: unknown[]) => console.error(...args)}\n\nexport class SchemaError extends Error {\n  problemGroups: SchemaValidationProblemGroup[]\n\n  constructor(problemGroups: SchemaValidationProblemGroup[]) {\n    super('Schema errors encountered')\n    this.name = 'SchemaError'\n    this.problemGroups = problemGroups\n  }\n\n  print(output: CliOutputter): void {\n    const logger = output || consoleOutputter\n    logger.error('Uh oh… found errors in schema:\\n')\n\n    this.problemGroups.forEach((group) => {\n      group.problems.forEach((problem) => {\n        const icon = logSymbols[problem.severity] || logSymbols.info\n        output.error(`  ${icon} ${upperFirst(problem.severity)}: ${getPath(group.path)}`)\n        output.error(`  ${problem.message}`)\n        if (problem.helpId) {\n          output.error(`  See ${generateHelpUrl(problem.helpId)}`)\n        }\n        output.error('')\n      })\n    })\n  }\n}\n\nfunction getPath(path: SchemaValidationProblemGroup['path']) {\n  return path\n    .map((segment) => {\n      if (segment.kind === 'type' && segment.name && segment.type) {\n        return `${segment.name} - (${segment.type})`\n      }\n      if (segment.kind === 'property' && segment.name) {\n        return segment.name\n      }\n      return null\n    })\n    .filter(Boolean)\n    .join(' / ')\n}\n","import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {Schema} from '@sanity/schema'\nimport {\n  type ArraySchemaType,\n  type CrossDatasetReferenceSchemaType,\n  type IntrinsicTypeName,\n  isDeprecationConfiguration,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Schema as CompiledSchema,\n  type SchemaType,\n} from '@sanity/types'\nimport {startCase, uniqBy} from 'lodash'\nimport oneline from 'oneline'\n\nimport * as helpUrls from './helpUrls'\nimport {SchemaError} from './SchemaError'\nimport {\n  type ApiSpecification,\n  type ConvertedFieldDefinition,\n  type ConvertedInterface,\n  type ConvertedType,\n  type ConvertedUnion,\n  type Deprecation,\n} from './types'\n\nconst skipTypes = ['document', 'reference']\nconst allowedJsonTypes = ['object', 'array']\nconst disallowedCustomizedMembers = ['object', 'array', 'image', 'file', 'block']\nconst disabledBlockFields = ['markDefs']\nconst scalars = ['string', 'number', 'boolean']\n\n/**\n * Data required elsewhere in the API specification generation process, but that should not be\n * included in the generated API specification.\n */\nexport const internal = Symbol('internal')\n\nfunction getBaseType(baseSchema: CompiledSchema, typeName: IntrinsicTypeName): SchemaType {\n  if (typeName === 'crossDatasetReference') {\n    return Schema.compile({\n      types: (baseSchema._original?.types || []).concat([\n        {\n          name: `__placeholder__`,\n          type: 'crossDatasetReference',\n          // Just needs _something_ to refer to, doesn't matter what\n          to: [{type: 'sanity.imageAsset'}],\n        },\n      ]),\n    }).get('__placeholder__')\n  }\n  if (typeName === 'globalDocumentReference') {\n    return Schema.compile({\n      types: (baseSchema._original?.types || []).concat([\n        {\n          name: `__placeholder__`,\n          type: 'globalDocumentReference',\n          // Just needs _something_ to refer to, doesn't matter what\n          to: [{type: 'sanity.imageAsset'}],\n        },\n      ]),\n    }).get('__placeholder__')\n  }\n\n  return Schema.compile({\n    types: (baseSchema._original?.types || []).concat([\n      {name: `__placeholder__`, type: typeName, options: {hotspot: true}},\n    ]),\n  }).get('__placeholder__')\n}\n\nfunction getTypeName(str: string): string {\n  const name = startCase(str).replace(/\\s+/g, '')\n  return name === 'Number' ? 'Float' : name\n}\n\nfunction isBaseType(type: SchemaType): boolean {\n  return (\n    type.name !== type.jsonType &&\n    allowedJsonTypes.includes(type.jsonType) &&\n    !skipTypes.includes(type.name) &&\n    !isReference(type)\n  )\n}\n\nfunction isBlockType(typeDef: SchemaType | ObjectField): boolean {\n  if (typeDef.name === 'block') {\n    return true\n  }\n\n  if (typeDef.type) {\n    return isBlockType(typeDef.type)\n  }\n\n  return false\n}\n\nfunction hasBlockParent(typeDef: SchemaType): boolean {\n  if (typeDef.type && typeDef.type.name === 'block' && !typeDef.type.type) {\n    return true\n  }\n\n  return Boolean(typeDef.type && hasBlockParent(typeDef.type))\n}\n\nfunction isArrayOfBlocks(typeDef: SchemaType | ObjectField): boolean {\n  const type = typeDef.type || typeDef\n  if (!('jsonType' in type) || type.jsonType !== 'array') {\n    return false\n  }\n\n  return (type.of || []).some(hasBlockParent)\n}\n\nfunction isType(typeDef: SchemaType | ObjectField | ObjectFieldType, typeName: string): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\nfunction isReference(\n  typeDef: SchemaType | ObjectField | ObjectFieldType,\n): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\n\nfunction isCrossDatasetReference(\n  typeDef: SchemaType | ObjectField | ObjectFieldType | CrossDatasetReferenceSchemaType,\n) {\n  return isType(typeDef, 'crossDatasetReference')\n}\n\nfunction getCrossDatasetReferenceMetadata(\n  typeDef: SchemaType | ObjectField | ObjectFieldType | CrossDatasetReferenceSchemaType,\n) {\n  if (!isCrossDatasetReference(typeDef)) return undefined\n\n  function getTypeNames(\n    type: SchemaType | ObjectField | ObjectFieldType | CrossDatasetReferenceSchemaType | undefined,\n  ) {\n    if (!type) return undefined\n    if (!('to' in type)) return getTypeNames(type.type)\n    return type.to.map((t) => t.type).filter((t): t is string => typeof t === 'string')\n  }\n\n  function getDataset(\n    type: SchemaType | ObjectField | ObjectFieldType | CrossDatasetReferenceSchemaType | undefined,\n  ) {\n    if (!type) return undefined\n    if ('dataset' in type && typeof type.dataset === 'string') return type.dataset\n    if (type.type) return getDataset(type.type)\n    return undefined\n  }\n\n  const typeNames = getTypeNames(typeDef)\n  if (!typeNames) return undefined\n\n  const dataset = getDataset(typeDef)\n  if (typeof dataset !== 'string') return undefined\n\n  return {typeNames, dataset}\n}\n\nexport function extractFromSanitySchema(\n  sanitySchema: CompiledSchema,\n  extractOptions: {nonNullDocumentFields?: boolean; withUnionCache?: boolean} = {},\n): ApiSpecification {\n  const {nonNullDocumentFields, withUnionCache} = extractOptions\n  const unionRecursionGuards = new Set<string>()\n  const unionDefinitionCache = new Map<string, any>()\n  const hasErrors =\n    sanitySchema._validation &&\n    sanitySchema._validation.some((group) =>\n      group.problems.some((problem) => problem.severity === 'error'),\n    )\n\n  if (hasErrors && Array.isArray(sanitySchema._validation)) {\n    throw new SchemaError(sanitySchema._validation)\n  }\n\n  const sanityTypes = sanitySchema._original?.types || []\n  const typeNames = sanitySchema.getTypeNames()\n  const unionTypes: ConvertedUnion[] = []\n  const types: ConvertedType[] = []\n\n  for (const typeName of typeNames) {\n    const schemaType = sanitySchema.get(typeName)\n    if (schemaType === undefined) {\n      continue\n    }\n    if (!isBaseType(schemaType)) {\n      continue\n    }\n\n    const convertedType = convertType(schemaType)\n    types.push(convertedType)\n  }\n\n  const withUnions = [...types, ...unionTypes]\n  return {types: withUnions, interfaces: [getDocumentInterfaceDefinition()]}\n\n  function isTopLevelType(typeName: string): boolean {\n    return typeNames.includes(typeName)\n  }\n\n  function mapFieldType(field: SchemaType | ObjectField | ObjectFieldType): string {\n    if (!field.type) {\n      throw new Error('Field has no type!')\n    }\n\n    const jsonType = 'jsonType' in field ? field.jsonType : ''\n    const isScalar = scalars.includes(jsonType)\n    if (isScalar && jsonType === 'number') {\n      return hasValidationFlag(field, 'integer') ? 'Int' : 'Float'\n    } else if (isScalar) {\n      return getTypeName(jsonType)\n    }\n\n    const type = field.type.type || field.type\n\n    // In the case of nested scalars, recurse (markdown -> longText -> text -> string)\n    if (type.type) {\n      return mapFieldType(type)\n    }\n\n    switch (type.name) {\n      case 'number':\n        return hasValidationFlag(field, 'integer') ? 'Int' : 'Float'\n      default:\n        return getTypeName(type.name)\n    }\n  }\n\n  function isArrayType(type: SchemaType | ObjectField): type is ArraySchemaType {\n    return Boolean(\n      ('jsonType' in type && type.jsonType === 'array') ||\n        (type.type && type.type.jsonType === 'array'),\n    )\n  }\n\n  function _convertType(\n    type: SchemaType | ObjectField,\n    parent: string,\n    options: {isField?: boolean},\n  ): ConvertedType {\n    let name: string | undefined\n    if (type.type) {\n      name = type.type.name\n    } else if ('jsonType' in type) {\n      name = type.jsonType\n    }\n\n    if (isReference(type)) {\n      return getReferenceDefinition(type, parent)\n    }\n\n    if (isArrayType(type)) {\n      return getArrayDefinition(type, parent, options)\n    }\n\n    if (name === 'document') {\n      return getDocumentDefinition(type as ObjectSchemaType)\n    }\n\n    if (name === 'block' || name === 'object') {\n      return getObjectDefinition(type, parent)\n    }\n\n    if (hasFields(type)) {\n      return getObjectDefinition(type, parent)\n    }\n\n    return {\n      type: mapFieldType(type),\n      description: getDescription(type),\n    } as any\n  }\n\n  function convertType(\n    type: SchemaType | ObjectField,\n    parent?: string,\n    props: {fieldName?: string} & Partial<Deprecation> = {},\n  ): ConvertedType {\n    const mapped = _convertType(type, parent || '', {isField: Boolean(props.fieldName)})\n    const gqlName = props.fieldName || mapped.name\n    const originalName = type.name\n    const original = gqlName === originalName ? {} : {originalName: originalName}\n    const crossDatasetReferenceMetadata = getCrossDatasetReferenceMetadata(type)\n\n    return {\n      ...getDeprecation(type.type),\n      ...props,\n      ...mapped,\n      ...original,\n      ...(crossDatasetReferenceMetadata && {crossDatasetReferenceMetadata}),\n    }\n  }\n\n  function isField(def: SchemaType | ObjectField): def is ObjectField {\n    return !('jsonType' in def) || !def.jsonType\n  }\n\n  // eslint-disable-next-line complexity\n  function getObjectDefinition(def: SchemaType | ObjectField, parent?: string): ConvertedType {\n    const isInline = isField(def)\n    const isDocument = def.type ? def.type.name === 'document' : false\n    const actualType = isInline ? def.type : def\n\n    if (typeNeedsHoisting(actualType)) {\n      throw createLiftTypeError(def.name, parent || '', actualType.name)\n    }\n\n    if (isInline && parent && def.type.name === 'object') {\n      throw createLiftTypeError(def.name, parent)\n    }\n\n    if (parent && def.type && isTopLevelType(def.type.name)) {\n      return {type: getTypeName(def.type.name)} as any\n    }\n\n    const name = `${parent || ''}${getTypeName(def.name)}`\n    const fields = collectFields(def)\n    const firstUnprefixed = Math.max(\n      0,\n      fields.findIndex((field) => field.name[0] !== '_'),\n    )\n\n    const keyField = createStringField('_key')\n\n    fields.splice(firstUnprefixed, 0, keyField)\n\n    if (!isDocument) {\n      fields.splice(firstUnprefixed + 1, 0, createStringField('_type'))\n    }\n\n    const objectIsBlock = isBlockType(def)\n    const objectFields = objectIsBlock\n      ? fields.filter((field) => !disabledBlockFields.includes(field.name))\n      : fields\n\n    return {\n      kind: 'Type',\n      name,\n      type: 'Object',\n      description: getDescription(def),\n      fields: objectFields.map((field) =>\n        isArrayOfBlocks(field)\n          ? buildRawField(field, name)\n          : (convertType(field, name, {\n              fieldName: field.name,\n              ...getDeprecation(def),\n            }) as any),\n      ),\n      [internal]: {\n        ...getDeprecation(def),\n      },\n    }\n  }\n\n  function buildRawField(field: ObjectField, parentName: string) {\n    return {\n      ...convertType(field, parentName, {fieldName: `${field.name}Raw`}),\n      type: 'JSON',\n      isRawAlias: true,\n    }\n  }\n\n  function createStringField(name: string): ObjectField {\n    return {\n      name,\n      type: {\n        jsonType: 'string',\n        name: 'string',\n        type: {name: 'string', type: undefined, jsonType: 'string'},\n      },\n    }\n  }\n\n  function collectFields(def: SchemaType | ObjectField) {\n    const fields = gatherAllFields(def)\n    if (fields.length > 0) {\n      return fields\n    }\n\n    const extended = getBaseType(sanitySchema, def.name as IntrinsicTypeName)\n    return gatherAllFields(extended)\n  }\n\n  function getReferenceDefinition(def: SchemaType, parent: string): any {\n    const base = {description: getDescription(def), isReference: true}\n    const candidates = arrayify(gatherAllReferenceCandidates(def))\n    if (candidates.length === 0) {\n      throw new Error('No candidates for reference')\n    }\n\n    if (candidates.length === 1) {\n      return {type: getTypeName(candidates[0].type.name), ...base}\n    }\n\n    const allTypeNames = candidates.map((c) => getTypeName(c.type.name))\n    const targetTypes = [...new Set(allTypeNames)].sort()\n    const name = targetTypes.join('Or')\n\n    // Register the union type if we haven't seen it before\n    if (!unionTypes.some((item) => item.name === name)) {\n      unionTypes.push({\n        kind: 'Union',\n        name,\n        types: targetTypes,\n      })\n    }\n\n    return {\n      type: name,\n      ...base,\n    }\n  }\n\n  function getArrayDefinition(\n    def: ArraySchemaType,\n    parent: string,\n    options: {isField?: boolean} = {},\n  ): any {\n    const base = {description: getDescription(def), kind: 'List'}\n    const name = !options.isField && def.name ? {name: getTypeName(def.name)} : {}\n    const candidates = def.type?.type && 'of' in def.type ? arrayify(def.type.of) : def.of\n\n    return candidates.length === 1\n      ? {\n          children: getArrayChildDefinition(candidates[0], def),\n          ...base,\n          ...name,\n        }\n      : {\n          children: getUnionDefinition(candidates, def, {grandParent: parent}),\n          ...base,\n          ...name,\n        }\n  }\n\n  function getArrayChildDefinition(child: SchemaType, arrayDef: SchemaType) {\n    if (typeNeedsHoisting(child)) {\n      // Seems to be inline? Should be hoisted?\n      throw createLiftTypeError(child.name, arrayDef.name)\n    }\n\n    if (isReference(child)) {\n      return getReferenceDefinition(child, arrayDef.name)\n    }\n\n    // In the case of nested scalars, recurse (markdown -> longText -> text -> string)\n    if (scalars.includes(child.jsonType) && !scalars.includes(child.name)) {\n      return {type: mapFieldType(child)}\n    }\n\n    return {type: getTypeName(child.name)}\n  }\n\n  function typeNeedsHoisting(type: SchemaType & {isCustomized?: boolean}): boolean {\n    if (type.name === 'object') {\n      return true\n    }\n\n    if (type.jsonType === 'object' && !isTopLevelType(type.name)) {\n      return true\n    }\n\n    if (type.isCustomized && !isTopLevelType(type.name)) {\n      return true\n    }\n\n    if (type.isCustomized && disallowedCustomizedMembers.includes(type.name)) {\n      return true\n    }\n\n    return false\n  }\n\n  function getUnionDefinition(\n    candidates: ObjectSchemaType[],\n    parent: SchemaType,\n    options: {grandParent?: string} = {},\n  ) {\n    if (candidates.length < 2) {\n      throw new Error('Not enough candidates for a union type')\n    }\n\n    // #1482: When creating union definition do not get caught in recursion loop\n    // for types that reference themselves\n    const guardPathName = `${typeof parent === 'object' ? parent.name : parent}`\n    if (unionRecursionGuards.has(guardPathName)) {\n      return {}\n    }\n\n    const unionCacheKey = `${options.grandParent}-${guardPathName}-${candidates\n      .map((c) => c.type?.name)\n      .join('-')}`\n    if (withUnionCache && unionDefinitionCache.has(unionCacheKey)) {\n      return unionDefinitionCache.get(unionCacheKey)\n    }\n\n    try {\n      unionRecursionGuards.add(guardPathName)\n\n      candidates.forEach((def, i) => {\n        if (typeNeedsHoisting(def)) {\n          throw createLiftTypeArrayError(\n            i,\n            parent.name,\n            def.type ? def.type.name : def.name,\n            options.grandParent,\n          )\n        }\n      })\n\n      const converted = candidates.map((def) => convertType(def))\n\n      const getName = (def: {type: string | {name: string}}): string =>\n        typeof def.type === 'string' ? def.type : def.type.name\n\n      // We might end up with union types being returned - these needs to be flattened\n      // so that an ImageOr(PersonOrPet) becomes ImageOrPersonOrPet\n      const flattened = converted.reduce(\n        (acc, candidate) => {\n          const union = unionTypes.find((item) => item.name === candidate.type)\n          return union\n            ? acc.concat(union.types.map((type) => ({type, isReference: candidate.isReference})))\n            : acc.concat(candidate)\n        },\n        [] as {name?: string; type: string | {name: string}; isReference?: boolean}[],\n      )\n\n      let allCandidatesAreDocuments = true\n      const refs: (string | {name: string})[] = []\n      const inlineObjs: string[] = []\n      const allTypeNames: string[] = []\n      for (const def of flattened) {\n        if (def.isReference) {\n          refs.push(def.type)\n        }\n        if (!isReference) {\n          inlineObjs.push(def.name || '')\n        }\n\n        const typeName = typeof def.type === 'string' ? def.type : def.type.name\n\n        // Here we remove duplicates, as they might appear twice due to in-line usage of types as well as references\n        if (def.name || def.type) {\n          allTypeNames.push(def.isReference ? typeName : def.name || '')\n        }\n\n        const typeDef = sanityTypes.find((type) => type.name === getName(def))\n        if (!typeDef || typeDef.type !== 'document') {\n          allCandidatesAreDocuments = false\n        }\n      }\n\n      const interfaces = allCandidatesAreDocuments ? ['Document'] : undefined\n      const possibleTypes = [...new Set(allTypeNames)].sort()\n\n      if (possibleTypes.length < 2) {\n        throw new Error(`Not enough types for a union type. Parent: ${parent.name}`)\n      }\n\n      const name = possibleTypes.join('Or')\n\n      if (!unionTypes.some((item) => item.name === name)) {\n        unionTypes.push({\n          kind: 'Union',\n          name,\n          types: possibleTypes,\n          interfaces,\n        })\n      }\n\n      const references = refs.length > 0 ? refs : undefined\n      const inlineObjects = inlineObjs.length > 0 ? inlineObjs : undefined\n\n      const unionDefinition = isReference(parent)\n        ? {type: name, references}\n        : {type: name, references, inlineObjects}\n\n      unionDefinitionCache.set(unionCacheKey, unionDefinition)\n      return unionDefinition\n    } finally {\n      unionRecursionGuards.delete(guardPathName)\n    }\n  }\n\n  function getDocumentDefinition(def: ObjectSchemaType) {\n    const objectDef = getObjectDefinition(def)\n    const fields = getDocumentInterfaceFields(def).concat(objectDef.fields)\n\n    return {...objectDef, fields, interfaces: ['Document']}\n  }\n\n  function getDocumentInterfaceDefinition(): ConvertedInterface {\n    return {\n      kind: 'Interface',\n      name: 'Document',\n      description: 'A Sanity document',\n      fields: getDocumentInterfaceFields(),\n    }\n  }\n\n  function getDocumentInterfaceFields(type?: ObjectSchemaType): ConvertedFieldDefinition[] {\n    const isNullable = typeof nonNullDocumentFields === 'boolean' ? !nonNullDocumentFields : true\n    return [\n      {\n        fieldName: '_id',\n        type: 'ID',\n        isNullable,\n        description: 'Document ID',\n        ...getDeprecation(type),\n      },\n      {\n        fieldName: '_type',\n        type: 'String',\n        isNullable,\n        description: 'Document type',\n        ...getDeprecation(type),\n      },\n      {\n        fieldName: '_createdAt',\n        type: 'Datetime',\n        isNullable,\n        description: 'Date the document was created',\n        ...getDeprecation(type),\n      },\n      {\n        fieldName: '_updatedAt',\n        type: 'Datetime',\n        isNullable,\n        description: 'Date the document was last modified',\n        ...getDeprecation(type),\n      },\n      {\n        fieldName: '_rev',\n        type: 'String',\n        isNullable,\n        description: 'Current document revision',\n        ...getDeprecation(type),\n      },\n    ]\n  }\n\n  function arrayify(thing: unknown) {\n    if (Array.isArray(thing)) {\n      return thing\n    }\n\n    return thing === null || typeof thing === 'undefined' ? [] : [thing]\n  }\n\n  function hasValidationFlag(\n    field: SchemaType | ObjectField | ObjectFieldType,\n    flag: string,\n  ): boolean {\n    return (\n      'validation' in field &&\n      Array.isArray(field.validation) &&\n      field.validation.some(\n        (rule) => rule && '_rules' in rule && rule._rules.some((item) => item.flag === flag),\n      )\n    )\n  }\n\n  function getDescription(type: SchemaType | ObjectField): string | undefined {\n    const description = type.type && type.type.description\n    return typeof description === 'string' ? description : undefined\n  }\n\n  function gatherAllReferenceCandidates(type: SchemaType): ObjectSchemaType[] {\n    const allFields = gatherReferenceCandidates(type)\n    return uniqBy(allFields, 'name')\n  }\n\n  function gatherReferenceCandidates(type: SchemaType): ObjectSchemaType[] {\n    const refTo = 'to' in type ? type.to : []\n    return 'type' in type && type.type ? [...gatherReferenceCandidates(type.type), ...refTo] : refTo\n  }\n\n  function gatherAllFields(type: SchemaType | ObjectField) {\n    const allFields = gatherFields(type)\n    return uniqBy(allFields, 'name')\n  }\n\n  function gatherFields(type: SchemaType | ObjectField): ObjectField[] {\n    if ('fields' in type) {\n      return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n    }\n\n    return []\n  }\n\n  function hasFieldsLikeShape(type: unknown): type is {fields: unknown} {\n    return typeof type === 'object' && type !== null && 'fields' in type\n  }\n\n  function hasArrayOfFields(type: unknown): type is {fields: ObjectField[]} {\n    return hasFieldsLikeShape(type) && Array.isArray(type.fields)\n  }\n\n  function hasFields(type: SchemaType | ObjectField): boolean {\n    if (hasArrayOfFields(type)) {\n      return gatherAllFields(type).length > 0\n    }\n\n    return 'type' in type && type.type ? hasFields(type.type) : false\n  }\n}\n\nfunction createLiftTypeArrayError(\n  index: number,\n  parent: string,\n  inlineType = 'object',\n  grandParent = '',\n) {\n  const helpUrl = generateHelpUrl(helpUrls.SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE)\n  const context = [grandParent, parent].filter(Boolean).join('/')\n  return new HelpfulError(\n    oneline`\n    Encountered anonymous inline ${inlineType} at index ${index} for type/field ${context}.\n    To use this type with GraphQL you will need to create a top-level schema type for it.\n    See ${helpUrl}`,\n    helpUrl,\n  )\n}\n\nfunction createLiftTypeError(typeName: string, parent: string, inlineType = 'object') {\n  const helpUrl = generateHelpUrl(helpUrls.SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE)\n  return new HelpfulError(\n    oneline`\n    Encountered anonymous inline ${inlineType} \"${typeName}\" for field/type \"${parent}\".\n    To use this field with GraphQL you will need to create a top-level schema type for it.\n    See ${helpUrl}`,\n    helpUrl,\n  )\n}\n\nclass HelpfulError extends Error {\n  helpUrl?: string\n\n  constructor(message: string, helpUrl?: string) {\n    super(message)\n    this.name = 'HelpfulError'\n    this.helpUrl = helpUrl\n  }\n}\n\nfunction getDeprecation(\n  type?: SchemaType | ObjectFieldType<SchemaType> | ObjectField<SchemaType>,\n): Partial<Deprecation> {\n  return isDeprecationConfiguration(type)\n    ? {\n        deprecationReason: type.deprecated.reason,\n      }\n    : {}\n}\n","import {\n  type ConvertedDocumentType,\n  type ConvertedInterface,\n  type ConvertedType,\n  type ConvertedUnion,\n} from './types'\n\nexport function isUnion(\n  type: ConvertedType | ConvertedUnion | ConvertedInterface,\n): type is ConvertedUnion {\n  return type.kind === 'Union'\n}\n\nexport function isNonUnion(\n  type: ConvertedType | ConvertedUnion | ConvertedInterface,\n): type is ConvertedType {\n  return !isUnion(type) && 'type' in type\n}\n\nexport function isDocumentType(\n  type: ConvertedType | ConvertedUnion | ConvertedInterface,\n): type is ConvertedDocumentType {\n  return (\n    isNonUnion(type) &&\n    type.type === 'Object' &&\n    Array.isArray(type.interfaces) &&\n    type.interfaces.includes('Document')\n  )\n}\n","import {flatten} from 'lodash'\n\nimport {isNonUnion} from '../helpers'\nimport {\n  type ConvertedField,\n  type ConvertedFieldDefinition,\n  type ConvertedType,\n  type ConvertedUnion,\n  type InputFilterField,\n  type InputObjectType,\n} from '../types'\n\ntype FilterCreator = (field: ConvertedField) => InputFilterField[]\n\nconst filterCreators: Record<string, FilterCreator> = {\n  ID: createIdFilters,\n  String: createStringFilters,\n  Url: createStringFilters,\n  Float: createNumberFilters,\n  Integer: createNumberFilters,\n  Boolean: createBooleanFilters,\n  Datetime: createDateFilters,\n  Date: createDateFilters,\n  Object: createObjectFilters,\n}\n\nexport function generateTypeFilters(types: (ConvertedType | ConvertedUnion)[]): InputObjectType[] {\n  const queryable = types\n    .filter(isNonUnion)\n    .filter(\n      (type) => type.type === 'Object' && type.interfaces && type.interfaces.includes('Document'),\n    )\n\n  return queryable.map((type) => {\n    const name = `${type.name}Filter`\n    const fields = flatten(type.fields.map(createFieldFilters)).filter(Boolean)\n    return {name, kind: 'InputObject', fields: [...fields, ...getDocumentFilters()]}\n  })\n}\n\nfunction createFieldFilters(field: ConvertedField) {\n  if (filterCreators[field.type]) {\n    return filterCreators[field.type](field)\n  }\n\n  if (field.kind === 'List') {\n    return createListFilters()\n  }\n\n  if (field.isReference) {\n    return createReferenceFilters(field)\n  }\n\n  return createInlineTypeFilters()\n}\n\nfunction getFieldName(field: ConvertedField, modifier = '') {\n  const suffix = modifier ? `_${modifier}` : ''\n  return `${field.fieldName}${suffix}`\n}\n\nfunction getDocumentFilters(): InputFilterField[] {\n  return [\n    {\n      fieldName: 'references',\n      type: 'ID',\n      description: 'All documents references the given document ID',\n      constraint: {\n        comparator: 'REFERENCES',\n      },\n    },\n    {\n      fieldName: 'is_draft',\n      type: 'Boolean',\n      description: 'All documents that are drafts',\n      constraint: {\n        field: '_id',\n        comparator: 'IS_DRAFT',\n      },\n    },\n  ]\n}\n\nfunction createIsDefinedFilter(field: ConvertedFieldDefinition): InputFilterField {\n  return {\n    fieldName: getFieldName(field, 'is_defined'),\n    type: 'Boolean',\n    description: 'All documents that have a value for this field',\n    constraint: {\n      field: field.fieldName,\n      comparator: 'IS_DEFINED',\n    },\n  }\n}\n\nfunction createEqualityFilter(field: ConvertedFieldDefinition): InputFilterField {\n  return {\n    fieldName: getFieldName(field),\n    type: field.type,\n    description: 'All documents that are equal to given value',\n    constraint: {\n      field: field.fieldName,\n      comparator: 'EQUALS',\n    },\n  }\n}\n\nfunction createInequalityFilter(field: ConvertedFieldDefinition): InputFilterField {\n  return {\n    fieldName: getFieldName(field, 'not'),\n    type: field.type,\n    description: 'All documents that are not equal to given value',\n    constraint: {\n      field: field.fieldName,\n      comparator: 'NOT_EQUALS',\n    },\n  }\n}\n\nfunction createDefaultFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return [createEqualityFilter(field), createInequalityFilter(field), createIsDefinedFilter(field)]\n}\n\nfunction createGtLtFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return [\n    {\n      fieldName: getFieldName(field, 'lt'),\n      type: field.type,\n      description: 'All documents are less than given value',\n      constraint: {\n        field: field.fieldName,\n        comparator: 'LT',\n      },\n    },\n    {\n      fieldName: getFieldName(field, 'lte'),\n      type: field.type,\n      description: 'All documents are less than or equal to given value',\n      constraint: {\n        field: field.fieldName,\n        comparator: 'LTE',\n      },\n    },\n    {\n      fieldName: getFieldName(field, 'gt'),\n      type: field.type,\n      description: 'All documents are greater than given value',\n      constraint: {\n        field: field.fieldName,\n        comparator: 'GT',\n      },\n    },\n    {\n      fieldName: getFieldName(field, 'gte'),\n      type: field.type,\n      description: 'All documents are greater than or equal to given value',\n      constraint: {\n        field: field.fieldName,\n        comparator: 'GTE',\n      },\n    },\n  ]\n}\n\nfunction createBooleanFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return createDefaultFilters(field)\n}\n\nfunction createIdFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return createStringFilters(field)\n}\n\nfunction createDateFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return createDefaultFilters(field).concat(createGtLtFilters(field))\n}\n\nfunction createStringFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return [\n    ...createDefaultFilters(field),\n    {\n      fieldName: getFieldName(field, 'matches'),\n      type: 'String',\n      description: 'All documents contain (match) the given word/words',\n      constraint: {\n        field: field.fieldName,\n        comparator: 'MATCHES',\n      },\n    },\n    {\n      fieldName: getFieldName(field, 'in'),\n      kind: 'List',\n      children: {\n        type: 'String',\n        isNullable: false,\n      },\n      description: 'All documents match one of the given values',\n      constraint: {\n        field: field.fieldName,\n        comparator: 'IN',\n      },\n    },\n    {\n      fieldName: getFieldName(field, 'not_in'),\n      kind: 'List',\n      children: {\n        type: 'String',\n        isNullable: false,\n      },\n      description: 'None of the values match any of the given values',\n      constraint: {\n        field: field.fieldName,\n        comparator: 'NOT_IN',\n      },\n    },\n  ]\n}\n\nfunction createNumberFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return createDefaultFilters(field).concat(createGtLtFilters(field))\n}\n\nfunction createObjectFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return []\n}\n\nfunction createListFilters(): InputFilterField[] {\n  return []\n}\n\nfunction createInlineTypeFilters(): InputFilterField[] {\n  return []\n}\n\nfunction createReferenceFilters(field: ConvertedFieldDefinition): InputFilterField[] {\n  return [\n    {\n      fieldName: getFieldName(field),\n      type: 'ID',\n      constraint: {\n        field: `${field.fieldName}._ref`,\n        comparator: 'EQUALS',\n      },\n    },\n  ]\n}\n","import {startCase, upperFirst} from 'lodash'\nimport pluralize from 'pluralize-esm'\n\nimport {isNonUnion} from '../helpers'\nimport {\n  type ConvertedType,\n  type ConvertedUnion,\n  type InputObjectType,\n  type QueryDefinition,\n} from '../types'\n\nfunction pluralizeTypeName(name: string): string {\n  const words = startCase(name).split(' ')\n  const last = words[words.length - 1]\n  // `pluralize` previously incorrectly cased the S to uppercase after numbers,\n  // which we need to maintain for backwards compatibility\n  const plural = pluralize(last.toLowerCase()).replace(/(\\d)s$/g, '$1S')\n  words[words.length - 1] = upperFirst(plural)\n  return words.join('')\n}\n\nexport function generateTypeQueries(\n  types: (ConvertedType | ConvertedUnion)[],\n  filters: InputObjectType[],\n): QueryDefinition[] {\n  const queries: QueryDefinition[] = []\n  const queryable = types\n    .filter(isNonUnion)\n    .filter(\n      (type) => type.type === 'Object' && type.interfaces && type.interfaces.includes('Document'),\n    )\n\n  // Single ID-based result lookup queries\n  queryable.forEach((type) => {\n    queries.push({\n      fieldName: type.name,\n      type: type.name,\n      constraints: [\n        {\n          field: '_id',\n          comparator: 'EQUALS',\n          value: {kind: 'argumentValue', argName: 'id'},\n        },\n      ],\n      args: [\n        {\n          name: 'id',\n          description: `${type.name} document ID`,\n          type: 'ID',\n          isNullable: false,\n        },\n      ],\n    })\n  })\n\n  // Fetch all of type\n  queryable.forEach((type) => {\n    const filterName = `${type.name}Filter`\n    const hasFilter = filters.find((filter) => filter.name === filterName)\n    queries.push({\n      fieldName: `all${pluralizeTypeName(type.name)}`,\n      filter: `_type == \"${type.originalName || type.name}\"`,\n      type: {\n        kind: 'List',\n        isNullable: false,\n        children: {type: type.name, isNullable: false},\n      },\n      args: hasFilter\n        ? [{name: 'where', type: filterName, isFieldFilter: true}, ...getLimitOffsetArgs()]\n        : getLimitOffsetArgs(),\n    })\n  })\n\n  return queries\n}\n\nfunction getLimitOffsetArgs(): QueryDefinition['args'] {\n  return [\n    {\n      name: 'limit',\n      type: 'Int',\n      description: 'Max documents to return',\n      isFieldFilter: false,\n    },\n    {\n      name: 'offset',\n      type: 'Int',\n      description: 'Offset at which to start returning documents from',\n      isFieldFilter: false,\n    },\n  ]\n}\n","import {type ApiSpecification, type GeneratedApiSpecification} from '../types'\nimport {generateTypeFilters} from './generateTypeFilters'\nimport {generateTypeQueries} from './generateTypeQueries'\n\nexport default (extracted: ApiSpecification): GeneratedApiSpecification => {\n  const filters = generateTypeFilters(extracted.types)\n  const queries = generateTypeQueries(extracted.types, filters)\n  const types = [...extracted.types, ...filters]\n  return {types, queries, interfaces: extracted.interfaces, generation: 'gen1'}\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createBooleanFilters(): InputObjectType {\n  return {\n    name: 'BooleanFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'eq',\n        type: 'Boolean',\n        description: 'Checks if the value is equal to the given input.',\n      },\n      {\n        fieldName: 'neq',\n        type: 'Boolean',\n        description: 'Checks if the value is not equal to the given input.',\n      },\n      {\n        fieldName: 'is_defined',\n        type: 'Boolean',\n        description: 'Checks if the value is defined.',\n      },\n    ],\n  }\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createDateFilters(): InputObjectType {\n  return {\n    name: 'DateFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'eq',\n        type: 'Date',\n        description: 'Checks if the value is equal to the given input.',\n      },\n      {\n        fieldName: 'neq',\n        type: 'Date',\n        description: 'Checks if the value is not equal to the given input.',\n      },\n      {\n        fieldName: 'gt',\n        type: 'Date',\n        description: 'Checks if the value is greater than the given input.',\n      },\n      {\n        fieldName: 'gte',\n        type: 'Date',\n        description: 'Checks if the value is greater than or equal to the given input.',\n      },\n      {\n        fieldName: 'lt',\n        type: 'Date',\n        description: 'Checks if the value is lesser than the given input.',\n      },\n      {\n        fieldName: 'lte',\n        type: 'Date',\n        description: 'Checks if the value is lesser than or equal to the given input.',\n      },\n      {\n        fieldName: 'is_defined',\n        type: 'Boolean',\n        description: 'Checks if the value is defined.',\n      },\n    ],\n  }\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createDateTimeFilters(): InputObjectType {\n  return {\n    name: 'DatetimeFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'eq',\n        type: 'Datetime',\n        description: 'Checks if the value is equal to the given input.',\n      },\n      {\n        fieldName: 'neq',\n        type: 'Datetime',\n        description: 'Checks if the value is not equal to the given input.',\n      },\n      {\n        fieldName: 'gt',\n        type: 'Datetime',\n        description: 'Checks if the value is greater than the given input.',\n      },\n      {\n        fieldName: 'gte',\n        type: 'Datetime',\n        description: 'Checks if the value is greater than or equal to the given input.',\n      },\n      {\n        fieldName: 'lt',\n        type: 'Datetime',\n        description: 'Checks if the value is lesser than the given input.',\n      },\n      {\n        fieldName: 'lte',\n        type: 'Datetime',\n        description: 'Checks if the value is lesser than or equal to the given input.',\n      },\n      {\n        fieldName: 'is_defined',\n        type: 'Boolean',\n        description: 'Checks if the value is defined.',\n      },\n    ],\n  }\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createDocumentFilters(): InputObjectType {\n  return {\n    name: 'DocumentFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'references',\n        type: 'ID',\n        description: 'All documents referencing the given document ID.',\n      },\n      {\n        fieldName: 'is_draft',\n        type: 'Boolean',\n        description: 'All documents that are drafts.',\n      },\n    ],\n  }\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createFloatFilters(): InputObjectType {\n  return {\n    name: 'FloatFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'eq',\n        type: 'Float',\n        description: 'Checks if the value is equal to the given input.',\n      },\n      {\n        fieldName: 'neq',\n        type: 'Float',\n        description: 'Checks if the value is not equal to the given input.',\n      },\n      {\n        fieldName: 'gt',\n        type: 'Float',\n        description: 'Checks if the value is greater than the given input.',\n      },\n      {\n        fieldName: 'gte',\n        type: 'Float',\n        description: 'Checks if the value is greater than or equal to the given input.',\n      },\n      {\n        fieldName: 'lt',\n        type: 'Float',\n        description: 'Checks if the value is lesser than the given input.',\n      },\n      {\n        fieldName: 'lte',\n        type: 'Float',\n        description: 'Checks if the value is lesser than or equal to the given input.',\n      },\n      {\n        fieldName: 'is_defined',\n        type: 'Boolean',\n        description: 'Checks if the value is defined.',\n      },\n    ],\n  }\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createIdFilters(): InputObjectType {\n  return {\n    name: 'IDFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'eq',\n        type: 'ID',\n        description: 'Checks if the value is equal to the given input.',\n      },\n      {\n        fieldName: 'neq',\n        type: 'ID',\n        description: 'Checks if the value is not equal to the given input.',\n      },\n      {\n        fieldName: 'matches',\n        type: 'ID',\n        description: 'Checks if the value matches the given word/words.',\n      },\n      {\n        fieldName: 'in',\n        kind: 'List',\n        children: {\n          type: 'ID',\n          isNullable: false,\n        },\n        description: 'Checks if the value is equal to one of the given values.',\n      },\n      {\n        fieldName: 'nin',\n        kind: 'List',\n        children: {\n          type: 'ID',\n          isNullable: false,\n        },\n        description: 'Checks if the value is not equal to one of the given values.',\n      },\n    ],\n  }\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createIntegerFilters(): InputObjectType {\n  return {\n    name: 'IntFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'eq',\n        type: 'Int',\n        description: 'Checks if the value is equal to the given input.',\n      },\n      {\n        fieldName: 'neq',\n        type: 'Int',\n        description: 'Checks if the value is not equal to the given input.',\n      },\n      {\n        fieldName: 'gt',\n        type: 'Int',\n        description: 'Checks if the value is greater than the given input.',\n      },\n      {\n        fieldName: 'gte',\n        type: 'Int',\n        description: 'Checks if the value is greater than or equal to the given input.',\n      },\n      {\n        fieldName: 'lt',\n        type: 'Int',\n        description: 'Checks if the value is lesser than the given input.',\n      },\n      {\n        fieldName: 'lte',\n        type: 'Int',\n        description: 'Checks if the value is lesser than or equal to the given input.',\n      },\n      {\n        fieldName: 'is_defined',\n        type: 'Boolean',\n        description: 'Checks if the value is defined.',\n      },\n    ],\n  }\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createStringFilters(): InputObjectType {\n  return {\n    name: 'StringFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'eq',\n        type: 'String',\n        description: 'Checks if the value is equal to the given input.',\n      },\n      {\n        fieldName: 'neq',\n        type: 'String',\n        description: 'Checks if the value is not equal to the given input.',\n      },\n      {\n        fieldName: 'matches',\n        type: 'String',\n        description: 'Checks if the value matches the given word/words.',\n      },\n      {\n        fieldName: 'in',\n        kind: 'List',\n        children: {\n          type: 'String',\n          isNullable: false,\n        },\n        description: 'Checks if the value is equal to one of the given values.',\n      },\n      {\n        fieldName: 'nin',\n        kind: 'List',\n        children: {\n          type: 'String',\n          isNullable: false,\n        },\n        description: 'Checks if the value is not equal to one of the given values.',\n      },\n      {\n        fieldName: 'is_defined',\n        type: 'Boolean',\n        description: 'Checks if the value is defined.',\n      },\n    ],\n  }\n}\n","import {isNonUnion, isUnion} from '../helpers'\nimport {type ConvertedType, type ConvertedUnion, type InputObjectType} from '../types'\nimport {createBooleanFilters} from './filters/booleanFilters'\nimport {createDateFilters} from './filters/dateFilters'\nimport {createDateTimeFilters} from './filters/dateTimeFilters'\nimport {createDocumentFilters} from './filters/documentFilters'\nimport {createFloatFilters} from './filters/floatFilters'\nimport {createIdFilters} from './filters/idFilters'\nimport {createIntegerFilters} from './filters/integerFilters'\nimport {createStringFilters} from './filters/stringFilters'\n\nconst typeAliases: Record<string, string | undefined> = {\n  Url: 'String',\n  Text: 'String',\n  Email: 'String',\n}\n\ntype FilterCreator = () => InputObjectType\n\nconst filterCreators: Record<string, FilterCreator> = {\n  ID: createIdFilters,\n  String: createStringFilters,\n  Float: createFloatFilters,\n  Integer: createIntegerFilters,\n  Boolean: createBooleanFilters,\n  Datetime: createDateTimeFilters,\n  Date: createDateFilters,\n  Document: createDocumentFilters,\n}\n\nexport function generateTypeFilters(types: (ConvertedType | ConvertedUnion)[]): InputObjectType[] {\n  const builtInTypeKeys = Object.keys(filterCreators)\n  const builtinTypeValues = Object.values(filterCreators)\n  const objectTypes = types\n    .filter(isNonUnion)\n    .filter(\n      (type) =>\n        type.type === 'Object' &&\n        !['Block', 'Span'].includes(type.name) &&\n        !type.interfaces &&\n        !builtInTypeKeys.includes(type.type),\n    )\n\n  const unionTypes = types.filter(isUnion).map((type) => type.name)\n  const documentTypes = types\n    .filter(isNonUnion)\n    .filter(\n      (type) => type.type === 'Object' && type.interfaces && type.interfaces.includes('Document'),\n    )\n\n  const builtinTypeFilters = createBuiltinTypeFilters(builtinTypeValues)\n  const objectTypeFilters = createObjectTypeFilters(objectTypes, {unionTypes})\n  const documentTypeFilters = createDocumentTypeFilters(documentTypes, {unionTypes})\n\n  return [...builtinTypeFilters, ...objectTypeFilters, ...documentTypeFilters]\n}\n\nfunction createBuiltinTypeFilters(builtinTypeValues: FilterCreator[]): InputObjectType[] {\n  return builtinTypeValues.map((filterCreator) => filterCreator())\n}\n\nfunction createObjectTypeFilters(\n  objectTypes: ConvertedType[],\n  options: {unionTypes: string[]},\n): InputObjectType[] {\n  return objectTypes.map((objectType) => ({\n    name: `${objectType.name}Filter`,\n    kind: 'InputObject',\n    fields: createFieldFilters(objectType, options),\n  }))\n}\n\nfunction createDocumentTypeFilters(\n  documentTypes: ConvertedType[],\n  options: {unionTypes: string[]},\n): InputObjectType[] {\n  return documentTypes.map((documentType) => ({\n    name: `${documentType.name}Filter`,\n    kind: 'InputObject',\n    fields: [...getDocumentFilters(), ...createFieldFilters(documentType, options)],\n  }))\n}\n\nfunction createFieldFilters(objectType: ConvertedType, options: {unionTypes: string[]}) {\n  const {unionTypes} = options\n  return objectType.fields\n    .filter(\n      (field) => field.type !== 'JSON' && field.kind !== 'List' && !unionTypes.includes(field.type),\n    )\n    .map((field) => ({\n      fieldName: field.fieldName,\n      type: `${typeAliases[field.type] || field.type}Filter`,\n      isReference: field.isReference,\n    }))\n}\n\nfunction getDocumentFilters() {\n  return [\n    {\n      fieldName: '_',\n      type: 'DocumentFilter',\n      description: 'Apply filters on document level',\n    },\n  ]\n}\n","import {upperFirst} from 'lodash'\n\nimport {isDocumentType} from '../helpers'\nimport {\n  type ConvertedType,\n  type ConvertedUnion,\n  type InputObjectType,\n  type QueryDefinition,\n} from '../types'\n\nexport function generateTypeQueries(\n  types: (ConvertedType | ConvertedUnion)[],\n  sortings: InputObjectType[],\n): QueryDefinition[] {\n  const queries: QueryDefinition[] = []\n  const queryable = types.filter(isDocumentType)\n  const isSortable = (type: ConvertedType) =>\n    sortings.some((sorting) => sorting.name === `${type.name}Sorting`)\n\n  // A document of any type\n  queries.push({\n    fieldName: 'Document',\n    type: 'Document',\n    constraints: [\n      {\n        field: '_id',\n        comparator: 'eq',\n        value: {kind: 'argumentValue', argName: 'id'},\n      },\n    ],\n    args: [\n      {\n        name: 'id',\n        description: 'Document ID',\n        type: 'ID',\n        isNullable: false,\n      },\n    ],\n  })\n\n  // Single ID-based result lookup queries\n  queryable.forEach((type) => {\n    queries.push({\n      fieldName: type.name,\n      type: type.name,\n      constraints: [\n        {\n          field: '_id',\n          comparator: 'eq',\n          value: {kind: 'argumentValue', argName: 'id'},\n        },\n      ],\n      args: [\n        {\n          name: 'id',\n          description: `${type.name} document ID`,\n          type: 'ID',\n          isNullable: false,\n        },\n      ],\n    })\n  })\n\n  // Fetch all of type\n  queryable.forEach((type) => {\n    const sorting: QueryDefinition['args'] = []\n    if (isSortable(type)) {\n      sorting.push({\n        name: 'sort',\n        type: {\n          kind: 'List',\n          isNullable: true,\n          children: {\n            type: `${type.name}Sorting`,\n            isNullable: false,\n          },\n        },\n      })\n    }\n\n    queries.push({\n      fieldName: `all${upperFirst(type.name)}`,\n      filter: `_type == \"${type.originalName || type.name}\"`,\n      type: {\n        kind: 'List',\n        isNullable: false,\n        children: {type: type.name, isNullable: false},\n      },\n      args: [\n        {\n          name: 'where',\n          type: `${type.name}Filter`,\n          isFieldFilter: true,\n        },\n        ...sorting,\n        {\n          name: 'limit',\n          type: 'Int',\n          description: 'Max documents to return',\n          isFieldFilter: false,\n        },\n        {\n          name: 'offset',\n          type: 'Int',\n          description: 'Offset at which to start returning documents from',\n          isFieldFilter: false,\n        },\n      ],\n    })\n  })\n\n  return queries\n}\n","import {isDocumentType, isNonUnion} from '../helpers'\nimport {\n  type ConvertedEnum,\n  type ConvertedType,\n  type ConvertedUnion,\n  type InputObjectType,\n} from '../types'\n\nconst builtInTypes = [\n  'Boolean',\n  'Date',\n  'Datetime',\n  'Email',\n  'Float',\n  'ID',\n  'Integer',\n  'String',\n  'Text',\n  'Url',\n]\n\nconst builtInSortingEnum: ConvertedEnum = {\n  name: 'SortOrder',\n  kind: 'Enum',\n  values: [\n    {\n      name: 'ASC',\n      description: 'Sorts on the value in ascending order.',\n      value: 1,\n    },\n    {\n      name: 'DESC',\n      description: 'Sorts on the value in descending order.',\n      value: 2,\n    },\n  ],\n}\n\nexport function generateTypeSortings(\n  types: (ConvertedType | ConvertedUnion)[],\n): (InputObjectType | ConvertedEnum)[] {\n  const objectTypes = types.filter(isNonUnion).filter(\n    (type) =>\n      type.type === 'Object' &&\n      !['Block', 'Span'].includes(type.name) && // TODO: What do we do with blocks?\n      !type.interfaces &&\n      !builtInTypes.includes(type.name),\n  )\n\n  const documentTypes = types.filter(isDocumentType)\n\n  const hasFields = (type: InputObjectType) => type.fields.length > 0\n\n  const objectTypeSortings = createObjectTypeSortings(objectTypes)\n  const documentTypeSortings = createDocumentTypeSortings(documentTypes)\n  const allSortings = [...objectTypeSortings, ...documentTypeSortings].filter(hasFields)\n\n  return [...allSortings, builtInSortingEnum]\n}\n\nfunction createObjectTypeSortings(objectTypes: ConvertedType[]): InputObjectType[] {\n  return objectTypes.map((objectType) => ({\n    name: `${objectType.name}Sorting`,\n    kind: 'InputObject',\n    fields: objectType.fields\n      .filter((field) => field.type !== 'JSON' && field.kind !== 'List')\n      .filter((field) => !field.isReference)\n      .map((field) => ({\n        fieldName: field.fieldName,\n        type: builtInTypes.includes(field.type) ? builtInSortingEnum.name : `${field.type}Sorting`,\n      })),\n  }))\n}\n\nfunction createDocumentTypeSortings(documentTypes: ConvertedType[]): InputObjectType[] {\n  return documentTypes.map((documentType) => ({\n    name: `${documentType.name}Sorting`,\n    kind: 'InputObject',\n    fields: documentType.fields\n      .filter((field) => field.type !== 'JSON' && field.kind !== 'List')\n      .filter((field) => !field.isReference)\n      .map((field) => ({\n        fieldName: field.fieldName,\n        type: builtInTypes.includes(field.type) ? builtInSortingEnum.name : `${field.type}Sorting`,\n      })),\n  }))\n}\n","import {type ApiSpecification, type GeneratedApiSpecification, type InputObjectType} from '../types'\nimport {generateTypeFilters} from './generateTypeFilters'\nimport {generateTypeQueries} from './generateTypeQueries'\nimport {generateTypeSortings} from './generateTypeSortings'\n\nexport default (extracted: ApiSpecification): GeneratedApiSpecification => {\n  const filters = generateTypeFilters(extracted.types)\n  const sortings = generateTypeSortings(extracted.types)\n  const queries = generateTypeQueries(\n    extracted.types,\n    sortings.filter((node): node is InputObjectType => node.kind === 'InputObject'),\n  )\n  const types = [...extracted.types, ...filters, ...sortings]\n\n  return {types, queries, interfaces: extracted.interfaces, generation: 'gen2'}\n}\n","import {type InputObjectType} from '../../types'\n\nexport function createDocumentFilters(): InputObjectType {\n  return {\n    name: 'Sanity_DocumentFilter',\n    kind: 'InputObject',\n    isConstraintFilter: true,\n    fields: [\n      {\n        fieldName: 'references',\n        type: 'ID',\n        description: 'All documents referencing the given document ID.',\n      },\n      {\n        fieldName: 'is_draft',\n        type: 'Boolean',\n        description: 'All documents that are drafts.',\n      },\n    ],\n  }\n}\n","/**\n * Generates a filter field name for a given field name.\n *\n * @internal\n *\n * @param fieldName - The field name to generate a filter field name for.\n * @param suffix - The suffix to append to the field name. Default is `Filter`.\n */\nexport function getFilterFieldName(fieldName: string, suffix = 'Filter'): string {\n  return `${fieldName}${suffix}`\n}\n","import {createBooleanFilters} from '../gen2/filters/booleanFilters'\nimport {createDateFilters} from '../gen2/filters/dateFilters'\nimport {createDateTimeFilters} from '../gen2/filters/dateTimeFilters'\nimport {createFloatFilters} from '../gen2/filters/floatFilters'\nimport {createIdFilters} from '../gen2/filters/idFilters'\nimport {createIntegerFilters} from '../gen2/filters/integerFilters'\nimport {createStringFilters} from '../gen2/filters/stringFilters'\nimport {isDocumentType, isNonUnion, isUnion} from '../helpers'\nimport {\n  type ApiCustomizationOptions,\n  type ConvertedDocumentType,\n  type ConvertedType,\n  type ConvertedUnion,\n  type InputObjectType,\n} from '../types'\nimport {createDocumentFilters} from './filters/documentFilters'\nimport {getFilterFieldName} from './utils'\n\nconst typeAliases: Record<string, string | undefined> = {\n  Url: 'String',\n  Text: 'String',\n  Email: 'String',\n}\n\ntype FilterCreator = () => InputObjectType\n\nconst filterCreators: Record<string, FilterCreator> = {\n  ID: createIdFilters,\n  String: createStringFilters,\n  Float: createFloatFilters,\n  Integer: createIntegerFilters,\n  Boolean: createBooleanFilters,\n  Datetime: createDateTimeFilters,\n  Date: createDateFilters,\n  Document: createDocumentFilters,\n}\n\nexport function generateTypeFilters(\n  types: (ConvertedType | ConvertedUnion)[],\n  options?: ApiCustomizationOptions,\n): InputObjectType[] {\n  const {filterSuffix} = options || {}\n  const builtInTypeKeys = Object.keys(filterCreators)\n  const builtinTypeValues = Object.values(filterCreators)\n  const objectTypes = types.filter(isNonUnion).filter(\n    (type) =>\n      type.type === 'Object' &&\n      !['Block', 'Span'].includes(type.name) && // TODO: What do we do with blocks?\n      !type.interfaces &&\n      !builtInTypeKeys.includes(type.type),\n  )\n\n  const unionTypes = types.filter(isUnion).map((type) => type.name)\n  const documentTypes = types.filter(\n    (type): type is ConvertedDocumentType => type.name === 'Document' || isDocumentType(type),\n  )\n\n  const builtinTypeFilters = createBuiltinTypeFilters(builtinTypeValues)\n  const objectTypeFilters = createObjectTypeFilters(objectTypes, {unionTypes, filterSuffix})\n  const documentTypeFilters = createDocumentTypeFilters(documentTypes, {unionTypes, filterSuffix})\n\n  return builtinTypeFilters.concat(objectTypeFilters).concat(documentTypeFilters)\n}\n\nfunction createBuiltinTypeFilters(builtinTypeValues: FilterCreator[]): InputObjectType[] {\n  return builtinTypeValues.map((filterCreator) => filterCreator())\n}\n\nfunction createObjectTypeFilters(\n  objectTypes: ConvertedType[],\n  options: {unionTypes: string[]; filterSuffix?: string},\n): InputObjectType[] {\n  return objectTypes.map((objectType) => ({\n    name: getFilterFieldName(objectType.name, options.filterSuffix),\n    kind: 'InputObject',\n    fields: createFieldFilters(objectType, options),\n  }))\n}\n\nfunction createDocumentTypeFilters(\n  documentTypes: ConvertedType[],\n  options: {unionTypes: string[]; filterSuffix?: string},\n): InputObjectType[] {\n  return documentTypes.map((documentType) => ({\n    name: getFilterFieldName(documentType.name, options.filterSuffix),\n    kind: 'InputObject',\n    fields: [...getDocumentFilters(), ...createFieldFilters(documentType, options)],\n  }))\n}\n\nfunction createFieldFilters(\n  objectType: ConvertedType,\n  options: {unionTypes: string[]; filterSuffix?: string},\n) {\n  const {unionTypes} = options\n  if (!objectType.fields) {\n    return []\n  }\n\n  return objectType.fields\n    .filter(\n      (field) => field.type !== 'JSON' && field.kind !== 'List' && !unionTypes.includes(field.type),\n    )\n    .map((field) => {\n      const typeName = typeAliases[field.type] || field.type\n      // If the type is default type than don't add a custom suffix\n      const filterSuffix = Object.keys({...typeAliases, ...filterCreators}).includes(typeName)\n        ? undefined\n        : options.filterSuffix\n\n      return {\n        fieldName: field.fieldName,\n        type: getFilterFieldName(typeAliases[field.type] || field.type, filterSuffix),\n        isReference: field.isReference,\n      }\n    })\n}\n\nfunction getDocumentFilters() {\n  return [\n    {\n      fieldName: '_',\n      type: 'Sanity_DocumentFilter',\n      description: 'Apply filters on document level',\n    },\n  ]\n}\n","import {upperFirst} from 'lodash'\n\nimport {internal} from '../extractFromSanitySchema'\nimport {isDocumentType, isUnion} from '../helpers'\nimport {\n  type ApiCustomizationOptions,\n  type ConvertedType,\n  type ConvertedUnion,\n  type Deprecation,\n  type InputObjectType,\n  type QueryDefinition,\n} from '../types'\nimport {getFilterFieldName} from './utils'\n\nexport function generateTypeQueries(\n  types: (ConvertedType | ConvertedUnion)[],\n  sortings: InputObjectType[],\n  options?: ApiCustomizationOptions,\n): QueryDefinition[] {\n  const {filterSuffix} = options || {}\n  const queries: QueryDefinition[] = []\n  const documentTypes = types.filter(isDocumentType)\n\n  const documentTypeNames = documentTypes.map((docType) =>\n    JSON.stringify(docType.originalName || docType.name),\n  )\n  const documentsFilter = `_type in [${documentTypeNames.join(', ')}]`\n\n  const documentInterface = types.find((type) => type.name === 'Document')\n  if (!documentInterface || isUnion(documentInterface)) {\n    throw new Error('Failed to find document interface')\n  }\n\n  const queryable = [...documentTypes, documentInterface]\n  const isSortable = (type: ConvertedType) =>\n    sortings.some((sorting) => sorting.name === `${type.name}Sorting`)\n\n  // Single ID-based result lookup queries\n  queryable.forEach((type) => {\n    queries.push({\n      fieldName: type.name,\n      type: type.name,\n      constraints: [\n        {\n          field: '_id',\n          comparator: 'eq',\n          value: {kind: 'argumentValue', argName: 'id'},\n        },\n      ],\n      args: [\n        {\n          name: 'id',\n          description: `${type.name} document ID`,\n          type: 'ID',\n          isNullable: false,\n        },\n      ],\n      ...getDeprecation(type),\n    })\n  })\n\n  // Fetch all of type\n  queryable.forEach((type) => {\n    const sorting: QueryDefinition['args'] = []\n    if (isSortable(type)) {\n      sorting.push({\n        name: 'sort',\n        type: {\n          kind: 'List',\n          isNullable: true,\n          children: {\n            type: `${type.name}Sorting`,\n            isNullable: false,\n          },\n        },\n      })\n    }\n\n    queries.push({\n      fieldName: `all${upperFirst(type.name)}`,\n      filter:\n        type.name === 'Document' && type.kind === 'Interface'\n          ? documentsFilter\n          : `_type == ${JSON.stringify(type.originalName || type.name)}`,\n      type: {\n        kind: 'List',\n        isNullable: false,\n        children: {type: type.name, isNullable: false},\n      },\n      args: [\n        {\n          name: 'where',\n          type: getFilterFieldName(type.name, filterSuffix),\n          isFieldFilter: true,\n        },\n        ...sorting,\n        {\n          name: 'limit',\n          type: 'Int',\n          description: 'Max documents to return',\n          isFieldFilter: false,\n        },\n        {\n          name: 'offset',\n          type: 'Int',\n          description: 'Offset at which to start returning documents from',\n          isFieldFilter: false,\n        },\n      ],\n      ...getDeprecation(type),\n    })\n  })\n\n  return queries\n}\n\nfunction getDeprecation(type: ConvertedType): Partial<Deprecation> {\n  return type[internal]?.deprecationReason\n    ? {\n        deprecationReason: type[internal].deprecationReason,\n      }\n    : {}\n}\n","import {isDocumentType, isNonUnion} from '../helpers'\nimport {\n  type ConvertedDocumentType,\n  type ConvertedEnum,\n  type ConvertedType,\n  type ConvertedUnion,\n  type InputObjectType,\n} from '../types'\n\nconst builtInTypes = [\n  'Boolean',\n  'Date',\n  'Datetime',\n  'Email',\n  'Float',\n  'ID',\n  'Integer',\n  'String',\n  'Text',\n  'Url',\n]\n\nconst builtInSortingEnum: ConvertedEnum = {\n  name: 'SortOrder',\n  kind: 'Enum',\n  values: [\n    {\n      name: 'ASC',\n      description: 'Sorts on the value in ascending order.',\n      value: 1,\n    },\n    {\n      name: 'DESC',\n      description: 'Sorts on the value in descending order.',\n      value: 2,\n    },\n  ],\n}\n\nexport function generateTypeSortings(\n  types: (ConvertedType | ConvertedUnion)[],\n): (InputObjectType | ConvertedEnum)[] {\n  const objectTypes = types.filter(isNonUnion).filter(\n    (type) =>\n      type.type === 'Object' &&\n      !['Block', 'Span'].includes(type.name) && // TODO: What do we do with blocks?\n      !type.interfaces &&\n      !builtInTypes.includes(type.name),\n  )\n  const documentTypes = types.filter(\n    (type): type is ConvertedDocumentType => type.name === 'Document' || isDocumentType(type),\n  )\n\n  const hasFields = (type: InputObjectType) => type.fields.length > 0\n\n  const objectTypeSortings = createObjectTypeSortings(objectTypes)\n  const documentTypeSortings = createDocumentTypeSortings(documentTypes)\n  const allSortings = [...objectTypeSortings, ...documentTypeSortings].filter(hasFields)\n\n  return [...allSortings, builtInSortingEnum]\n}\n\nfunction createObjectTypeSortings(objectTypes: ConvertedType[]): InputObjectType[] {\n  return objectTypes.map((objectType) => ({\n    name: `${objectType.name}Sorting`,\n    kind: 'InputObject',\n    fields: objectType.fields\n      .filter((field) => field.type !== 'JSON' && field.kind !== 'List')\n      .filter((field) => !field.isReference)\n      .map((field) => ({\n        fieldName: field.fieldName,\n        type: builtInTypes.includes(field.type) ? builtInSortingEnum.name : `${field.type}Sorting`,\n      })),\n  }))\n}\n\nfunction createDocumentTypeSortings(documentTypes: ConvertedType[]): InputObjectType[] {\n  return documentTypes.map((documentType) => ({\n    name: `${documentType.name}Sorting`,\n    kind: 'InputObject',\n    fields: documentType.fields\n      .filter((field) => field.type !== 'JSON' && field.kind !== 'List')\n      .filter((field) => !field.isReference)\n      .map((field) => ({\n        fieldName: field.fieldName,\n        type: builtInTypes.includes(field.type) ? builtInSortingEnum.name : `${field.type}Sorting`,\n      })),\n  }))\n}\n","import {isUnion} from '../helpers'\nimport {\n  type ApiCustomizationOptions,\n  type ApiSpecification,\n  type ConvertedType,\n  type GeneratedApiSpecification,\n  type InputObjectType,\n} from '../types'\nimport {generateTypeFilters} from './generateTypeFilters'\nimport {generateTypeQueries} from './generateTypeQueries'\nimport {generateTypeSortings} from './generateTypeSortings'\n\nexport default (\n  extracted: ApiSpecification,\n  options?: ApiCustomizationOptions,\n): GeneratedApiSpecification => {\n  const documentInterface = extracted.interfaces.find((iface) => iface.name === 'Document')\n  if (!documentInterface || isUnion(documentInterface)) {\n    throw new Error('Failed to find document interface')\n  }\n\n  const types = [...extracted.types, documentInterface as ConvertedType]\n\n  const filters = generateTypeFilters(types, options)\n  const sortings = generateTypeSortings(types)\n  const queries = generateTypeQueries(\n    types,\n    sortings.filter((node): node is InputObjectType => node.kind === 'InputObject'),\n    options,\n  )\n  const graphqlTypes = [...extracted.types, ...filters, ...sortings]\n\n  return {types: graphqlTypes, queries, interfaces: extracted.interfaces, generation: 'gen3'}\n}\n","/* eslint-disable no-process-env, no-process-exit, max-statements */\nimport {type CliCommandContext, type CliOutputter, type CliPrompter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport {get} from 'lodash'\nimport oneline from 'oneline'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport {debug} from '../../debug'\nimport {getClientUrl} from '../../util/getClientUrl'\nimport {getUrlHeaders} from '../../util/getUrlHeaders'\nimport {extractFromSanitySchema} from './extractFromSanitySchema'\nimport gen1 from './gen1'\nimport gen2 from './gen2'\nimport gen3 from './gen3'\nimport {getGraphQLAPIs} from './getGraphQLAPIs'\nimport {SchemaError} from './SchemaError'\nimport {type DeployResponse, type GeneratedApiSpecification, type ValidationResponse} from './types'\n\nconst latestGeneration = 'gen3'\nconst generations = {\n  gen1,\n  gen2,\n  gen3,\n}\n\nconst apiIdRegex = /^[a-z0-9_-]+$/\nconst isInteractive = process.stdout.isTTY && process.env.TERM !== 'dumb' && !('CI' in process.env)\n\nconst ignoredWarnings: string[] = ['OPTIONAL_INPUT_FIELD_ADDED']\nconst ignoredBreaking: string[] = []\n\ninterface DeployTask {\n  dataset: string\n  projectId: string\n  tag: string\n  enablePlayground: boolean\n  schema: GeneratedApiSpecification\n}\n\n// eslint-disable-next-line complexity\nexport default async function deployGraphQLApiAction(\n  args: {argv?: string[]},\n  context: CliCommandContext,\n): Promise<void> {\n  // Reparsing CLI flags for better control of binary flags\n  const flags = await parseCliFlags(args)\n  const {\n    force,\n    dryRun,\n    'api': onlyApis,\n    'dataset': datasetFlag,\n    'tag': tagFlag,\n    'playground': playgroundFlag,\n    'generation': generationFlag,\n    'non-null-document-fields': nonNullDocumentFieldsFlag,\n    withUnionCache,\n  } = flags\n\n  const {apiClient, output, prompt} = context\n\n  let spinner\n\n  const client = apiClient({\n    requireUser: true,\n    // Don't throw if we do not have a project ID defined, as we will infer it from the\n    // source/ workspace of each configured API later\n    requireProject: false,\n  }).config({apiVersion: '2023-08-01'})\n\n  const apiDefs = await getGraphQLAPIs(context)\n\n  let hasMultipleApis = apiDefs.length > 1\n  if (flags.api) {\n    hasMultipleApis = flags.api.length > 1\n  }\n\n  const usedFlags = [\n    datasetFlag && '--dataset',\n    tagFlag && '--tag',\n    typeof playgroundFlag !== 'undefined' && '--playground',\n    typeof generationFlag !== 'undefined' && '--generation',\n    typeof nonNullDocumentFieldsFlag !== 'undefined' && '--non-null-document-fields',\n  ].filter(Boolean)\n\n  if (hasMultipleApis && usedFlags.length > 0) {\n    output.warn(`WARN: More than one API defined, and ${usedFlags.join('/')} is specified`)\n    output.warn(`WARN: This will use the specified flag(s) for ALL APIs, overriding config!`)\n\n    if (flags.force) {\n      output.warn(`WARN: --force specified, continuing...`)\n    } else if (\n      !(await prompt.single({\n        type: 'confirm',\n        message: 'Continue with flag overrides for all APIs?',\n        default: false,\n      }))\n    ) {\n      process.exit(1)\n    }\n  }\n\n  const deployTasks: DeployTask[] = []\n\n  for (const apiId of onlyApis || []) {\n    if (!apiDefs.some((apiDef) => apiDef.id === apiId)) {\n      throw new Error(`GraphQL API with id \"${apiId}\" not found`)\n    }\n  }\n\n  const apiNames = new Set<string>()\n  const apiIds = new Set<string>()\n  for (const apiDef of apiDefs) {\n    if (onlyApis && (!apiDef.id || !onlyApis.includes(apiDef.id))) {\n      continue\n    }\n\n    const dataset = datasetFlag || apiDef.dataset\n    const tag = tagFlag || apiDef.tag || 'default'\n    const apiName = [dataset, tag].join('/')\n    if (apiNames.has(apiName)) {\n      throw new Error(`Multiple GraphQL APIs with the same dataset and tag found (${apiName})`)\n    }\n\n    if (apiDef.id) {\n      if (typeof apiDef.id !== 'string' || !apiIdRegex.test(apiDef.id)) {\n        throw new Error(\n          `Invalid GraphQL API id \"${apiDef.id}\" - only a-z, 0-9, underscore and dashes are allowed`,\n        )\n      }\n\n      if (apiIds.has(apiDef.id)) {\n        throw new Error(`Multiple GraphQL APIs with the same ID found (${apiDef.id})`)\n      }\n\n      apiIds.add(apiDef.id)\n    }\n\n    apiNames.add(apiName)\n  }\n\n  if (onlyApis) {\n    output.warn(`Deploying only specified APIs: ${onlyApis.join(', ')}`)\n  }\n\n  process.exitCode = 0\n  let index = -1\n  for (const apiDef of apiDefs) {\n    if (onlyApis && (!apiDef.id || !onlyApis.includes(apiDef.id))) {\n      continue\n    }\n\n    index++\n\n    const dataset = datasetFlag || apiDef.dataset\n    const tag = tagFlag || apiDef.tag || 'default'\n    const {projectId, playground, nonNullDocumentFields, schema} = apiDef\n    const apiName = [dataset, tag].join('/')\n    spinner = output.spinner(`Generating GraphQL API: ${apiName}`).start()\n\n    if (!dataset) {\n      throw new Error(`No dataset specified for API at index ${index}`)\n    }\n\n    const projectClient = client.clone().config({projectId, useProjectHostname: true})\n    const {currentGeneration, playgroundEnabled} = await getCurrentSchemaProps(\n      projectClient,\n      dataset,\n      tag,\n    )\n\n    // CLI flag trumps configuration\n    const specifiedGeneration =\n      typeof generationFlag === 'undefined' ? apiDef.generation : generationFlag\n\n    const generation = await resolveApiGeneration({\n      currentGeneration,\n      specifiedGeneration,\n      index,\n      force,\n      output,\n      prompt,\n    })\n\n    if (!generation) {\n      // User cancelled\n      spinner.fail()\n      continue\n    }\n\n    if (!isRecognizedApiGeneration(generation)) {\n      throw new Error(`Unknown API generation \"${generation}\" for API at index ${index}`)\n    }\n\n    const enablePlayground = await shouldEnablePlayground({\n      dryRun,\n      spinner,\n      playgroundCliFlag: playgroundFlag,\n      playgroundConfiguration: playground,\n      playgroundCurrentlyEnabled: playgroundEnabled,\n      prompt,\n    })\n\n    let apiSpec: GeneratedApiSpecification\n    try {\n      const generateSchema = generations[generation]\n      const extracted = extractFromSanitySchema(schema, {\n        // Allow CLI flag to override configured setting\n        nonNullDocumentFields:\n          typeof nonNullDocumentFieldsFlag === 'undefined'\n            ? nonNullDocumentFields\n            : nonNullDocumentFieldsFlag,\n        withUnionCache,\n      })\n\n      apiSpec = generateSchema(extracted, {filterSuffix: apiDef.filterSuffix})\n    } catch (err) {\n      spinner.fail()\n\n      if (err instanceof SchemaError) {\n        err.print(output)\n        process.exitCode = 1\n      }\n\n      throw err\n    }\n\n    let valid: ValidationResponse | undefined\n    try {\n      valid = await projectClient.request<ValidationResponse>({\n        url: `/apis/graphql/${dataset}/${tag}/validate`,\n        method: 'POST',\n        body: {enablePlayground, schema: apiSpec},\n        maxRedirects: 0,\n      })\n    } catch (err) {\n      const validationError = get(err, 'response.body.validationError')\n      spinner.fail()\n      throw validationError ? new Error(validationError) : err\n    }\n\n    // when the result is not valid and there are breaking changes afoot!\n    if (!isResultValid(valid, {spinner, force})) {\n      // not valid and a dry run? then it can exit with a error\n      if (dryRun) {\n        spinner.fail()\n        renderBreakingChanges(valid, output)\n        process.exitCode = 1\n        continue\n      }\n\n      if (!isInteractive) {\n        spinner.fail()\n        renderBreakingChanges(valid, output)\n        throw new Error(\n          'Dangerous changes found - falling back. Re-run the command with the `--force` flag to force deployment.',\n        )\n      }\n\n      spinner.stop()\n      renderBreakingChanges(valid, output)\n      const shouldDeploy = await prompt.single({\n        type: 'confirm',\n        message: 'Do you want to deploy a new API despite the dangerous changes?',\n        default: false,\n      })\n\n      if (!shouldDeploy) {\n        spinner.fail()\n        continue\n      }\n\n      spinner.succeed()\n    } else if (dryRun) {\n      spinner.succeed()\n      output.print('GraphQL API is valid and has no breaking changes')\n      continue\n    }\n\n    deployTasks.push({\n      projectId,\n      dataset,\n      tag,\n      enablePlayground,\n      schema: apiSpec,\n    })\n  }\n\n  // Give some space for deployment tasks\n  output.print('')\n\n  for (const task of deployTasks) {\n    const {dataset, tag, schema, projectId, enablePlayground} = task\n\n    output.print(`Project: ${projectId}`)\n    output.print(`Dataset: ${dataset}`)\n    output.print(`Tag:     ${tag}`)\n\n    spinner = output.spinner('Deploying GraphQL API').start()\n\n    try {\n      const projectClient = client.clone().config({projectId, useProjectHostname: true})\n      const response = await projectClient.request<DeployResponse>({\n        url: `/apis/graphql/${dataset}/${tag}`,\n        method: 'PUT',\n        body: {enablePlayground, schema},\n        maxRedirects: 0,\n      })\n\n      spinner.stop()\n      const apiUrl = getClientUrl(\n        projectClient,\n        response.location.replace(/^\\/(v1|v\\d{4}-\\d{2}-\\d{2})\\//, '/'),\n      )\n      output.print(`URL:     ${apiUrl}`)\n      spinner.start('Deployed!').succeed()\n      output.print('')\n    } catch (err) {\n      spinner.fail()\n      throw err\n    }\n  }\n\n  // Because of side effects when loading the schema, we can end up in situations where\n  // the API has been successfully deployed, but some timer or other handle is keeping\n  // the process from naturally exiting.\n\n  process.exit(process.exitCode)\n}\n\nasync function shouldEnablePlayground({\n  dryRun,\n  spinner,\n  playgroundCliFlag,\n  playgroundConfiguration,\n  playgroundCurrentlyEnabled,\n  prompt,\n}: {\n  dryRun: boolean\n  spinner: ReturnType<CliCommandContext['output']['spinner']>\n  playgroundCliFlag?: boolean\n  playgroundConfiguration?: boolean\n  playgroundCurrentlyEnabled?: boolean\n  prompt: CliCommandContext['prompt']\n}): Promise<boolean> {\n  // On a dry run, it doesn't matter, return true 🤷‍♂️\n  if (dryRun) {\n    return true\n  }\n\n  // Prioritize CLI flag if set\n  if (typeof playgroundCliFlag !== 'undefined') {\n    return playgroundCliFlag\n  }\n\n  // If explicitly set true/false in configuration, use that\n  if (typeof playgroundConfiguration !== 'undefined') {\n    return playgroundConfiguration\n  }\n\n  // If API is already deployed, use the current state\n  if (typeof playgroundCurrentlyEnabled !== 'undefined') {\n    return playgroundCurrentlyEnabled\n  }\n\n  // If no API is deployed, default to true if non-interactive\n  if (!isInteractive) {\n    return true\n  }\n\n  // Interactive environment, so prompt the user\n  const prevText = spinner.text\n  spinner.warn()\n  const shouldDeploy = await prompt.single<boolean>({\n    type: 'confirm',\n    message: 'Do you want to enable a GraphQL playground?',\n    default: true,\n  })\n  spinner.clear().start(prevText)\n\n  return shouldDeploy\n}\n\nasync function getCurrentSchemaProps(\n  client: SanityClient,\n  dataset: string,\n  tag: string,\n): Promise<{\n  currentGeneration?: string\n  playgroundEnabled?: boolean\n}> {\n  try {\n    const apiUrl = getClientUrl(client, `/apis/graphql/${dataset}/${tag}`)\n    const res = await getUrlHeaders(apiUrl, {\n      Authorization: `Bearer ${client.config().token}`,\n    })\n\n    return {\n      currentGeneration: res['x-sanity-graphql-generation'],\n      playgroundEnabled: res['x-sanity-graphql-playground'] === 'true',\n    }\n  } catch (err) {\n    if (err.statusCode === 404) {\n      return {}\n    }\n\n    throw err\n  }\n}\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2))\n    .option('tag', {type: 'string'})\n    .option('dataset', {type: 'string'})\n    .option('api', {type: 'string', array: true})\n    .option('dry-run', {type: 'boolean', default: false})\n    .option('generation', {type: 'string'})\n    .option('non-null-document-fields', {type: 'boolean'})\n    .option('playground', {type: 'boolean'})\n    .option('with-union-cache', {type: 'boolean'})\n    .option('force', {type: 'boolean'}).argv\n}\n\nfunction isResultValid(\n  valid: ValidationResponse,\n  {spinner, force}: {spinner: any; force?: boolean},\n) {\n  const {validationError, breakingChanges: breaking, dangerousChanges: dangerous} = valid\n  if (validationError) {\n    spinner.fail()\n    throw new Error(`GraphQL schema is not valid:\\n\\n${validationError}`)\n  }\n\n  const breakingChanges = breaking.filter((change) => !ignoredBreaking.includes(change.type))\n  const dangerousChanges = dangerous.filter((change) => !ignoredWarnings.includes(change.type))\n\n  const hasProblematicChanges = breakingChanges.length > 0 || dangerousChanges.length > 0\n  if (force && hasProblematicChanges) {\n    spinner.text = 'Validating GraphQL API: Dangerous changes. Forced with `--force`.'\n    spinner.warn()\n    return true\n  } else if (force || !hasProblematicChanges) {\n    spinner.succeed()\n    return true\n  }\n\n  spinner.warn()\n  return false\n}\n\nfunction renderBreakingChanges(valid: ValidationResponse, output: CliOutputter) {\n  const {breakingChanges: breaking, dangerousChanges: dangerous} = valid\n\n  const breakingChanges = breaking.filter((change) => !ignoredBreaking.includes(change.type))\n  const dangerousChanges = dangerous.filter((change) => !ignoredWarnings.includes(change.type))\n\n  if (dangerousChanges.length > 0) {\n    output.print('\\nFound potentially dangerous changes from previous schema:')\n    dangerousChanges.forEach((change) => output.print(` - ${change.description}`))\n  }\n\n  if (breakingChanges.length > 0) {\n    output.print('\\nFound BREAKING changes from previous schema:')\n    breakingChanges.forEach((change) => output.print(` - ${change.description}`))\n  }\n\n  output.print('')\n}\n\nasync function resolveApiGeneration({\n  currentGeneration,\n  specifiedGeneration,\n  index,\n  force,\n  output,\n  prompt,\n}: {\n  index: number\n  currentGeneration?: string\n  specifiedGeneration?: string\n  force?: boolean\n  output: CliOutputter\n  prompt: CliPrompter\n}): Promise<string | undefined> {\n  // a) If no API is currently deployed:\n  //    use the specificed one from config, or use whichever generation is the latest\n  // b) If an API generation is specified explicitly:\n  //    use the given one, but _prompt_ if it differs from the current one\n  // c) If no API generation is specified explicitly:\n  //    use whichever is already deployed, but warn if differs from latest\n  if (!currentGeneration) {\n    const generation = specifiedGeneration || latestGeneration\n    debug(\n      'There is no current generation deployed, using %s (%s)',\n      generation,\n      specifiedGeneration ? 'specified' : 'default',\n    )\n    return generation\n  }\n\n  if (specifiedGeneration && specifiedGeneration !== currentGeneration) {\n    if (!force && !isInteractive) {\n      throw new Error(oneline`\n        Specified generation (${specifiedGeneration}) for API at index ${index} differs from the one currently deployed (${currentGeneration}).\n        Re-run the command with \\`--force\\` to force deployment.\n      `)\n    }\n\n    output.warn(\n      `Specified generation (${specifiedGeneration}) for API at index ${index} differs from the one currently deployed (${currentGeneration}).`,\n    )\n\n    const confirmDeploy =\n      force ||\n      (await prompt.single({\n        type: 'confirm',\n        message: 'Are you sure you want to deploy?',\n        default: false,\n      }))\n\n    return confirmDeploy ? specifiedGeneration : undefined\n  }\n\n  if (specifiedGeneration) {\n    debug('Using specified (%s) generation', specifiedGeneration)\n    return specifiedGeneration\n  }\n\n  debug('Using the currently deployed version (%s)', currentGeneration)\n  return currentGeneration\n}\n\nfunction isRecognizedApiGeneration(generation: string): generation is 'gen1' | 'gen2' | 'gen3' {\n  return generations.hasOwnProperty(generation)\n}\n"],"names":["request","getIt","promise","HttpError","Error","constructor","message","name","getUrlHeaders","url","headers","response","stream","maxRedirects","method","statusCode","error","body","resume","SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE","consoleOutputter","args","console","SchemaError","problemGroups","print","output","forEach","group","problems","problem","icon","logSymbols","severity","info","upperFirst","getPath","path","helpId","generateHelpUrl","map","segment","kind","type","filter","Boolean","join","skipTypes","allowedJsonTypes","disallowedCustomizedMembers","disabledBlockFields","scalars","internal","Symbol","getBaseType","baseSchema","typeName","Schema","compile","types","_original","concat","to","get","options","hotspot","getTypeName","str","startCase","replace","isBaseType","jsonType","includes","isReference","isBlockType","typeDef","hasBlockParent","isArrayOfBlocks","of","some","isType","isCrossDatasetReference","getCrossDatasetReferenceMetadata","getTypeNames","t","getDataset","dataset","typeNames","extractFromSanitySchema","sanitySchema","extractOptions","nonNullDocumentFields","withUnionCache","unionRecursionGuards","Set","unionDefinitionCache","Map","_validation","Array","isArray","sanityTypes","unionTypes","schemaType","undefined","convertedType","convertType","push","interfaces","getDocumentInterfaceDefinition","isTopLevelType","mapFieldType","field","isScalar","hasValidationFlag","isArrayType","_convertType","parent","getReferenceDefinition","getArrayDefinition","getDocumentDefinition","hasFields","getObjectDefinition","description","getDescription","props","mapped","isField","fieldName","gqlName","originalName","original","crossDatasetReferenceMetadata","getDeprecation","def","isInline","isDocument","actualType","typeNeedsHoisting","createLiftTypeError","fields","collectFields","firstUnprefixed","Math","max","findIndex","keyField","createStringField","splice","objectFields","buildRawField","parentName","isRawAlias","gatherAllFields","length","extended","base","candidates","arrayify","gatherAllReferenceCandidates","allTypeNames","c","targetTypes","sort","item","children","getArrayChildDefinition","getUnionDefinition","grandParent","child","arrayDef","isCustomized","guardPathName","has","unionCacheKey","add","i","createLiftTypeArrayError","converted","getName","flattened","reduce","acc","candidate","union","find","allCandidatesAreDocuments","refs","inlineObjs","possibleTypes","references","inlineObjects","unionDefinition","set","delete","objectDef","getDocumentInterfaceFields","isNullable","thing","flag","validation","rule","_rules","allFields","gatherReferenceCandidates","uniqBy","refTo","gatherFields","hasFieldsLikeShape","hasArrayOfFields","index","inlineType","helpUrl","helpUrls","context","HelpfulError","oneline","isDeprecationConfiguration","deprecationReason","deprecated","reason","isUnion","isNonUnion","isDocumentType","filterCreators","ID","createIdFilters","String","createStringFilters","Url","Float","createNumberFilters","Integer","createBooleanFilters","Datetime","createDateFilters","Date","Object","createObjectFilters","generateTypeFilters","flatten","createFieldFilters","getDocumentFilters","createListFilters","createReferenceFilters","createInlineTypeFilters","getFieldName","modifier","suffix","constraint","comparator","createIsDefinedFilter","createEqualityFilter","createInequalityFilter","createDefaultFilters","createGtLtFilters","pluralizeTypeName","words","split","last","plural","pluralize","toLowerCase","generateTypeQueries","filters","queries","queryable","constraints","value","argName","filterName","hasFilter","isFieldFilter","getLimitOffsetArgs","extracted","generation","isConstraintFilter","createDateTimeFilters","createDocumentFilters","createFloatFilters","createIntegerFilters","typeAliases","Text","Email","Document","builtInTypeKeys","keys","builtinTypeValues","values","objectTypes","documentTypes","builtinTypeFilters","createBuiltinTypeFilters","objectTypeFilters","createObjectTypeFilters","documentTypeFilters","createDocumentTypeFilters","filterCreator","objectType","documentType","sortings","isSortable","sorting","builtInTypes","builtInSortingEnum","generateTypeSortings","objectTypeSortings","createObjectTypeSortings","documentTypeSortings","createDocumentTypeSortings","node","getFilterFieldName","filterSuffix","documentsFilter","docType","JSON","stringify","documentInterface","iface","latestGeneration","generations","gen1","gen2","gen3","apiIdRegex","isInteractive","process","stdout","isTTY","env","TERM","ignoredWarnings","ignoredBreaking","deployGraphQLApiAction","flags","parseCliFlags","force","dryRun","onlyApis","datasetFlag","tagFlag","playgroundFlag","generationFlag","nonNullDocumentFieldsFlag","apiClient","prompt","spinner","client","requireUser","requireProject","config","apiVersion","apiDefs","getGraphQLAPIs","hasMultipleApis","api","usedFlags","warn","single","default","exit","deployTasks","apiId","apiDef","id","apiNames","apiIds","tag","apiName","test","exitCode","projectId","playground","schema","start","projectClient","clone","useProjectHostname","currentGeneration","playgroundEnabled","getCurrentSchemaProps","specifiedGeneration","resolveApiGeneration","fail","isRecognizedApiGeneration","enablePlayground","shouldEnablePlayground","playgroundCliFlag","playgroundConfiguration","playgroundCurrentlyEnabled","apiSpec","generateSchema","err","valid","validationError","isResultValid","succeed","renderBreakingChanges","stop","task","apiUrl","getClientUrl","location","prevText","text","shouldDeploy","clear","res","Authorization","token","yargs","hideBin","argv","slice","option","array","breakingChanges","breaking","dangerousChanges","dangerous","change","hasProblematicChanges","debug","hasOwnProperty"],"mappings":"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"}