"use strict";
var chalk = require("chalk"), partition = require("lodash/partition"), schemaApiClient = require("./schemaApiClient.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), partition__default = /* @__PURE__ */ _interopDefaultCompat(partition);
function getWorkspaceSchemaId(args) {
  const {
    workspaceName: rawWorkspaceName,
    idPrefix
  } = args;
  let workspaceName = rawWorkspaceName, idWarning;
  return workspaceName.match(schemaApiClient.validForIdPattern) || (workspaceName = workspaceName.replace(new RegExp(`[^${schemaApiClient.validForIdChars}]`, "g"), "_"), idWarning = [`Workspace "${rawWorkspaceName}" contains characters unsupported by schema _id [${schemaApiClient.validForIdChars}], they will be replaced with _.`, "This could lead duplicate schema ids: consider renaming your workspace."].join(`
`)), {
    safeId: `${idPrefix ? `${idPrefix}.` : ""}${schemaApiClient.SANITY_WORKSPACE_SCHEMA_TYPE}.${workspaceName}`,
    idWarning
  };
}
function deploySchemasActionForCommand(flags, context) {
  return deploySchemasAction({
    ...flags,
    //invoking the command through CLI implies that schema is required
    "schema-required": !0
  }, {
    ...context,
    manifestExtractor: schemaApiClient.createManifestExtractor(context)
  });
}
async function deploySchemasAction(flags, context) {
  const {
    workspaceName,
    verbose,
    idPrefix,
    manifestDir,
    extractManifest,
    schemaRequired
  } = schemaApiClient.parseDeploySchemasConfig(flags, context), {
    output,
    apiClient,
    jsonReader,
    manifestExtractor
  } = context;
  if (!await schemaApiClient.ensureManifestExtractSatisfied({
    schemaRequired,
    extractManifest,
    manifestDir,
    manifestExtractor,
    output
  }))
    return "failure";
  try {
    const {
      client,
      projectId
    } = schemaApiClient.createSchemaApiClient(apiClient), manifestReader = schemaApiClient.createManifestReader({
      manifestDir,
      output,
      jsonReader
    }), manifest = await manifestReader.getManifest(), storeWorkspaceSchema = createStoreWorkspaceSchema({
      idPrefix,
      projectId,
      verbose,
      client,
      output,
      manifestReader
    }), targetWorkspaces = manifest.workspaces.filter((workspace) => !workspaceName || workspace.name === workspaceName);
    if (!targetWorkspaces.length)
      throw workspaceName ? new schemaApiClient.FlagValidationError(`Found no workspaces named "${workspaceName}"`) : new Error("Workspace array in manifest is empty.");
    const results = await Promise.allSettled(targetWorkspaces.map(async (workspace) => {
      await storeWorkspaceSchema(workspace);
    })), [successes, failures] = partition__default.default(results, (result) => result.status === "fulfilled");
    if (failures.length)
      throw new Error(`Failed to deploy ${failures.length}/${targetWorkspaces.length} schemas. Successfully deployed ${successes.length}/${targetWorkspaces.length} schemas.`);
    return output.success(`Deployed ${successes.length}/${targetWorkspaces.length} schemas`), "success";
  } catch (err) {
    if (schemaRequired || err instanceof schemaApiClient.FlagValidationError)
      throw err;
    return output.print(`\u21B3 Error when storing schemas:
  ${err.message}`), "failure";
  } finally {
    output.print(`${chalk__default.default.gray("\u21B3 List deployed schemas with:")} ${chalk__default.default.cyan("sanity schema list")}`);
  }
}
function createStoreWorkspaceSchema(args) {
  const {
    idPrefix,
    projectId,
    verbose,
    client,
    output,
    manifestReader
  } = args;
  return async (workspace) => {
    const {
      safeId: id,
      idWarning
    } = getWorkspaceSchemaId({
      workspaceName: workspace.name,
      idPrefix
    });
    idWarning && output.warn(idWarning);
    try {
      schemaApiClient.throwWriteProjectIdMismatch(workspace, projectId);
      const schema = await manifestReader.getWorkspaceSchema(workspace.name), storedWorkspaceSchema = {
        _type: schemaApiClient.SANITY_WORKSPACE_SCHEMA_TYPE,
        _id: id,
        workspace,
        // we have to stringify the schema to save on attribute paths
        schema: JSON.stringify(schema)
      };
      await client.withConfig({
        dataset: workspace.dataset,
        projectId: workspace.projectId
      }).createOrReplace(storedWorkspaceSchema), verbose && output.print(chalk__default.default.gray(`\u21B3 schemaId: ${id}, projectId: ${projectId}, dataset: ${workspace.dataset}`));
    } catch (err) {
      throw output.error(`\u21B3 Error deploying schema for workspace "${workspace.name}":
  ${chalk__default.default.red(`${err.message}`)}`), err;
    }
  };
}
exports.default = deploySchemasActionForCommand;
exports.deploySchemasAction = deploySchemasAction;
//# sourceMappingURL=deploySchemasAction.js.map
