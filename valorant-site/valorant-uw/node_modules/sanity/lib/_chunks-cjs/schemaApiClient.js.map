{"version":3,"file":"schemaApiClient.js","sources":["../../src/_internal/manifest/manifestTypes.ts","../../src/_internal/manifest/manifestTypeHelpers.ts","../../src/_internal/cli/actions/schema/utils/manifestReader.ts","../../src/_internal/cli/actions/schema/utils/schemaStoreValidation.ts","../../src/_internal/cli/actions/schema/utils/mainfestExtractor.ts","../../src/_internal/cli/actions/schema/utils/schemaApiClient.ts"],"sourcesContent":["import {type SanityDocumentLike} from '@sanity/types'\n\nexport const SANITY_WORKSPACE_SCHEMA_TYPE = 'sanity.workspace.schema'\n\nexport type ManifestSerializable =\n  | string\n  | number\n  | boolean\n  | {[k: string]: ManifestSerializable}\n  | ManifestSerializable[]\n\nexport interface CreateManifest {\n  version: number\n  createdAt: string\n  workspaces: ManifestWorkspaceFile[]\n}\n\nexport interface ManifestWorkspaceFile extends Omit<CreateWorkspaceManifest, 'schema' | 'tools'> {\n  schema: string // filename\n  tools: string // filename\n}\n\nexport interface CreateWorkspaceManifest {\n  name: string\n  title?: string\n  subtitle?: string\n  basePath: string\n  dataset: string\n  projectId: string\n  schema: ManifestSchemaType[]\n  tools: ManifestTool[]\n  /**\n   * returns null in the case of the icon not being able to be stringified\n   */\n  icon: string | null\n}\n\nexport interface ManifestSchemaType {\n  type: string\n  name: string\n  title?: string\n  deprecated?: {\n    reason: string\n  }\n  readOnly?: boolean | 'conditional'\n  hidden?: boolean | 'conditional'\n  validation?: ManifestValidationGroup[]\n  fields?: ManifestField[]\n  to?: ManifestReferenceMember[]\n  of?: ManifestArrayMember[]\n  preview?: {\n    select: Record<string, string>\n  }\n  fieldsets?: ManifestFieldset[]\n  options?: Record<string, ManifestSerializable>\n  //portable text\n  marks?: {\n    annotations?: ManifestArrayMember[]\n    decorators?: ManifestTitledValue[]\n  }\n  lists?: ManifestTitledValue[]\n  styles?: ManifestTitledValue[]\n\n  // userland (assignable to ManifestSerializable | undefined)\n  // not included to add some typesafty to extractManifest\n  // [index: string]: unknown\n}\n\nexport interface ManifestFieldset {\n  name: string\n  title?: string\n  [index: string]: ManifestSerializable | undefined\n}\n\nexport interface ManifestTitledValue {\n  value: string\n  title?: string\n}\n\nexport type ManifestField = ManifestSchemaType & {fieldset?: string}\nexport type ManifestArrayMember = Omit<ManifestSchemaType, 'name'> & {name?: string}\nexport type ManifestReferenceMember = Omit<ManifestSchemaType, 'name'> & {name?: string}\n\nexport interface ManifestValidationGroup {\n  rules: ManifestValidationRule[]\n  message?: string\n  level?: 'error' | 'warning' | 'info'\n}\n\nexport type ManifestValidationRule = {\n  flag: string\n  constraint?: ManifestSerializable\n  [index: string]: ManifestSerializable | undefined\n}\n\nexport interface ManifestTool {\n  name: string\n  title: string\n  /**\n   * returns null in the case of the icon not being able to be stringified\n   */\n  icon: string | null\n  type: string | null\n}\n\nexport type DefaultWorkspaceSchemaId = `${typeof SANITY_WORKSPACE_SCHEMA_TYPE}.${string}`\nexport type PrefixedWorkspaceSchemaId = `${string}.${DefaultWorkspaceSchemaId}`\nexport type WorkspaceSchemaId = DefaultWorkspaceSchemaId | PrefixedWorkspaceSchemaId\n\nexport interface StoredWorkspaceSchema extends SanityDocumentLike {\n  _type: typeof SANITY_WORKSPACE_SCHEMA_TYPE\n  _id: WorkspaceSchemaId\n  workspace: ManifestWorkspaceFile\n  /**\n   * JSON.stringify version of ManifestSchemaType[] to save on attribute paths.\n   * Consumers must use JSON.parse on the value.\n   */\n  schema: string\n  //schema: ManifestSchemaType[]\n}\n","import {\n  type CrossDatasetReferenceSchemaType,\n  type ObjectField,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type SchemaType,\n} from '@sanity/types'\n\nconst DEFAULT_IMAGE_FIELDS = ['asset', 'hotspot', 'crop', 'media']\nconst DEFAULT_FILE_FIELDS = ['asset', 'media']\nconst DEFAULT_GEOPOINT_FIELDS = ['lat', 'lng', 'alt']\nconst DEFAULT_SLUG_FIELDS = ['current', 'source']\n\nexport function getCustomFields(type: ObjectSchemaType): (ObjectField & {fieldset?: string})[] {\n  const fields = type.fieldsets\n    ? type.fieldsets.flatMap((fs) => {\n        if (fs.single) {\n          return fs.field\n        }\n        return fs.fields.map((field) => ({\n          ...field,\n          fieldset: fs.name,\n        }))\n      })\n    : type.fields\n\n  if (isType(type, 'block')) {\n    return []\n  }\n  if (isType(type, 'slug')) {\n    return fields.filter((f) => !DEFAULT_SLUG_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'geopoint')) {\n    return fields.filter((f) => !DEFAULT_GEOPOINT_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'image')) {\n    return fields.filter((f) => !DEFAULT_IMAGE_FIELDS.includes(f.name))\n  }\n  if (isType(type, 'file')) {\n    return fields.filter((f) => !DEFAULT_FILE_FIELDS.includes(f.name))\n  }\n  return fields\n}\n\nexport function isReference(type: SchemaType): type is ReferenceSchemaType {\n  return isType(type, 'reference')\n}\n\nexport function isCrossDatasetReference(type: SchemaType): type is CrossDatasetReferenceSchemaType {\n  return isType(type, 'crossDatasetReference')\n}\n\nexport function isObjectField(maybeOjectField: unknown): boolean {\n  return (\n    typeof maybeOjectField === 'object' && maybeOjectField !== null && 'name' in maybeOjectField\n  )\n}\n\nexport function isCustomized(maybeCustomized: SchemaType): boolean {\n  const hasFieldsArray =\n    isObjectField(maybeCustomized) &&\n    !isType(maybeCustomized, 'reference') &&\n    !isType(maybeCustomized, 'crossDatasetReference') &&\n    'fields' in maybeCustomized &&\n    Array.isArray(maybeCustomized.fields)\n\n  if (!hasFieldsArray) {\n    return false\n  }\n\n  const fields = getCustomFields(maybeCustomized)\n  return !!fields.length\n}\n\nexport function isType(schemaType: SchemaType, typeName: string): boolean {\n  if (schemaType.name === typeName) {\n    return true\n  }\n  if (!schemaType.type) {\n    return false\n  }\n  return isType(schemaType.type, typeName)\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined\n}\n\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && typeof value === 'object'\n}\n\nexport function isPrimitive(value: unknown): value is string | boolean | number {\n  return isString(value) || isBoolean(value) || isNumber(value)\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'boolean'\n}\n\nfunction isBoolean(value: unknown): value is boolean {\n  return typeof value === 'number'\n}\n","import {type Stats} from 'node:fs'\nimport {readFile, stat} from 'node:fs/promises'\nimport path, {join, resolve} from 'node:path'\n\nimport {type CliOutputter} from '@sanity/cli'\nimport chalk from 'chalk'\n\nimport {type CreateManifest, type ManifestSchemaType} from '../../../../manifest/manifestTypes'\nimport {MANIFEST_FILENAME} from '../../manifest/extractManifestAction'\nimport {type DeploySchemasFlags} from '../deploySchemasAction'\n\nexport type ManifestJsonReader = <T>(\n  filePath: string,\n) => Promise<JsonFileParseSuccess<T> | undefined>\n\nexport type CreateManifestReaderFactory = (args: {\n  manifestDir: string\n  output: CliOutputter\n  jsonReader?: <T>(filePath: string) => Promise<JsonFileParseSuccess<T> | undefined>\n}) => CreateManifestReader\n\nexport interface CreateManifestReader {\n  getManifest: () => Promise<CreateManifest>\n  getWorkspaceSchema: (workspaceName: string) => Promise<ManifestSchemaType[]>\n}\n\ninterface JsonFileParseSuccess<T> {\n  parsedJson: T\n  path: string\n  lastModified: string\n}\n\n/**\n * The manifest reader will try to read manifest and workspace schema files _once_ and cache a successful result.\n * If you need to re-read the manifest from disk, create a new instance.\n */\nexport const createManifestReader: CreateManifestReaderFactory = ({\n  manifestDir,\n  output,\n  jsonReader = parseJsonFile,\n}) => {\n  let parsedManifest: JsonFileParseSuccess<CreateManifest>\n  const parsedWorkspaces: Record<string, JsonFileParseSuccess<ManifestSchemaType[]> | undefined> =\n    {}\n\n  const getManifest: CreateManifestReader['getManifest'] = async () => {\n    if (parsedManifest) {\n      return parsedManifest?.parsedJson\n    }\n\n    const manifestFile = path.join(manifestDir, MANIFEST_FILENAME)\n\n    const result = await jsonReader<CreateManifest>(manifestFile)\n    if (!result) {\n      throw new Error(\n        `Manifest does not exist at ${manifestFile}. To create the manifest file, omit --no-${'extract-manifest' satisfies keyof DeploySchemasFlags} or run \"sanity manifest extract\" first.`,\n      )\n    }\n\n    output.print(\n      chalk.gray(`↳ Read manifest from ${manifestFile} (last modified: ${result.lastModified})`),\n    )\n\n    parsedManifest = result\n    return result.parsedJson\n  }\n\n  const getWorkspaceSchema: CreateManifestReader['getWorkspaceSchema'] = async (workspaceName) => {\n    if (parsedWorkspaces[workspaceName]) {\n      return parsedWorkspaces[workspaceName]?.parsedJson\n    }\n    const manifest = await getManifest()\n    if (!manifest) {\n      throw Error('Manifest is required to read workspace schema.')\n    }\n\n    const workspaceManifest = manifest.workspaces.find(\n      (workspace) => workspace.name === workspaceName,\n    )\n\n    if (!workspaceManifest) {\n      throw Error(`No workspace named \"${workspaceName}\" found in manifest.`)\n    }\n\n    const workspaceSchemaFile = path.join(manifestDir, workspaceManifest.schema)\n    const result = await jsonReader<ManifestSchemaType[]>(workspaceSchemaFile)\n    if (!result) {\n      throw Error(`Workspace schema file at \"${workspaceSchemaFile}\" does not exist.`)\n    }\n    parsedWorkspaces[workspaceName] = result\n    return result.parsedJson\n  }\n  return {\n    getManifest,\n    getWorkspaceSchema,\n  }\n}\n\nexport function resolveManifestDirectory(workDir: string, customPath?: string): string {\n  const defaultOutputDir = resolve(join(workDir, 'dist'))\n\n  const outputDir = resolve(defaultOutputDir)\n  const defaultStaticPath = join(outputDir, 'static')\n\n  const staticPath = customPath ?? defaultStaticPath\n  return path.resolve(process.cwd(), staticPath)\n}\n\nasync function parseJsonFile<T>(filePath: string): Promise<JsonFileParseSuccess<T> | undefined> {\n  let stats: Stats\n  try {\n    stats = await stat(filePath)\n  } catch (err) {\n    // file does not exist\n    return undefined\n  }\n  const content = await readFile(filePath, 'utf-8')\n  const lastModified = stats.mtime.toISOString()\n  const json = JSON.parse(content) as T\n  if (!json) {\n    throw new Error(`JSON file \"${filePath}\" was empty.`)\n  }\n  return {\n    parsedJson: json,\n    path: filePath,\n    lastModified,\n  }\n}\n","import {type CliOutputter} from '@sanity/cli'\nimport uniqBy from 'lodash/uniqBy'\n\nimport {isDefined} from '../../../../manifest/manifestTypeHelpers'\nimport {SANITY_WORKSPACE_SCHEMA_TYPE} from '../../../../manifest/manifestTypes'\nimport {type DeleteSchemaFlags} from '../deleteSchemaAction'\nimport {type DeploySchemasFlags} from '../deploySchemasAction'\nimport {type SchemaListFlags} from '../listSchemasAction'\nimport {resolveManifestDirectory} from './manifestReader'\n\nexport const validForIdChars = 'a-zA-Z0-9._-'\nexport const validForIdPattern = new RegExp(`^[${validForIdChars}]+$`, 'g')\n\nconst requiredInId = SANITY_WORKSPACE_SCHEMA_TYPE.replace(/[.]/g, '\\\\.')\nconst idPattern = new RegExp(\n  `^(?:[${validForIdChars}]+?\\\\.)?${requiredInId}\\\\.([${validForIdChars}]+)$`,\n)\n\nexport class FlagValidationError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'FlagValidationError'\n  }\n}\n\ninterface WorkspaceSchemaId {\n  schemaId: string\n  workspace: string\n}\n\nexport interface SchemaStoreCommonFlags {\n  'extract-manifest'?: boolean\n  'manifest-dir'?: string\n  'verbose'?: boolean\n}\n\nfunction parseCommonFlags(\n  flags: SchemaStoreCommonFlags,\n  context: {workDir: string},\n  errors: string[],\n) {\n  const manifestDir = parseManifestDir(flags, errors)\n  const verbose = !!flags.verbose\n  // extract manifest by default: our CLI layer handles both --extract-manifest (true) and --no-extract-manifest (false)\n  const extractManifest = flags['extract-manifest'] ?? true\n\n  const fullManifestDir = resolveManifestDirectory(context.workDir, manifestDir)\n  return {\n    manifestDir: fullManifestDir,\n    verbose,\n    extractManifest,\n  }\n}\n\nexport function parseDeploySchemasConfig(flags: DeploySchemasFlags, context: {workDir: string}) {\n  const errors: string[] = []\n\n  const commonFlags = parseCommonFlags(flags, context, errors)\n  const workspaceName = parseWorkspace(flags, errors)\n  const idPrefix = parseIdPrefix(flags, errors)\n  const schemaRequired = !!flags['schema-required']\n\n  assertNoErrors(errors)\n  return {...commonFlags, workspaceName, idPrefix, schemaRequired}\n}\n\nexport function parseListSchemasConfig(flags: SchemaListFlags, context: {workDir: string}) {\n  const errors: string[] = []\n\n  const commonFlags = parseCommonFlags(flags, context, errors)\n  const id = parseId(flags, errors)\n  const json = !!flags.json\n\n  assertNoErrors(errors)\n  return {...commonFlags, json, id}\n}\n\nexport function parseDeleteSchemasConfig(flags: DeleteSchemaFlags, context: {workDir: string}) {\n  const errors: string[] = []\n\n  const commonFlags = parseCommonFlags(flags, context, errors)\n  const ids = parseIds(flags, errors)\n  const dataset = parseDataset(flags, errors)\n\n  assertNoErrors(errors)\n  return {...commonFlags, dataset, ids}\n}\n\nfunction assertNoErrors(errors: string[]) {\n  if (errors.length) {\n    throw new FlagValidationError(\n      `Invalid arguments:\\n${errors.map((error) => `  - ${error}`).join('\\n')}`,\n    )\n  }\n}\n\nexport function parseIds(flags: {ids?: unknown}, errors: string[]): WorkspaceSchemaId[] {\n  const parsedIds = parseNonEmptyString(flags, 'ids', errors)\n  if (errors.length) {\n    return []\n  }\n\n  const ids = parsedIds\n    .split(',')\n    .map((id) => id.trim())\n    .filter((id) => !!id)\n    .map((id) => parseWorkspaceSchemaId(id, errors))\n    .filter(isDefined)\n\n  const uniqueIds = uniqBy(ids, 'schemaId' satisfies keyof (typeof ids)[number])\n  if (uniqueIds.length < ids.length) {\n    errors.push(`ids contains duplicates`)\n  }\n  if (!errors.length && !uniqueIds.length) {\n    errors.push(`ids contains no valid id strings`)\n  }\n  return uniqueIds\n}\n\nexport function parseId(flags: {id?: unknown}, errors: string[]) {\n  const id = flags.id === undefined ? undefined : parseNonEmptyString(flags, 'id', errors)\n  if (id) {\n    return parseWorkspaceSchemaId(id, errors)?.schemaId\n  }\n  return undefined\n}\n\nexport function parseWorkspaceSchemaId(id: string, errors: string[]) {\n  const trimmedId = id.trim()\n\n  if (!trimmedId.match(validForIdPattern)) {\n    errors.push(`id can only contain characters in [${validForIdChars}] but found: \"${trimmedId}\"`)\n    return undefined\n  }\n\n  if (trimmedId.startsWith('-')) {\n    errors.push(`id cannot start with - (dash) but found: \"${trimmedId}\"`)\n    return undefined\n  }\n\n  if (trimmedId.match(/\\.\\./g)) {\n    errors.push(`id cannot have consecutive . (period) characters, but found: \"${trimmedId}\"`)\n    return undefined\n  }\n\n  const match = trimmedId.match(idPattern)\n  const workspace = match?.[1] ?? ''\n  if (!workspace) {\n    errors.push(\n      `id must end with ${SANITY_WORKSPACE_SCHEMA_TYPE}.<workspaceName> but found: \"${trimmedId}\"`,\n    )\n    return undefined\n  }\n  return {\n    schemaId: trimmedId,\n    workspace,\n  }\n}\n\nfunction parseDataset(flags: {dataset?: unknown}, errors: string[]) {\n  return flags.dataset === undefined ? undefined : parseNonEmptyString(flags, 'dataset', errors)\n}\n\nfunction parseWorkspace(flags: {workspace?: unknown}, errors: string[]) {\n  return flags.workspace === undefined ? undefined : parseNonEmptyString(flags, 'workspace', errors)\n}\n\nfunction parseManifestDir(flags: {'manifest-dir'?: unknown}, errors: string[]) {\n  return flags['manifest-dir'] === undefined\n    ? undefined\n    : parseNonEmptyString(flags, 'manifest-dir', errors)\n}\n\nexport function parseIdPrefix(flags: {'id-prefix'?: unknown}, errors: string[]) {\n  if (flags['id-prefix'] === undefined) {\n    return undefined\n  }\n\n  const idPrefix = parseNonEmptyString(flags, 'id-prefix', errors)\n  if (errors.length) {\n    return undefined\n  }\n\n  if (idPrefix.endsWith('.')) {\n    errors.push(`id-prefix argument cannot end with . (period), but was: \"${idPrefix}\"`)\n    return undefined\n  }\n\n  if (!idPrefix.match(validForIdPattern)) {\n    errors.push(\n      `id-prefix can only contain _id compatible characters [${validForIdChars}], but was: \"${idPrefix}\"`,\n    )\n    return undefined\n  }\n\n  if (idPrefix.startsWith('-')) {\n    errors.push(`id-prefix cannot start with - (dash) but was: \"${idPrefix}\"`)\n    return undefined\n  }\n\n  if (idPrefix.match(/\\.\\./g)) {\n    errors.push(`id-prefix cannot have consecutive . (period) characters, but was: \"${idPrefix}\"`)\n    return undefined\n  }\n\n  return idPrefix\n}\n\nfunction parseNonEmptyString<\n  Flag extends string,\n  Flags extends Partial<Record<Flag, unknown | undefined>>,\n>(flags: Flags, flagName: Flag, errors: string[]): string {\n  const flag = flags[flagName]\n  if (!isString(flag) || !flag) {\n    errors.push(`${flagName} argument is empty`)\n    return ''\n  }\n  return flag\n}\n\nfunction isString(flag: unknown): flag is string {\n  return typeof flag === 'string'\n}\n\nfunction getProjectIdMismatchMessage(\n  workspace: {name: string; projectId: string},\n  operation: 'read' | 'write',\n) {\n  return `No permissions to ${operation} schema for workspace \"${workspace.name}\" with projectId \"${workspace.projectId}\"`\n}\n\n/**\n * At the moment schema store commands does not support studios where workspaces have multiple projects\n */\nexport function throwWriteProjectIdMismatch(\n  workspace: {name: string; projectId: string},\n  projectId: string,\n): void {\n  if (workspace.projectId !== projectId) {\n    throw new Error(getProjectIdMismatchMessage(workspace, 'write'))\n  }\n}\n\nexport function filterLogReadProjectIdMismatch(\n  workspace: {name: string; projectId: string},\n  projectId: string,\n  output: CliOutputter,\n) {\n  const canRead = workspace.projectId === projectId\n  if (!canRead) output.warn(`${getProjectIdMismatchMessage(workspace, 'read')} – ignoring it.`)\n  return canRead\n}\n","import {type CliCommandArguments, type CliCommandContext, type CliOutputter} from '@sanity/cli'\nimport chalk from 'chalk'\n\nimport {type ExtractManifestFlags, extractManifestSafe} from '../../manifest/extractManifestAction'\nimport {FlagValidationError} from './schemaStoreValidation'\n\nexport type ManifestExtractor = (manifestDir: string) => Promise<void>\n\nexport async function ensureManifestExtractSatisfied(args: {\n  schemaRequired: boolean\n  extractManifest: boolean\n  manifestDir: string\n  manifestExtractor: (manifestDir: string) => Promise<void>\n  output: CliOutputter\n}) {\n  const {schemaRequired, extractManifest, manifestDir, manifestExtractor, output} = args\n  if (!extractManifest) {\n    return true\n  }\n  try {\n    // a successful manifest extract will write a new manifest file, which manifestReader will then read from disk\n    await manifestExtractor(manifestDir)\n    return true\n  } catch (err) {\n    if (schemaRequired || err instanceof FlagValidationError) {\n      throw err\n    } else {\n      output.print(chalk.gray(`↳ Failed to extract manifest:\\n  ${err.message}`))\n      return false\n    }\n  }\n}\n\nexport function createManifestExtractor(context: CliCommandContext & {safe?: boolean}) {\n  return async (manifestDir: string) => {\n    const error = await extractManifestSafe(\n      {\n        extOptions: {path: manifestDir},\n        groupOrCommand: 'extract',\n        argv: [],\n        argsWithoutOptions: [],\n        extraArguments: [],\n      } as CliCommandArguments<ExtractManifestFlags>,\n      context,\n    )\n    if (!context.safe && error) {\n      throw error\n    }\n  }\n}\n","import {type CliApiClient} from '@sanity/cli'\n\nexport function createSchemaApiClient(apiClient: CliApiClient) {\n  const client = apiClient({\n    requireUser: true,\n    requireProject: true,\n  }).withConfig({apiVersion: 'v2025-03-01', useCdn: false})\n\n  const projectId = client.config().projectId\n  const dataset = client.config().dataset\n  if (!projectId) throw new Error('Project ID is not defined')\n  if (!dataset) throw new Error('Dataset is not defined')\n\n  return {\n    client,\n    projectId,\n    dataset,\n  }\n}\n"],"names":["SANITY_WORKSPACE_SCHEMA_TYPE","isDefined","value","createManifestReader","manifestDir","output","jsonReader","parseJsonFile","parsedManifest","parsedWorkspaces","getManifest","parsedJson","manifestFile","path","join","MANIFEST_FILENAME","result","Error","print","chalk","gray","lastModified","getWorkspaceSchema","workspaceName","manifest","workspaceManifest","workspaces","find","workspace","name","workspaceSchemaFile","schema","resolveManifestDirectory","workDir","customPath","defaultOutputDir","resolve","outputDir","defaultStaticPath","staticPath","process","cwd","filePath","stats","stat","content","readFile","mtime","toISOString","json","JSON","parse","validForIdChars","validForIdPattern","RegExp","requiredInId","replace","idPattern","FlagValidationError","constructor","message","parseCommonFlags","flags","context","errors","parseManifestDir","verbose","extractManifest","parseDeploySchemasConfig","commonFlags","parseWorkspace","idPrefix","parseIdPrefix","schemaRequired","assertNoErrors","parseListSchemasConfig","id","parseId","parseDeleteSchemasConfig","ids","parseIds","dataset","parseDataset","length","map","error","parsedIds","parseNonEmptyString","split","trim","filter","parseWorkspaceSchemaId","uniqueIds","uniqBy","push","undefined","schemaId","trimmedId","match","startsWith","endsWith","flagName","flag","isString","getProjectIdMismatchMessage","operation","projectId","throwWriteProjectIdMismatch","filterLogReadProjectIdMismatch","canRead","warn","ensureManifestExtractSatisfied","args","manifestExtractor","err","createManifestExtractor","extractManifestSafe","extOptions","groupOrCommand","argv","argsWithoutOptions","extraArguments","safe","createSchemaApiClient","apiClient","client","requireUser","requireProject","withConfig","apiVersion","useCdn","config"],"mappings":"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"}