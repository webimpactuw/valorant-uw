"use strict";
var chalk = require("chalk"), uniq = require("lodash/uniq"), schemaApiClient = require("./schemaApiClient.js"), schemaStoreOutStrings = require("./schemaStoreOutStrings.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq);
class DeleteIdError extends Error {
  constructor(id, dataset, options) {
    super(options?.cause?.message, options), this.name = "DeleteIdError", this.id = id, this.dataset = dataset;
  }
}
function deleteSchemasActionForCommand(flags, context) {
  return deleteSchemaAction(flags, {
    ...context,
    manifestExtractor: schemaApiClient.createManifestExtractor(context)
  });
}
async function deleteSchemaAction(flags, context) {
  const {
    ids,
    dataset,
    extractManifest,
    manifestDir,
    verbose
  } = schemaApiClient.parseDeleteSchemasConfig(flags, context), {
    output,
    apiClient,
    jsonReader,
    manifestExtractor
  } = context;
  if (!await schemaApiClient.ensureManifestExtractSatisfied({
    schemaRequired: !0,
    extractManifest,
    manifestDir,
    manifestExtractor,
    output
  }))
    return "failure";
  const {
    client,
    projectId
  } = schemaApiClient.createSchemaApiClient(apiClient), workspaces = (await schemaApiClient.createManifestReader({
    manifestDir,
    output,
    jsonReader
  }).getManifest()).workspaces.filter((workspace) => !dataset || workspace.dataset === dataset).filter((workspace) => schemaApiClient.filterLogReadProjectIdMismatch(workspace, projectId, output)), datasets = uniq__default.default(workspaces.map((w) => w.dataset)), results = await Promise.allSettled(datasets.flatMap((targetDataset) => ids.map(async ({
    schemaId
  }) => {
    try {
      const deletedSchema = await client.withConfig({
        dataset: targetDataset
      }).delete(schemaId);
      return {
        dataset: targetDataset,
        schemaId,
        deleted: deletedSchema.results.length
      };
    } catch (err) {
      throw new DeleteIdError(schemaId, targetDataset, {
        cause: err
      });
    }
  }))), deletedIds = results.filter((r) => r.status === "fulfilled").filter((r) => r.value.deleted).map((r) => r.value), notFound = uniq__default.default(results.filter((r) => r.status === "fulfilled").filter((r) => !r.value.deleted).filter((r) => !deletedIds.map(({
    schemaId
  }) => schemaId).includes(r.value.schemaId)).map((r) => r.value.schemaId)), deleteFailureIds = uniq__default.default(results.filter((r) => r.status === "rejected").map((result) => {
    const error = result.reason;
    if (error instanceof DeleteIdError)
      return output.error(chalk__default.default.red(`Failed to delete schema "${error.id}" in dataset "${error.dataset}":
${error.message}`)), verbose && output.error(error), error.id;
    throw error;
  })), success = deletedIds.length === ids.length;
  return success ? output.success(`Successfully deleted ${deletedIds.length}/${ids.length} schemas`) : output.error([`Deleted ${deletedIds.length}/${ids.length} schemas.`, deletedIds.length ? `Successfully deleted ids:
${deletedIds.map(({
    schemaId,
    dataset: targetDataset
  }) => `- "${schemaId}" (in ${schemaStoreOutStrings.getDatasetsOutString([targetDataset])})`).join(`
`)}` : void 0, notFound.length ? `Ids not found in ${schemaStoreOutStrings.getDatasetsOutString(datasets)}:
${schemaStoreOutStrings.getStringList(notFound)}` : void 0, ...deleteFailureIds.length ? [`Failed to delete ids:
${schemaStoreOutStrings.getStringList(deleteFailureIds)}`, "Check logs for errors."] : []].filter(schemaApiClient.isDefined).join(`
`)), success ? "success" : "failure";
}
exports.default = deleteSchemasActionForCommand;
exports.deleteSchemaAction = deleteSchemaAction;
//# sourceMappingURL=deleteSchemaAction.js.map
