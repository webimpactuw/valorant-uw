"use strict";
var chalk = require("chalk"), sortBy = require("lodash/sortBy"), uniq = require("lodash/uniq"), schemaApiClient = require("./schemaApiClient.js"), schemaStoreOutStrings = require("./schemaStoreOutStrings.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var chalk__default = /* @__PURE__ */ _interopDefaultCompat(chalk), sortBy__default = /* @__PURE__ */ _interopDefaultCompat(sortBy), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq);
class DatasetError extends Error {
  constructor(dataset, options) {
    super(options?.cause?.message, options), this.dataset = dataset, this.name = "DatasetError";
  }
}
function listSchemasActionForCommand(flags, context) {
  return listSchemasAction(flags, {
    ...context,
    manifestExtractor: schemaApiClient.createManifestExtractor(context)
  });
}
async function listSchemasAction(flags, context) {
  const {
    json,
    id,
    manifestDir,
    extractManifest
  } = schemaApiClient.parseListSchemasConfig(flags, context), {
    output,
    apiClient,
    jsonReader,
    manifestExtractor
  } = context;
  if (!await schemaApiClient.ensureManifestExtractSatisfied({
    schemaRequired: !0,
    extractManifest,
    manifestDir,
    manifestExtractor,
    output
  }))
    return "failure";
  const {
    client,
    projectId
  } = schemaApiClient.createSchemaApiClient(apiClient), workspaces = (await schemaApiClient.createManifestReader({
    manifestDir,
    output,
    jsonReader
  }).getManifest()).workspaces.filter((workspace) => schemaApiClient.filterLogReadProjectIdMismatch(workspace, projectId, output)), datasets = uniq__default.default(workspaces.map((w) => w.dataset)), schemas = (await Promise.allSettled(datasets.map(async (dataset) => {
    try {
      const datasetClient = client.withConfig({
        dataset
      });
      return id ? datasetClient.getDocument(id) : datasetClient.fetch("*[_type == $type]", {
        type: schemaApiClient.SANITY_WORKSPACE_SCHEMA_TYPE
      });
    } catch (error) {
      throw new DatasetError(dataset, {
        cause: error
      });
    }
  }))).map((result, index) => {
    if (result.status === "fulfilled") return result.value;
    if (result.reason instanceof DatasetError) {
      const message = chalk__default.default.red(`\u21B3 Failed to fetch schema from dataset "${result.reason.dataset}":
  ${result.reason.message}`);
      output.error(message);
    } else
      throw result.reason;
    return [];
  }).filter(schemaApiClient.isDefined).flat();
  if (schemas.length === 0) {
    const datasetString = schemaStoreOutStrings.getDatasetsOutString(datasets);
    return output.error(id ? `Schema for id "${id}" not found in ${datasetString}` : `No schemas found in ${datasetString}`), "failure";
  }
  return json ? output.print(`${JSON.stringify(id ? schemas[0] : schemas, null, 2)}`) : printSchemaList({
    schemas,
    output
  }), "success";
}
function printSchemaList({
  schemas,
  output
}) {
  const ordered = sortBy__default.default(schemas.map(({
    _createdAt: createdAt,
    _id: id,
    workspace
  }) => [id, workspace.name, workspace.dataset, workspace.projectId, createdAt].map(String)), ["createdAt"]), headings = ["Id", "Workspace", "Dataset", "ProjectId", "CreatedAt"], rows = ordered.reverse(), maxWidths = rows.reduce((max, row) => row.map((current, index) => Math.max(current.length, max[index])), headings.map((str) => str.length)), rowToString = (row) => row.map((col, i) => `${col}`.padEnd(maxWidths[i])).join("   ");
  output.print(chalk__default.default.cyan(rowToString(headings))), rows.forEach((row) => output.print(rowToString(row)));
}
exports.default = listSchemasActionForCommand;
exports.listSchemasAction = listSchemasAction;
//# sourceMappingURL=listSchemasAction.js.map
