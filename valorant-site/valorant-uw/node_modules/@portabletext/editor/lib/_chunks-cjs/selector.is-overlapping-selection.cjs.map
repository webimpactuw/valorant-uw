{"version":3,"file":"selector.is-overlapping-selection.cjs","sources":["../../src/selectors/selector.is-selection-collapsed.ts","../../src/behavior-actions/behavior.guards.ts","../../src/selectors/selectors.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-selection-start-point.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-previous-inline-object.ts","../../src/selectors/selector.get-selected-slice.ts","../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.is-selection-expanded.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts"],"sourcesContent":["import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(snapshot.context.selection.anchor.path) ===\n      JSON.stringify(snapshot.context.selection.focus.path) &&\n    snapshot.context.selection?.anchor.offset ===\n      snapshot.context.selection?.focus.offset\n  )\n}\n","import {\n  isPortableTextListBlock,\n  isPortableTextTextBlock,\n  type PortableTextListBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/editor-schema'\n\n/**\n * @alpha\n */\nexport type BehaviorGuards = ReturnType<typeof createGuards>\n\nexport function createGuards({schema}: {schema: EditorSchema}) {\n  function isListBlock(block: unknown): block is PortableTextListBlock {\n    return isPortableTextListBlock(block) && block._type === schema.block.name\n  }\n\n  function isTextBlock(block: unknown): block is PortableTextTextBlock {\n    return isPortableTextTextBlock(block) && block._type === schema.block.name\n  }\n\n  return {isListBlock, isTextBlock}\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const key = snapshot.context.selection\n    ? isKeySegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const guards = createGuards(snapshot.context)\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && guards.isListBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusTextBlock(snapshot)\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection\n    ? isKeySegment(snapshot.context.selection.focus.path[2])\n      ? snapshot.context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = snapshot.context.selection.backward\n    ? isKeySegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = snapshot.context.selection.backward\n    ? isKeySegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection.backward\n    ? isKeySegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = snapshot.context.selection.backward\n    ? isKeySegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? snapshot.context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = (snapshot) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n","import type {EditorSelectionPoint} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import type {EditorSelectionPoint} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeySegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {sliceBlocks} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedSlice: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return sliceBlocks({\n    blocks: snapshot.context.value,\n    selection: snapshot.context.selection,\n  })\n}\n","import {isPortableTextSpan, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSlice} from './selector.get-selected-slice'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = (snapshot) => {\n  const selectedSlice = getSelectedSlice(snapshot)\n\n  return selectedSlice.reduce((text, block) => {\n    if (!isPortableTextTextBlock(block)) {\n      return text\n    }\n\n    return (\n      text +\n      block.children.reduce((text, child) => {\n        if (isPortableTextSpan(child)) {\n          return text + child.text\n        }\n\n        return text\n      }, '')\n    )\n  }, '')\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = (snapshot) => {\n  return !isSelectionCollapsed(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  getBlockEndPoint,\n  getBlockStartPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        value: snapshot.context.value,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint(focusTextBlock)\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint(focusTextBlock)\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value: snapshot.context.value,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value: snapshot.context.value,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = utils.getBlockEndPoint(block)\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = utils.getBlockStartPoint(block)\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = snapshot.context.selection.backward\n      ? reverseSelection(snapshot.context.selection)\n      : snapshot.context.selection\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const endBlockKey = isKeySegment(selection.focus.path[0])\n      ? selection.focus.path[0]._key\n      : undefined\n    const endChildKey = isKeySegment(selection.focus.path[2])\n      ? selection.focus.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    let after = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = true\n          break\n        }\n\n        // Both the point and the selection end in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !endChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = true\n              break\n            }\n\n            // Both the point and the selection end in this child\n\n            after = point.offset > selection.focus.offset\n            break\n          }\n\n          if (child._key === pointChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === pointBlockKey) {\n        break\n      }\n    }\n\n    return after\n  }\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = snapshot.context.selection.backward\n      ? reverseSelection(snapshot.context.selection)\n      : snapshot.context.selection\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const startBlockKey = isKeySegment(selection.anchor.path[0])\n      ? selection.anchor.path[0]._key\n      : undefined\n    const startChildKey = isKeySegment(selection.anchor.path[2])\n      ? selection.anchor.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    let before = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = true\n          break\n        }\n\n        // Both the point and the selection start in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !startChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = true\n              break\n            }\n\n            // Both the point and the selection start in this child\n\n            before = point.offset < selection.anchor.offset\n            break\n          }\n\n          if (child._key === startChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === startBlockKey) {\n        break\n      }\n    }\n\n    return before\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from '../utils'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    const originalSelectionStartPoint = getSelectionStartPoint(snapshot)\n    const originalSelectionEndPoint = getSelectionEndPoint(snapshot)\n\n    if (\n      !selectionStartPoint ||\n      !selectionEndPoint ||\n      !originalSelectionStartPoint ||\n      !originalSelectionEndPoint\n    ) {\n      return false\n    }\n\n    const startPointBeforeSelection =\n      isPointBeforeSelection(selectionStartPoint)(snapshot)\n    const startPointAfterSelection =\n      isPointAfterSelection(selectionStartPoint)(snapshot)\n    const endPointBeforeSelection =\n      isPointBeforeSelection(selectionEndPoint)(snapshot)\n    const endPointAfterSelection =\n      isPointAfterSelection(selectionEndPoint)(snapshot)\n\n    const originalStartPointBeforeStartPoint = isPointBeforeSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n    const originalStartPointAfterStartPoint = isPointAfterSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n\n    const originalEndPointBeforeEndPoint = isPointBeforeSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n    const originalEndPointAfterEndPoint = isPointAfterSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n\n    const endPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionStartPoint,\n    )\n    const startPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionEndPoint,\n    )\n\n    if (endPointBeforeSelection && !endPointEqualToOriginalStartPoint) {\n      return false\n    }\n\n    if (startPointAfterSelection && !startPointEqualToOriginalEndPoint) {\n      return false\n    }\n\n    if (\n      !originalStartPointBeforeStartPoint &&\n      originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      originalEndPointAfterEndPoint\n    ) {\n      return !endPointEqualToOriginalStartPoint\n    }\n\n    if (\n      originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return !startPointEqualToOriginalEndPoint\n    }\n\n    if (\n      !startPointAfterSelection ||\n      !startPointBeforeSelection ||\n      !endPointAfterSelection ||\n      !endPointBeforeSelection\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n"],"names":["isSelectionCollapsed","snapshot","context","selection","JSON","stringify","anchor","path","focus","offset","createGuards","schema","isListBlock","block","isPortableTextListBlock","_type","name","isTextBlock","isPortableTextTextBlock","getFocusBlock","key","isKeySegment","_key","undefined","node","value","find","getFocusListBlock","guards","focusBlock","getFocusTextBlock","getFocusBlockObject","getFocusChild","children","span","getFocusSpan","focusChild","isPortableTextSpan","getFirstBlock","getLastBlock","length","getSelectedBlocks","selectedBlocks","startKey","backward","endKey","push","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock","getSelectionEndPoint","getSelectionStartPoint","getNextInlineObject","focusTextBlock","selectionEndPoint","selectionEndPointChildKey","endPointChildFound","inlineObject","child","isSpan","getPreviousInlineObject","selectionStartPoint","selectionStartPointChildKey","getSelectedSlice","sliceBlocks","blocks","getSelectionText","reduce","text","isSelectionExpanded","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","split","at","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","caretWordEndSelectionPoint","caretWordSelection","isAtTheEndOfBlock","utils","isAtTheStartOfBlock","isPointAfterSelection","point","reverseSelection","pointBlockKey","pointChildKey","endBlockKey","endChildKey","after","isPointBeforeSelection","startBlockKey","startChildKey","before","isOverlappingSelection","originalSelectionStartPoint","originalSelectionEndPoint","startPointBeforeSelection","startPointAfterSelection","endPointBeforeSelection","endPointAfterSelection","originalStartPointBeforeStartPoint","originalStartPointAfterStartPoint","originalEndPointBeforeEndPoint","originalEndPointAfterEndPoint","endPointEqualToOriginalStartPoint","isEqualSelectionPoints","startPointEqualToOriginalEndPoint"],"mappings":"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"}