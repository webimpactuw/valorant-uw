"use strict";
var jsxRuntime = require("react/jsx-runtime"), react = require("@xstate/react"), React = require("react"), slateReact = require("slate-react"), reactCompilerRuntime = require("react-compiler-runtime"), debug$g = require("debug"), isEqual = require("lodash/isEqual.js"), slate = require("slate"), xstate = require("xstate"), patches = require("@portabletext/patches"), types = require("@sanity/types"), flatten = require("lodash/flatten.js"), isPlainObject = require("lodash/isPlainObject.js"), uniq = require("lodash/uniq.js"), getRandomValues = require("get-random-values-esm"), parseBlocks = require("./parse-blocks.cjs"), util_sliceBlocks = require("./util.slice-blocks.cjs"), blockTools = require("@portabletext/block-tools"), toHtml = require("@portabletext/to-html"), schema = require("@sanity/schema"), get = require("lodash/get.js"), isUndefined = require("lodash/isUndefined.js"), omitBy = require("lodash/omitBy.js"), omit = require("lodash/omit.js"), util_selectionPointToBlockOffset = require("./util.selection-point-to-block-offset.cjs"), selector_isSelectingEntireBlocks = require("./selector.is-selecting-entire-blocks.cjs"), slateDom = require("slate-dom"), startCase = require("lodash.startcase"), behavior_core = require("./behavior.core.cjs"), selector_isOverlappingSelection = require("./selector.is-overlapping-selection.cjs"), util_getSelectionStartPoint = require("./util.get-selection-start-point.cjs"), rxjs = require("rxjs"), useEffectEvent = require("use-effect-event");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var React__default = /* @__PURE__ */ _interopDefaultCompat(React), debug__default = /* @__PURE__ */ _interopDefaultCompat(debug$g), isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual), flatten__default = /* @__PURE__ */ _interopDefaultCompat(flatten), isPlainObject__default = /* @__PURE__ */ _interopDefaultCompat(isPlainObject), uniq__default = /* @__PURE__ */ _interopDefaultCompat(uniq), getRandomValues__default = /* @__PURE__ */ _interopDefaultCompat(getRandomValues), get__default = /* @__PURE__ */ _interopDefaultCompat(get), isUndefined__default = /* @__PURE__ */ _interopDefaultCompat(isUndefined), omitBy__default = /* @__PURE__ */ _interopDefaultCompat(omitBy), omit__default = /* @__PURE__ */ _interopDefaultCompat(omit), startCase__default = /* @__PURE__ */ _interopDefaultCompat(startCase);
const rootName = "sanity-pte:";
debug__default.default(rootName);
function debugWithName(name) {
  const namespace = `${rootName}${name}`;
  return debug__default.default && debug__default.default.enabled(namespace) ? debug__default.default(namespace) : debug__default.default(rootName);
}
const VOID_CHILD_KEY = "void-child";
function keepObjectEquality(object, keyMap) {
  const value = keyMap[object._key];
  return value && isEqual__default.default(object, value) ? value : (keyMap[object._key] = object, object);
}
function toSlateValue(value, {
  schemaTypes
}, keyMap = {}) {
  return value && Array.isArray(value) ? value.map((block) => {
    const {
      _type,
      _key,
      ...rest
    } = block;
    if (block && block._type === schemaTypes.block.name) {
      const textBlock = block;
      let hasInlines = !1;
      const hasMissingStyle = typeof textBlock.style > "u", hasMissingMarkDefs = typeof textBlock.markDefs > "u", hasMissingChildren = typeof textBlock.children > "u", children = (textBlock.children || []).map((child) => {
        const {
          _type: cType,
          _key: cKey,
          ...cRest
        } = child;
        return cType !== "span" ? (hasInlines = !0, keepObjectEquality({
          _type: cType,
          _key: cKey,
          children: [{
            _key: VOID_CHILD_KEY,
            _type: "span",
            text: "",
            marks: []
          }],
          value: cRest,
          __inline: !0
        }, keyMap)) : child;
      });
      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].name), keepObjectEquality({
        _type,
        _key,
        ...rest,
        children
      }, keyMap));
    }
    return keepObjectEquality({
      _type,
      _key,
      children: [{
        _key: VOID_CHILD_KEY,
        _type: "span",
        text: "",
        marks: []
      }],
      value: rest
    }, keyMap);
  }) : [];
}
function fromSlateValue(value, textBlockType, keyMap = {}) {
  return value.map((block) => {
    const {
      _key,
      _type
    } = block;
    if (!_key || !_type)
      throw new Error("Not a valid block");
    if (_type === textBlockType && "children" in block && Array.isArray(block.children) && _key) {
      let hasInlines = !1;
      const children = block.children.map((child) => {
        const {
          _type: _cType
        } = child;
        if ("value" in child && _cType !== "span") {
          hasInlines = !0;
          const {
            value: v,
            _key: k,
            _type: t,
            __inline: _i,
            children: _c,
            ...rest
          } = child;
          return keepObjectEquality({
            ...rest,
            ...v,
            _key: k,
            _type: t
          }, keyMap);
        }
        return child;
      });
      return hasInlines ? keepObjectEquality({
        ...block,
        children,
        _key,
        _type
      }, keyMap) : block;
    }
    const blockValue = "value" in block && block.value;
    return keepObjectEquality({
      _key,
      _type,
      ...typeof blockValue == "object" ? blockValue : {}
    }, keyMap);
  });
}
function isEqualToEmptyEditor(children, schemaTypes) {
  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && "style" in children[0] && children[0].style === schemaTypes.styles[0].name && !("listItem" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate.Text.isText(children[0].children[0]) && children[0].children[0]._type === "span" && !children[0].children[0].marks?.join("") && children[0].children[0].text === "";
}
const IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), mutationMachine = xstate.setup({
  types: {
    context: {},
    events: {},
    input: {},
    emitted: {}
  },
  actions: {
    "emit has pending patches": xstate.emit({
      type: "has pending patches"
    }),
    "emit mutations": xstate.enqueueActions(({
      context,
      enqueue
    }) => {
      for (const bulk of context.pendingMutations)
        enqueue.emit({
          type: "mutation",
          patches: bulk.patches,
          snapshot: bulk.value
        });
    }),
    "clear pending mutations": xstate.assign({
      pendingMutations: []
    }),
    "defer patch": xstate.assign({
      pendingMutations: ({
        context,
        event
      }) => {
        if (xstate.assertEvent(event, "patch"), context.pendingMutations.length === 0)
          return [{
            actionId: event.actionId,
            value: event.value,
            patches: [event.patch]
          }];
        const lastBulk = context.pendingMutations.at(-1);
        return lastBulk && lastBulk.actionId === event.actionId ? context.pendingMutations.slice(0, -1).concat({
          value: event.value,
          actionId: lastBulk.actionId,
          patches: [...lastBulk.patches, event.patch]
        }) : context.pendingMutations.concat({
          value: event.value,
          actionId: event.actionId,
          patches: [event.patch]
        });
      }
    })
  },
  actors: {
    "type listener": xstate.fromCallback(({
      input,
      sendBack
    }) => {
      const originalApply = input.slateEditor.apply;
      return input.slateEditor.apply = (op) => {
        op.type === "insert_text" || op.type === "remove_text" ? sendBack({
          type: "typing"
        }) : sendBack({
          type: "not typing"
        }), originalApply(op);
      }, () => {
        input.slateEditor.apply = originalApply;
      };
    })
  },
  guards: {
    "is typing": xstate.stateIn({
      typing: "typing"
    }),
    "no pending mutations": ({
      context
    }) => context.pendingMutations.length === 0,
    "slate is normalizing": ({
      context
    }) => slate.Editor.isNormalizing(context.slateEditor)
  },
  delays: {
    "mutation debounce": process.env.NODE_ENV === "test" ? 250 : 0,
    "type debounce": process.env.NODE_ENV === "test" ? 0 : 250
  }
}).createMachine({
  id: "mutation",
  context: ({
    input
  }) => ({
    pendingMutations: [],
    schema: input.schema,
    slateEditor: input.slateEditor
  }),
  type: "parallel",
  states: {
    typing: {
      initial: "idle",
      invoke: {
        src: "type listener",
        input: ({
          context
        }) => ({
          slateEditor: context.slateEditor
        })
      },
      states: {
        idle: {
          on: {
            typing: {
              target: "typing"
            }
          }
        },
        typing: {
          after: {
            "type debounce": {
              target: "idle"
            }
          },
          on: {
            "not typing": {
              target: "idle"
            },
            typing: {
              target: "typing",
              reenter: !0
            }
          }
        }
      }
    },
    mutations: {
      initial: "idle",
      states: {
        idle: {
          on: {
            patch: {
              actions: ["defer patch", "emit has pending patches"],
              target: "emitting mutations"
            }
          }
        },
        "emitting mutations": {
          after: {
            "mutation debounce": [{
              guard: xstate.and([xstate.not("is typing"), "slate is normalizing"]),
              target: "idle",
              actions: ["emit mutations", "clear pending mutations"]
            }, {
              target: "emitting mutations",
              reenter: !0
            }]
          },
          on: {
            patch: {
              target: "emitting mutations",
              actions: ["defer patch"],
              reenter: !0
            }
          }
        }
      }
    }
  }
});
function validateValue(value, types$1, keyGenerator) {
  let resolution = null, valid = !0;
  const validChildTypes = [types$1.span.name, ...types$1.inlineObjects.map((t) => t.name)], validBlockTypes = [types$1.block.name, ...types$1.blockObjects.map((t) => t.name)];
  return value === void 0 ? {
    valid: !0,
    resolution: null,
    value
  } : !Array.isArray(value) || value.length === 0 ? {
    valid: !1,
    resolution: {
      patches: [patches.unset([])],
      description: "Editor value must be an array of Portable Text blocks, or undefined.",
      action: "Unset the value",
      item: value,
      i18n: {
        description: "inputs.portable-text.invalid-value.not-an-array.description",
        action: "inputs.portable-text.invalid-value.not-an-array.action"
      }
    },
    value
  } : (value.some((blk, index) => {
    if (!isPlainObject__default.default(blk))
      return resolution = {
        patches: [patches.unset([index])],
        description: `Block must be an object, got ${String(blk)}`,
        action: "Unset invalid item",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.not-an-object.description",
          action: "inputs.portable-text.invalid-value.not-an-object.action",
          values: {
            index
          }
        }
      }, !0;
    if (!blk._key || typeof blk._key != "string")
      return resolution = {
        patches: [patches.set({
          ...blk,
          _key: keyGenerator()
        }, [index])],
        description: `Block at index ${index} is missing required _key.`,
        action: "Set the block with a random _key value",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-key.description",
          action: "inputs.portable-text.invalid-value.missing-key.action",
          values: {
            index
          }
        }
      }, !0;
    if (!blk._type || !validBlockTypes.includes(blk._type)) {
      if (blk._type === "block") {
        const currentBlockTypeName = types$1.block.name;
        return resolution = {
          patches: [patches.set({
            ...blk,
            _type: currentBlockTypeName
          }, [{
            _key: blk._key
          }])],
          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,
          action: `Use type '${currentBlockTypeName}'`,
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.incorrect-block-type.description",
            action: "inputs.portable-text.invalid-value.incorrect-block-type.action",
            values: {
              key: blk._key,
              expectedTypeName: currentBlockTypeName
            }
          }
        }, !0;
      }
      return !blk._type && types.isPortableTextTextBlock({
        ...blk,
        _type: types$1.block.name
      }) ? (resolution = {
        patches: [patches.set({
          ...blk,
          _type: types$1.block.name
        }, [{
          _key: blk._key
        }])],
        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types$1.block.name}'`,
        action: `Use type '${types$1.block.name}'`,
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-block-type.description",
          action: "inputs.portable-text.invalid-value.missing-block-type.action",
          values: {
            key: blk._key,
            expectedTypeName: types$1.block.name
          }
        }
      }, !0) : blk._type ? (resolution = {
        patches: [patches.unset([{
          _key: blk._key
        }])],
        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.disallowed-type.description",
          action: "inputs.portable-text.invalid-value.disallowed-type.action",
          values: {
            key: blk._key,
            typeName: blk._type
          }
        }
      }, !0) : (resolution = {
        patches: [patches.unset([{
          _key: blk._key
        }])],
        description: `Block with _key '${blk._key}' is missing an _type property`,
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-type.description",
          action: "inputs.portable-text.invalid-value.missing-type.action",
          values: {
            key: blk._key
          }
        }
      }, !0);
    }
    if (blk._type === types$1.block.name) {
      const textBlock = blk;
      if (textBlock.children && !Array.isArray(textBlock.children))
        return resolution = {
          patches: [patches.set({
            children: []
          }, [{
            _key: textBlock._key
          }])],
          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,
          action: "Reset the children property",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-children.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-children.action",
            values: {
              key: textBlock._key
            }
          }
        }, !0;
      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {
        const newSpan = {
          _type: types$1.span.name,
          _key: keyGenerator(),
          text: "",
          marks: []
        };
        return resolution = {
          autoResolve: !0,
          patches: [patches.setIfMissing([], [{
            _key: blk._key
          }, "children"]), patches.insert([newSpan], "after", [{
            _key: blk._key
          }, "children", 0])],
          description: `Children for text block with _key '${blk._key}' is empty.`,
          action: "Insert an empty text",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.empty-children.description",
            action: "inputs.portable-text.invalid-value.empty-children.action",
            values: {
              key: blk._key
            }
          }
        }, !0;
      }
      const allUsedMarks = uniq__default.default(flatten__default.default(textBlock.children.filter((cld) => cld._type === types$1.span.name).map((cld) => cld.marks || [])));
      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {
        const unusedMarkDefs = uniq__default.default(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)));
        if (unusedMarkDefs.length > 0)
          return resolution = {
            autoResolve: !0,
            patches: unusedMarkDefs.map((markDefKey) => patches.unset([{
              _key: blk._key
            }, "markDefs", {
              _key: markDefKey
            }])),
            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(", ")}.`,
            action: "Remove unused mark definition item",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.orphaned-mark-defs.description",
              action: "inputs.portable-text.invalid-value.orphaned-mark-defs.action",
              values: {
                key: blk._key,
                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())
              }
            }
          }, !0;
      }
      const orphanedMarks = allUsedMarks.filter((mark) => !types$1.decorators.map((dec) => dec.name).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));
      if (orphanedMarks.length > 0) {
        const spanChildren = textBlock.children.filter((cld) => cld._type === types$1.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));
        if (spanChildren) {
          const orphaned = orphanedMarks.join(", ");
          return resolution = {
            autoResolve: !0,
            patches: spanChildren.map((child) => patches.set((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{
              _key: blk._key
            }, "children", {
              _key: child._key
            }, "marks"])),
            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,
            action: "Remove invalid marks",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.orphaned-marks.description",
              action: "inputs.portable-text.invalid-value.orphaned-marks.action",
              values: {
                key: blk._key,
                orphanedMarks: orphanedMarks.map((m) => m.toString())
              }
            }
          }, !0;
        }
      }
      textBlock.children.some((child, cIndex) => {
        if (!isPlainObject__default.default(child))
          return resolution = {
            patches: [patches.unset([{
              _key: blk._key
            }, "children", cIndex])],
            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,
            action: "Remove the item",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.non-object-child.description",
              action: "inputs.portable-text.invalid-value.non-object-child.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          }, !0;
        if (!child._key || typeof child._key != "string") {
          const newChild = {
            ...child,
            _key: keyGenerator()
          };
          return resolution = {
            autoResolve: !0,
            patches: [patches.set(newChild, [{
              _key: blk._key
            }, "children", cIndex])],
            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,
            action: "Set a new random _key on the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.missing-child-key.description",
              action: "inputs.portable-text.invalid-value.missing-child-key.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          }, !0;
        }
        return child._type ? validChildTypes.includes(child._type) ? child._type === types$1.span.name && typeof child.text != "string" ? (resolution = {
          patches: [patches.set({
            ...child,
            text: ""
          }, [{
            _key: blk._key
          }, "children", {
            _key: child._key
          }])],
          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,
          action: "Write an empty text property to the object",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.invalid-span-text.description",
            action: "inputs.portable-text.invalid-value.invalid-span-text.action",
            values: {
              key: blk._key,
              childKey: child._key
            }
          }
        }, !0) : !1 : (resolution = {
          patches: [patches.unset([{
            _key: blk._key
          }, "children", {
            _key: child._key
          }])],
          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,
          action: "Remove the object",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.disallowed-child-type.description",
            action: "inputs.portable-text.invalid-value.disallowed-child-type.action",
            values: {
              key: blk._key,
              childKey: child._key,
              childType: child._type
            }
          }
        }, !0) : (resolution = {
          patches: [patches.unset([{
            _key: blk._key
          }, "children", {
            _key: child._key
          }])],
          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,
          action: "Remove the object",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-child-type.description",
            action: "inputs.portable-text.invalid-value.missing-child-type.action",
            values: {
              key: blk._key,
              childKey: child._key
            }
          }
        }, !0);
      }) && (valid = !1);
    }
    return !1;
  }) && (valid = !1), {
    valid,
    resolution,
    value
  });
}
function withRemoteChanges(editor, fn) {
  const prev = isChangingRemotely(editor) || !1;
  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);
}
function isChangingRemotely(editor) {
  return IS_PROCESSING_REMOTE_CHANGES.get(editor);
}
const PATCHING = /* @__PURE__ */ new WeakMap();
function withoutPatching(editor, fn) {
  const prev = isPatching(editor);
  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);
}
function isPatching(editor) {
  return PATCHING.get(editor);
}
function cloneDiff(diff2) {
  const [type, patch] = diff2;
  return [type, patch];
}
function getCommonOverlap(textA, textB) {
  let text1 = textA, text2 = textB;
  const text1Length = text1.length, text2Length = text2.length;
  if (text1Length === 0 || text2Length === 0) return 0;
  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));
  const textLength = Math.min(text1Length, text2Length);
  if (text1 === text2) return textLength;
  let best = 0, length = 1;
  for (let found = 0; found !== -1; ) {
    const pattern = text1.substring(textLength - length);
    if (found = text2.indexOf(pattern), found === -1) return best;
    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);
  }
  return best;
}
function getCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1[0] !== text2[0]) return 0;
  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;
  for (; pointerMin < pointerMid; ) text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  return pointerMid;
}
function getCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;
  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;
  for (; pointerMin < pointerMid; ) text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  return pointerMid;
}
function isHighSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 56320 && charCode <= 57343;
}
function bisect(text1, text2, deadline) {
  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);
  for (let x = 0; x < vLength; x++) v1[x] = -1, v2[x] = -1;
  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;
  const delta = text1Length - text2Length, front = delta % 2 !== 0;
  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;
  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1Offset = vOffset + k1;
      let x1;
      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;
      let y1 = x1 - k1;
      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); ) x1++, y1++;
      if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;
      else if (y1 > text2Length) k1start += 2;
      else if (front) {
        const k2Offset = vOffset + delta - k1;
        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
          const x2 = text1Length - v2[k2Offset];
          if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2Offset = vOffset + k2;
      let x2;
      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;
      let y2 = x2 - k2;
      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); ) x2++, y2++;
      if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;
      else if (y2 > text2Length) k2start += 2;
      else if (!front) {
        const k1Offset = vOffset + delta - k2;
        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;
          if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
        }
      }
    }
  }
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}
function bisectSplit(text1, text2, x, y, deadline) {
  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {
    checkLines: !1,
    deadline
  }), diffsb = doDiff(text1b, text2b, {
    checkLines: !1,
    deadline
  });
  return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2, timeout = 1) {
  if (timeout <= 0) return null;
  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;
  if (longText.length < 4 || shortText.length * 2 < longText.length) return null;
  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
  let halfMatch;
  if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
  else {
    if (!halfMatch1 && !halfMatch2) return null;
    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;
  }
  if (!halfMatch) throw new Error("Unable to find a half match.");
  let text1A, text1B, text2A, text2B;
  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);
  const midCommon = halfMatch[4];
  return [text1A, text1B, text2A, text2B, midCommon];
}
function halfMatchI(longText, shortText, i) {
  const seed = longText.slice(i, i + Math.floor(longText.length / 4));
  let j = -1, bestCommon = "", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {
    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));
  }
  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || "", bestLongTextB || "", bestShortTextA || "", bestShortTextB || "", bestCommon || ""] : null;
}
function charsToLines(diffs, lineArray) {
  for (let x = 0; x < diffs.length; x++) {
    const chars = diffs[x][1], text = [];
    for (let y = 0; y < chars.length; y++) text[y] = lineArray[chars.charCodeAt(y)];
    diffs[x][1] = text.join("");
  }
}
function linesToChars(textA, textB) {
  const lineArray = [], lineHash = {};
  lineArray[0] = "";
  function diffLinesToMunge(text) {
    let chars = "", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;
    for (; lineEnd < text.length - 1; ) {
      lineEnd = text.indexOf(`
`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);
      let line = text.slice(lineStart, lineEnd + 1);
      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;
    }
    return chars;
  }
  let maxLines = 4e4;
  const chars1 = diffLinesToMunge(textA);
  maxLines = 65535;
  const chars2 = diffLinesToMunge(textB);
  return {
    chars1,
    chars2,
    lineArray
  };
}
function doLineModeDiff(textA, textB, opts) {
  let text1 = textA, text2 = textB;
  const a = linesToChars(text1, text2);
  text1 = a.chars1, text2 = a.chars2;
  const linearray = a.lineArray;
  let diffs = doDiff(text1, text2, {
    checkLines: !1,
    deadline: opts.deadline
  });
  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "";
  for (; pointer < diffs.length; ) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++, textInsert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        countDelete++, textDelete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (countDelete >= 1 && countInsert >= 1) {
          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;
          const aa = doDiff(textDelete, textInsert, {
            checkLines: !1,
            deadline: opts.deadline
          });
          for (let j = aa.length - 1; j >= 0; j--) diffs.splice(pointer, 0, aa[j]);
          pointer += aa.length;
        }
        countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
    pointer++;
  }
  return diffs.pop(), diffs;
}
function computeDiff(text1, text2, opts) {
  let diffs;
  if (!text1) return [[DIFF_INSERT, text2]];
  if (!text2) return [[DIFF_DELETE, text1]];
  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);
  if (i !== -1) return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;
  if (shorttext.length === 1) return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  const halfMatch = findHalfMatch(text1, text2);
  if (halfMatch) {
    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);
    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);
  }
  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);
}
var __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value
}) : obj[key] = value, __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {})) __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  return a;
};
const DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
  if (textA === null || textB === null) throw new Error("Null input. (diff)");
  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
  return adjustDiffForSurrogatePairs(diffs), diffs;
}
function doDiff(textA, textB, options) {
  let text1 = textA, text2 = textB;
  if (text1 === text2) return text1 ? [[DIFF_EQUAL, text1]] : [];
  let commonlength = getCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);
  let diffs = computeDiff(text1, text2, options);
  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;
}
function createDeadLine(timeout) {
  let t = 1;
  return typeof timeout < "u" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
  return __spreadValues$2({
    checkLines: !0,
    deadline: createDeadLine(opts.timeout || 1)
  }, opts);
}
function combineChar(data, char, dir) {
  return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];
}
function hasSharedChar(diffs, i, j, dir) {
  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
  const inv = dir === 1 ? -1 : 1;
  let insertIdx = null, deleteIdx = null, j = i + dir;
  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {
    const [op, text2] = diffs[j];
    if (text2.length !== 0) {
      if (op === DIFF_INSERT) {
        insertIdx === null && (insertIdx = j);
        continue;
      } else if (op === DIFF_DELETE) {
        deleteIdx === null && (deleteIdx = j);
        continue;
      } else if (op === DIFF_EQUAL) {
        if (insertIdx === null && deleteIdx === null) {
          const [rest, char2] = splitChar(diffs[i][1], dir);
          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);
          return;
        }
        break;
      }
    }
  }
  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);
    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
    return;
  }
  const [text, char] = splitChar(diffs[i][1], dir);
  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
}
function adjustDiffForSurrogatePairs(diffs) {
  for (let i = 0; i < diffs.length; i++) {
    const [diffType, diffText] = diffs[i];
    if (diffText.length === 0) continue;
    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];
    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);
  }
  for (let i = 0; i < diffs.length; i++) diffs[i][1].length === 0 && diffs.splice(i, 1);
}
function cleanupSemantic(rawDiffs) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;
  const equalities = [];
  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;
  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;
  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);
      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;
    }
    pointer++;
  }
  return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\s/, linebreakRegex = /[\r\n]/, blanklineEndRegex = /\n\r?\n$/, blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) return 6;
    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
  }
  let pointer = 1;
  for (; pointer < diffs.length - 1; ) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];
      const commonOffset = getCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
    }
    pointer++;
  }
  return diffs;
}
function cleanupMerge(rawDiffs) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));
  diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "", commonlength;
  for (; pointer < diffs.length; ) switch (diffs[pointer][0]) {
    case DIFF_INSERT:
      countInsert++, textInsert += diffs[pointer][1], pointer++;
      break;
    case DIFF_DELETE:
      countDelete++, textDelete += diffs[pointer][1], pointer++;
      break;
    case DIFF_EQUAL:
      countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
      break;
    default:
      throw new Error("Unknown diff operation");
  }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let hasChanges = !1;
  for (pointer = 1; pointer < diffs.length - 1; ) diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;
  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function trueCount(...args) {
  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs, editCost = 4) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;
  const equalities = [];
  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;
  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;
  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value
}) : obj[key] = value, __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {})) __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  return a;
};
const DEFAULT_OPTIONS = {
  /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */
  threshold: 0.5,
  /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */
  distance: 1e3
};
function applyDefaults(options) {
  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc, opts = {}) {
  if (pattern.length > MAX_BITS$1) throw new Error("Pattern too long for this browser.");
  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);
  function getBitapScore(e, x) {
    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);
    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;
  }
  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);
  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));
  const matchmask = 1 << pattern.length - 1;
  bestLoc = -1;
  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];
  for (let d = 0; d < pattern.length; d++) {
    for (binMin = 0, binMid = binMax; binMin < binMid; ) getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);
    binMax = binMid;
    let start = Math.max(1, loc - binMid + 1);
    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (let j = finish; j >= start; j--) {
      const charMatch = s[text.charAt(j - 1)];
      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {
        const score = getBitapScore(d, j - 1);
        if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);
        else break;
      }
    }
    if (getBitapScore(d + 1, loc) > scoreThreshold) break;
    lastRd = rd;
  }
  return bestLoc;
}
function getAlphabetFromPattern(pattern) {
  const s = {};
  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] = 0;
  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  return s;
}
function match(text, pattern, searchLocation, options = {}) {
  if (text === null || pattern === null || searchLocation === null) throw new Error("Null input. (match())");
  const loc = Math.max(0, Math.min(searchLocation, text.length));
  if (text === pattern) return 0;
  if (text.length) {
    if (text.substring(loc, loc + pattern.length) === pattern) return loc;
  } else return -1;
  return bitap(text, pattern, loc, options);
}
function diffText1(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);
  return text.join("");
}
function diffText2(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);
  return text.join("");
}
function levenshtein(diffs) {
  let leven = 0, insertions = 0, deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0], data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
  }
  return leven += Math.max(insertions, deletions), leven;
}
function xIndex(diffs, location) {
  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;
  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++) lastChars1 = chars1, lastChars2 = chars2;
  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);
}
function countUtf8Bytes(str) {
  let bytes = 0;
  for (let i = 0; i < str.length; i++) {
    const codePoint = str.codePointAt(i);
    if (typeof codePoint > "u") throw new Error("Failed to get codepoint");
    bytes += utf8len(codePoint);
  }
  return bytes;
}
function adjustIndiciesToUcs2(patches2, base, options = {}) {
  let byteOffset = 0, idx = 0;
  function advanceTo(target) {
    for (; byteOffset < target; ) {
      const codePoint = base.codePointAt(idx);
      if (typeof codePoint > "u") return idx;
      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;
    }
    if (!options.allowExceedingIndices && byteOffset !== target) throw new Error("Failed to determine byte offset");
    return idx;
  }
  const adjusted = [];
  for (const patch of patches2) adjusted.push({
    diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),
    start1: advanceTo(patch.start1),
    start2: advanceTo(patch.start2),
    utf8Start1: patch.utf8Start1,
    utf8Start2: patch.utf8Start2,
    length1: patch.length1,
    length2: patch.length2,
    utf8Length1: patch.utf8Length1,
    utf8Length2: patch.utf8Length2
  });
  return adjusted;
}
function utf8len(codePoint) {
  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;
}
const MAX_BITS = 32, DEFAULT_MARGIN = 4;
function addPadding(patches2, margin = DEFAULT_MARGIN) {
  const paddingLength = margin;
  let nullPadding = "";
  for (let x = 1; x <= paddingLength; x++) nullPadding += String.fromCharCode(x);
  for (const p of patches2) p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;
  let patch = patches2[0], diffs = patch.diffs;
  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
  else if (paddingLength > diffs[0][1].length) {
    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;
    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
  }
  if (patch = patches2[patches2.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
  else if (paddingLength > diffs[diffs.length - 1][1].length) {
    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
  }
  return nullPadding;
}
function createPatchObject(start1, start2) {
  return {
    diffs: [],
    start1,
    start2,
    utf8Start1: start1,
    utf8Start2: start2,
    length1: 0,
    length2: 0,
    utf8Length1: 0,
    utf8Length2: 0
  };
}
function splitMax(patches2, margin = DEFAULT_MARGIN) {
  const patchSize = MAX_BITS;
  for (let x = 0; x < patches2.length; x++) {
    if (patches2[x].length1 <= patchSize) continue;
    const bigpatch = patches2[x];
    patches2.splice(x--, 1);
    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = "";
    for (; bigpatch.diffs.length !== 0; ) {
      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
      let empty = !0;
      if (preContext !== "") {
        const precontextByteCount = countUtf8Bytes(preContext);
        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);
      }
      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {
        const diffType = bigpatch.diffs[0][0];
        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);
        if (diffType === DIFF_INSERT) {
          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;
          const diff2 = bigpatch.diffs.shift();
          diff2 && patch.diffs.push(diff2), empty = !1;
        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));
      }
      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);
      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);
      postContext !== "" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches2.splice(++x, 0, patch);
    }
  }
}
function apply(patches2, originalText, opts = {}) {
  if (typeof patches2 == "string") throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
  let text = originalText;
  if (patches2.length === 0) return [text, []];
  const parsed = adjustIndiciesToUcs2(patches2, text, {
    allowExceedingIndices: opts.allowExceedingIndices
  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);
  text = nullPadding + text + nullPadding, splitMax(parsed, margin);
  let delta = 0;
  const results = [];
  for (let x = 0; x < parsed.length; x++) {
    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);
    let startLoc, endLoc = -1;
    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;
    else {
      results[x] = !0, delta = startLoc - expectedLoc;
      let text2;
      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
      else {
        let diffs = diff(text1, text2, {
          checkLines: !1
        });
        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;
        else {
          diffs = cleanupSemanticLossless(diffs);
          let index1 = 0, index2 = 0;
          for (let y = 0; y < parsed[x].diffs.length; y++) {
            const mod = parsed[x].diffs[y];
            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);
          }
        }
      }
    }
  }
  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
  if (!textline) return [];
  const patches2 = [], lines = textline.split(`
`);
  let textPointer = 0;
  for (; textPointer < lines.length; ) {
    const m = lines[textPointer].match(patchHeader);
    if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);
    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
    for (patches2.push(patch), m[2] === "" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === "0" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === "" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === "0" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {
      const currentLine = lines[textPointer], sign = currentLine.charAt(0);
      if (sign === "@") break;
      if (sign === "") {
        textPointer++;
        continue;
      }
      let line;
      try {
        line = decodeURI(currentLine.slice(1));
      } catch {
        throw new Error(`Illegal escape in parse: ${currentLine}`);
      }
      const utf8Diff = countUtf8Bytes(line) - line.length;
      if (sign === "-") patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;
      else if (sign === "+") patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;
      else if (sign === " ") patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;
      else throw new Error(`Invalid patch mode "${sign}" in: ${line}`);
      textPointer++;
    }
  }
  return patches2;
}
function toInt(num) {
  return parseInt(num, 10);
}
const IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();
function withUndoing(editor, fn) {
  const prev = isUndoing(editor);
  IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);
}
function isUndoing(editor) {
  return IS_UDOING.get(editor) ?? !1;
}
function setIsUndoing(editor, isUndoing2) {
  IS_UDOING.set(editor, isUndoing2);
}
function withRedoing(editor, fn) {
  const prev = isRedoing(editor);
  IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);
}
function isRedoing(editor) {
  return IS_REDOING.get(editor) ?? !1;
}
function setIsRedoing(editor, isRedoing2) {
  IS_REDOING.set(editor, isRedoing2);
}
const defaultKeyGenerator = () => randomKey(12), getByteHexTable = /* @__PURE__ */ (() => {
  let table;
  return () => {
    if (table)
      return table;
    table = [];
    for (let i = 0; i < 256; ++i)
      table[i] = (i + 256).toString(16).slice(1);
    return table;
  };
})();
function whatwgRNG(length = 16) {
  const rnds8 = new Uint8Array(length);
  return getRandomValues__default.default(rnds8), rnds8;
}
function randomKey(length) {
  const table = getByteHexTable();
  return whatwgRNG(length).reduce((str, n) => str + table[n], "").slice(0, length);
}
const CURRENT_ACTION_ID = /* @__PURE__ */ new WeakMap();
function withApplyingBehaviorActions(editor, fn) {
  CURRENT_ACTION_ID.set(editor, defaultKeyGenerator()), slate.Editor.withoutNormalizing(editor, fn), CURRENT_ACTION_ID.set(editor, void 0);
}
function getCurrentActionId(editor) {
  return CURRENT_ACTION_ID.get(editor);
}
function isApplyingBehaviorActions(editor) {
  return getCurrentActionId(editor) !== void 0;
}
const CURRENT_UNDO_STEP = /* @__PURE__ */ new WeakMap();
function withUndoStep(editor, fn) {
  const current = CURRENT_UNDO_STEP.get(editor);
  if (current) {
    fn();
    return;
  }
  CURRENT_UNDO_STEP.set(editor, current ?? {
    undoStepId: defaultKeyGenerator()
  }), fn(), CURRENT_UNDO_STEP.set(editor, void 0);
}
function getCurrentUndoStepId(editor) {
  return CURRENT_UNDO_STEP.get(editor)?.undoStepId;
}
const debug$f = debugWithName("plugin:withUndoRedo"), SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {
  const state = SAVING.get(editor);
  return state === void 0 ? !0 : state;
}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);
function createWithUndoRedo(options) {
  const {
    editorActor
  } = options;
  return (editor) => {
    let previousSnapshot = fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name);
    const remotePatches = getRemotePatches(editor);
    let previousUndoStepId = getCurrentUndoStepId(editor);
    options.subscriptions.push(() => {
      debug$f("Subscribing to patches");
      const sub = editorActor.on("patches", ({
        patches: patches2,
        snapshot
      }) => {
        let reset = !1;
        patches2.forEach((patch) => {
          if (!reset && patch.origin !== "local" && remotePatches) {
            if (patch.type === "unset" && patch.path.length === 0) {
              debug$f("Someone else cleared the content, resetting undo/redo history"), editor.history = {
                undos: [],
                redos: []
              }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;
              return;
            }
            remotePatches.push({
              patch,
              time: /* @__PURE__ */ new Date(),
              snapshot,
              previousSnapshot
            });
          }
        }), previousSnapshot = snapshot;
      });
      return () => {
        debug$f("Unsubscribing to patches"), sub.unsubscribe();
      };
    }), editor.history = {
      undos: [],
      redos: []
    };
    const {
      apply: apply2
    } = editor;
    return editor.apply = (op) => {
      if (editorActor.getSnapshot().matches({
        "edit mode": "read only"
      })) {
        apply2(op);
        return;
      }
      if (isChangingRemotely(editor)) {
        apply2(op);
        return;
      }
      if (isUndoing(editor) || isRedoing(editor)) {
        apply2(op);
        return;
      }
      const {
        operations,
        history
      } = editor, {
        undos
      } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor), currentUndoStepId = getCurrentUndoStepId(editor);
      let merge = currentUndoStepId !== void 0 && previousUndoStepId === void 0 ? !1 : currentUndoStepId !== void 0 && previousUndoStepId !== void 0 ? currentUndoStepId === previousUndoStepId : !0;
      if (save) {
        if (step ? operations.length === 0 && (merge = currentUndoStepId === void 0 && previousUndoStepId === void 0 ? shouldMerge(op, lastOp) || overwrite : merge) : merge = !1, step && merge)
          step.operations.push(op);
        else {
          const newStep = {
            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],
            timestamp: /* @__PURE__ */ new Date()
          };
          undos.push(newStep), debug$f("Created new undo step", step);
        }
        for (; undos.length > UNDO_STEP_LIMIT; )
          undos.shift();
        shouldClear(op) && (history.redos = []);
      }
      previousUndoStepId = currentUndoStepId, apply2(op);
    }, editor;
  };
}
const historyUndoActionImplementation = ({
  action
}) => {
  const editor = action.editor, {
    undos
  } = editor.history, remotePatches = getRemotePatches(editor);
  if (undos.length > 0) {
    const step = undos[undos.length - 1];
    if (debug$f("Undoing", step), step.operations.length > 0) {
      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);
      let transformedOperations = step.operations;
      otherPatches.forEach((item) => {
        transformedOperations = flatten__default.default(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));
      });
      const reversedOperations = transformedOperations.map(slate.Operation.inverse).reverse();
      try {
        slate.Editor.withoutNormalizing(editor, () => {
          withUndoing(editor, () => {
            withoutSaving(editor, () => {
              reversedOperations.forEach((op) => {
                editor.apply(op);
              });
            });
          });
        });
      } catch (err) {
        debug$f("Could not perform undo step", err), remotePatches.splice(0, remotePatches.length), slate.Transforms.deselect(editor), editor.history = {
          undos: [],
          redos: []
        }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();
        return;
      }
      editor.history.redos.push(step), editor.history.undos.pop();
    }
  }
}, historyRedoActionImplementation = ({
  action
}) => {
  const editor = action.editor, {
    redos
  } = editor.history, remotePatches = getRemotePatches(editor);
  if (redos.length > 0) {
    const step = redos[redos.length - 1];
    if (debug$f("Redoing", step), step.operations.length > 0) {
      const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);
      let transformedOperations = step.operations;
      otherPatches.forEach((item) => {
        transformedOperations = flatten__default.default(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));
      });
      try {
        slate.Editor.withoutNormalizing(editor, () => {
          withRedoing(editor, () => {
            withoutSaving(editor, () => {
              transformedOperations.forEach((op) => {
                editor.apply(op);
              });
            });
          });
        });
      } catch (err) {
        debug$f("Could not perform redo step", err), remotePatches.splice(0, remotePatches.length), slate.Transforms.deselect(editor), editor.history = {
          undos: [],
          redos: []
        }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();
        return;
      }
      editor.history.undos.push(step), editor.history.redos.pop();
    }
  }
};
function transformOperation(editor, patch, operation, snapshot, previousSnapshot) {
  const transformedOperation = {
    ...operation
  };
  if (patch.type === "insert" && patch.path.length === 1) {
    const insertBlockIndex = (snapshot || []).findIndex((blk) => isEqual__default.default({
      _key: blk._key
    }, patch.path[0]));
    return debug$f(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];
  }
  if (patch.type === "unset" && patch.path.length === 1) {
    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => isEqual__default.default({
      _key: blk._key
    }, patch.path[0]));
    return "path" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$f("Skipping transformation that targeted removed block"), []) : [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];
  }
  if (patch.type === "unset" && patch.path.length === 0)
    return debug$f(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];
  if (patch.type === "diffMatchPatch") {
    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);
    return !operationTargetBlock || !isEqual__default.default({
      _key: operationTargetBlock._key
    }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {
      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;
      const {
        diffs
      } = diffPatch;
      if (diffs.forEach((diff2, index) => {
        const [diffType, text] = diff2;
        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));
      }), transformedOperation.type === "insert_text" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "remove_text" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "set_selection") {
        const currentFocus = transformedOperation.properties?.focus ? {
          ...transformedOperation.properties.focus
        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {
          ...transformedOperation.properties.anchor
        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {
          ...transformedOperation.newProperties.focus
        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {
          ...transformedOperation.newProperties.anchor
        } : void 0;
        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {
          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);
        }), currentFocus && currentAnchor && (transformedOperation.properties = {
          focus: currentFocus,
          anchor: currentAnchor
        }), newFocus && newAnchor && (transformedOperation.newProperties = {
          focus: newFocus,
          anchor: newAnchor
        }));
      }
    }), [transformedOperation]);
  }
  return [transformedOperation];
}
function adjustBlockPath(operation, level, blockIndex) {
  const transformedOperation = {
    ...operation
  };
  if (blockIndex >= 0 && transformedOperation.type !== "set_selection" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {
    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];
    transformedOperation.path = newPath;
  }
  if (transformedOperation.type === "set_selection") {
    const currentFocus = transformedOperation.properties?.focus ? {
      ...transformedOperation.properties.focus
    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {
      ...transformedOperation.properties.anchor
    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {
      ...transformedOperation.newProperties.focus
    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {
      ...transformedOperation.newProperties.anchor
    } : void 0;
    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {
      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);
    }), currentFocus && currentAnchor && (transformedOperation.properties = {
      focus: currentFocus,
      anchor: currentAnchor
    }), newFocus && newAnchor && (transformedOperation.newProperties = {
      focus: newFocus,
      anchor: newAnchor
    }));
  }
  return transformedOperation;
}
const shouldMerge = (op, prev) => !!(op.type === "set_selection" || prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && slate.Path.equals(op.path, prev.path) && op.text !== " " || prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && slate.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === "set_selection" && prev.type === "set_selection"), shouldClear = (op) => op.type !== "set_selection";
function withoutSaving(editor, fn) {
  const prev = isSaving(editor);
  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
  return {
    type: "set_selection",
    properties: {
      ...editor.selection
    },
    newProperties: {
      ...editor.selection
    }
  };
}
function findOperationTargetBlock(editor, operation) {
  let block;
  return operation.type === "set_selection" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : "path" in operation && (block = editor.children[operation.path[0]]), block;
}
const debug$e = debugWithName("sync machine"), syncValueCallback = ({
  sendBack,
  input
}) => {
  updateValue({
    context: input.context,
    sendBack,
    slateEditor: input.slateEditor,
    value: input.value,
    streamBlocks: input.streamBlocks
  });
}, syncValueLogic = xstate.fromCallback(syncValueCallback), syncMachine = xstate.setup({
  types: {
    context: {},
    input: {},
    events: {},
    emitted: {}
  },
  actions: {
    "assign initial value synced": xstate.assign({
      initialValueSynced: !0
    }),
    "assign readOnly": xstate.assign({
      readOnly: ({
        event
      }) => (xstate.assertEvent(event, "update readOnly"), event.readOnly)
    }),
    "assign pending value": xstate.assign({
      pendingValue: ({
        event
      }) => (xstate.assertEvent(event, "update value"), event.value)
    }),
    "clear pending value": xstate.assign({
      pendingValue: void 0
    }),
    "assign previous value": xstate.assign({
      previousValue: ({
        event
      }) => (xstate.assertEvent(event, "done syncing"), event.value)
    }),
    "emit done syncing initial value": xstate.emit({
      type: "done syncing initial value"
    })
  },
  guards: {
    "initial value synced": ({
      context
    }) => context.initialValueSynced,
    "is busy": ({
      context
    }) => {
      const editable = !context.readOnly, isProcessingLocalChanges = context.isProcessingLocalChanges, isChanging = isChangingRemotely(context.slateEditor) ?? !1, isBusy = editable && (isProcessingLocalChanges || isChanging);
      return debug$e("isBusy", {
        isBusy,
        editable,
        isProcessingLocalChanges,
        isChanging
      }), isBusy;
    },
    "value changed while syncing": ({
      context,
      event
    }) => (xstate.assertEvent(event, "done syncing"), context.pendingValue !== event.value),
    "pending value equals previous value": ({
      context
    }) => isEqual__default.default(context.pendingValue, context.previousValue)
  },
  actors: {
    "sync value": syncValueLogic
  }
}).createMachine({
  id: "sync",
  context: ({
    input
  }) => ({
    initialValueSynced: !1,
    isProcessingLocalChanges: !1,
    keyGenerator: input.keyGenerator,
    schema: input.schema,
    readOnly: input.readOnly,
    slateEditor: input.slateEditor,
    pendingValue: void 0,
    previousValue: void 0
  }),
  on: {
    "has pending patches": {
      actions: xstate.assign({
        isProcessingLocalChanges: !0
      })
    },
    mutation: {
      actions: xstate.assign({
        isProcessingLocalChanges: !1
      })
    },
    "update readOnly": {
      actions: ["assign readOnly"]
    }
  },
  type: "parallel",
  states: {
    "setting up": {
      initial: "syncing initial value",
      states: {
        "syncing initial value": {
          entry: [() => {
            debug$e("entry: syncing initial value");
          }],
          exit: [() => {
            debug$e("exit: syncing initial value");
          }],
          always: {
            guard: "initial value synced",
            target: "done syncing initial value"
          }
        },
        "done syncing initial value": {
          entry: ["emit done syncing initial value", () => {
            debug$e("entry: done syncing initial value");
          }],
          exit: [() => {
            debug$e("exit: done syncing initial value");
          }],
          type: "final"
        }
      }
    },
    syncing: {
      initial: "idle",
      states: {
        idle: {
          entry: [() => {
            debug$e("entry: syncing->idle");
          }],
          exit: [() => {
            debug$e("exit: syncing->idle");
          }],
          on: {
            "update value": [{
              guard: "is busy",
              target: "busy",
              actions: ["assign pending value"]
            }, {
              target: "syncing",
              actions: ["assign pending value"]
            }]
          }
        },
        busy: {
          entry: [() => {
            debug$e("entry: syncing->busy");
          }],
          exit: [() => {
            debug$e("exit: syncing->busy");
          }],
          after: {
            1e3: [{
              guard: "is busy",
              target: ".",
              reenter: !0,
              actions: [() => {
                debug$e("reenter: syncing->busy");
              }]
            }, {
              target: "syncing"
            }]
          },
          on: {
            "update value": [{
              actions: ["assign pending value"]
            }]
          }
        },
        syncing: {
          entry: [() => {
            debug$e("entry: syncing->syncing");
          }],
          exit: [() => {
            debug$e("exit: syncing->syncing");
          }],
          always: {
            guard: "pending value equals previous value",
            target: "idle",
            actions: ["clear pending value", "assign initial value synced"]
          },
          invoke: {
            src: "sync value",
            id: "sync value",
            input: ({
              context
            }) => ({
              context: {
                keyGenerator: context.keyGenerator,
                previousValue: context.previousValue,
                readOnly: context.readOnly,
                schema: context.schema
              },
              slateEditor: context.slateEditor,
              streamBlocks: !context.initialValueSynced,
              value: context.pendingValue
            })
          },
          on: {
            "update value": {
              actions: ["assign pending value"]
            },
            patch: {
              actions: [xstate.emit(({
                event
              }) => event)]
            },
            "invalid value": {
              actions: [xstate.emit(({
                event
              }) => event)]
            },
            "value changed": {
              actions: [xstate.emit(({
                event
              }) => event)]
            },
            "done syncing": [{
              guard: "value changed while syncing",
              actions: ["assign previous value", "assign initial value synced"],
              target: "syncing",
              reenter: !0
            }, {
              target: "idle",
              actions: ["clear pending value", "assign previous value", "assign initial value synced"]
            }]
          }
        }
      }
    }
  }
});
async function updateValue({
  context,
  sendBack,
  slateEditor,
  streamBlocks,
  value
}) {
  let isChanged = !1, isValid = !0;
  const hadSelection = !!slateEditor.selection;
  if ((!value || value.length === 0) && (debug$e("Value is empty"), slate.Editor.withoutNormalizing(slateEditor, () => {
    withoutSaving(slateEditor, () => {
      withoutPatching(slateEditor, () => {
        hadSelection && slate.Transforms.deselect(slateEditor);
        const childrenLength = slateEditor.children.length;
        slateEditor.children.forEach((_, index) => {
          slate.Transforms.removeNodes(slateEditor, {
            at: [childrenLength - 1 - index]
          });
        }), slate.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({
          decorators: []
        }), {
          at: [0]
        }), hadSelection && slate.Transforms.select(slateEditor, [0, 0]);
      });
    });
  }), isChanged = !0), value && value.length > 0) {
    const slateValueFromProps = toSlateValue(value, {
      schemaTypes: context.schema
    });
    await new Promise((resolve) => {
      slate.Editor.withoutNormalizing(slateEditor, () => {
        withRemoteChanges(slateEditor, () => {
          withoutPatching(slateEditor, async () => {
            const childrenLength = slateEditor.children.length;
            if (slateValueFromProps.length < childrenLength) {
              for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)
                slate.Transforms.removeNodes(slateEditor, {
                  at: [i]
                });
              isChanged = !0;
            }
            for await (const [currentBlock, currentBlockIndex] of getBlocks({
              slateValue: slateValueFromProps,
              streamBlocks
            })) {
              const {
                blockChanged,
                blockValid
              } = syncBlock({
                context,
                sendBack,
                block: currentBlock,
                index: currentBlockIndex,
                slateEditor,
                value
              });
              isChanged = blockChanged || isChanged, isValid = isValid && blockValid;
            }
            resolve();
          });
        });
      });
    });
  }
  if (!isValid) {
    debug$e("Invalid value, returning"), sendBack({
      type: "done syncing",
      value
    });
    return;
  }
  if (isChanged) {
    debug$e("Server value changed, syncing editor");
    try {
      slateEditor.onChange();
    } catch (err) {
      console.error(err), sendBack({
        type: "invalid value",
        resolution: null,
        value
      }), sendBack({
        type: "done syncing",
        value
      });
      return;
    }
    hadSelection && !slateEditor.selection && (slate.Transforms.select(slateEditor, {
      anchor: {
        path: [0, 0],
        offset: 0
      },
      focus: {
        path: [0, 0],
        offset: 0
      }
    }), slateEditor.onChange()), sendBack({
      type: "value changed",
      value
    });
  } else
    debug$e("Server value and editor value is equal, no need to sync.");
  sendBack({
    type: "done syncing",
    value
  });
}
async function* getBlocks({
  slateValue,
  streamBlocks
}) {
  let index = 0;
  for await (const block of slateValue)
    streamBlocks && index % 10 === 0 && await new Promise((resolve) => setTimeout(resolve, 0)), yield [block, index], index++;
}
function syncBlock({
  context,
  sendBack,
  block,
  index,
  slateEditor,
  value
}) {
  let blockChanged = !1, blockValid = !0;
  const currentBlock = block, currentBlockIndex = index, oldBlock = slateEditor.children[currentBlockIndex], hasChanges = oldBlock && !isEqual__default.default(currentBlock, oldBlock);
  return slate.Editor.withoutNormalizing(slateEditor, () => {
    withRemoteChanges(slateEditor, () => {
      withoutPatching(slateEditor, () => {
        if (hasChanges && blockValid) {
          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);
          !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {
            sendBack({
              type: "patch",
              patch
            });
          })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$e.enabled && debug$e("Updating block", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$e.enabled && debug$e("Replacing block", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), blockChanged = !0) : (sendBack({
            type: "invalid value",
            resolution: validation.resolution,
            value
          }), blockValid = !1);
        }
        if (!oldBlock && blockValid) {
          const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, context.schema, context.keyGenerator);
          debug$e.enabled && debug$e("Validating and inserting new block in the end of the value", currentBlock), validation.valid || validation.resolution?.autoResolve ? slate.Transforms.insertNodes(slateEditor, currentBlock, {
            at: [currentBlockIndex]
          }) : (debug$e("Invalid", validation), sendBack({
            type: "invalid value",
            resolution: validation.resolution,
            value
          }), blockValid = !1);
        }
      });
    });
  }), {
    blockChanged,
    blockValid
  };
}
function _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {
  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;
  selectionFocusOnBlock && slate.Transforms.deselect(slateEditor), slate.Transforms.removeNodes(slateEditor, {
    at: [currentBlockIndex]
  }), slate.Transforms.insertNodes(slateEditor, currentBlock, {
    at: [currentBlockIndex]
  }), slateEditor.onChange(), selectionFocusOnBlock && slate.Transforms.select(slateEditor, currentSelection);
}
function _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {
  if (slate.Transforms.setNodes(slateEditor, currentBlock, {
    at: [currentBlockIndex]
  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {
    const oldBlockChildrenLength = oldBlock.children.length;
    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {
      const childIndex = oldBlockChildrenLength - 1 - index;
      childIndex > 0 && (debug$e("Removing child"), slate.Transforms.removeNodes(slateEditor, {
        at: [currentBlockIndex, childIndex]
      }));
    }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {
      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !isEqual__default.default(currentBlockChild, oldBlockChild), isTextChanged = !isEqual__default.default(currentBlockChild.text, oldBlockChild?.text), path = [currentBlockIndex, currentBlockChildIndex];
      if (isChildChanged)
        if (currentBlockChild._key === oldBlockChild?._key) {
          debug$e("Updating changed child", currentBlockChild, oldBlockChild), slate.Transforms.setNodes(slateEditor, currentBlockChild, {
            at: path
          });
          const isSpanNode = slate.Text.isText(currentBlockChild) && currentBlockChild._type === "span" && slate.Text.isText(oldBlockChild) && oldBlockChild._type === "span";
          isSpanNode && isTextChanged ? (oldBlockChild.text.length > 0 && slate.Transforms.delete(slateEditor, {
            at: {
              focus: {
                path,
                offset: 0
              },
              anchor: {
                path,
                offset: oldBlockChild.text.length
              }
            }
          }), slate.Transforms.insertText(slateEditor, currentBlockChild.text, {
            at: path
          }), slateEditor.onChange()) : isSpanNode || (debug$e("Updating changed inline object child", currentBlockChild), slate.Transforms.setNodes(slateEditor, {
            _key: VOID_CHILD_KEY
          }, {
            at: [...path, 0],
            voids: !0
          }));
        } else oldBlockChild ? (debug$e("Replacing child", currentBlockChild), slate.Transforms.removeNodes(slateEditor, {
          at: [currentBlockIndex, currentBlockChildIndex]
        }), slate.Transforms.insertNodes(slateEditor, currentBlockChild, {
          at: [currentBlockIndex, currentBlockChildIndex]
        }), slateEditor.onChange()) : oldBlockChild || (debug$e("Inserting new child", currentBlockChild), slate.Transforms.insertNodes(slateEditor, currentBlockChild, {
          at: [currentBlockIndex, currentBlockChildIndex]
        }), slateEditor.onChange());
    });
  }
}
const debug$d = debugWithName("component:PortableTextEditor:Synchronizer");
function Synchronizer(props) {
  const $ = reactCompilerRuntime.c(41), {
    editorActor,
    slateEditor
  } = props, incomingValue = react.useSelector(props.editorActor, _temp), readOnly = react.useSelector(props.editorActor, _temp2);
  let t0;
  $[0] !== props.editorActor ? (t0 = props.editorActor.getSnapshot(), $[0] = props.editorActor, $[1] = t0) : t0 = $[1];
  const t1 = t0.context.keyGenerator;
  let t2;
  $[2] !== props.editorActor ? (t2 = props.editorActor.getSnapshot().matches({
    "edit mode": "read only"
  }), $[2] = props.editorActor, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] !== props.editorActor ? (t3 = props.editorActor.getSnapshot(), $[4] = props.editorActor, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== slateEditor || $[7] !== t0.context.keyGenerator || $[8] !== t2 || $[9] !== t3.context.schema ? (t4 = {
    input: {
      keyGenerator: t1,
      readOnly: t2,
      schema: t3.context.schema,
      slateEditor
    }
  }, $[6] = slateEditor, $[7] = t0.context.keyGenerator, $[8] = t2, $[9] = t3.context.schema, $[10] = t4) : t4 = $[10];
  const syncActorRef = react.useActorRef(syncMachine, t4);
  let t5;
  $[11] !== props.editorActor ? (t5 = props.editorActor.getSnapshot(), $[11] = props.editorActor, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== slateEditor || $[14] !== t5.context.schema ? (t6 = {
    input: {
      schema: t5.context.schema,
      slateEditor
    }
  }, $[13] = slateEditor, $[14] = t5.context.schema, $[15] = t6) : t6 = $[15];
  const mutationActorRef = react.useActorRef(mutationMachine, t6);
  let t7, t8;
  $[16] !== editorActor || $[17] !== mutationActorRef || $[18] !== syncActorRef ? (t7 = () => {
    const subscription = mutationActorRef.on("*", (event) => {
      event.type === "has pending patches" && syncActorRef.send({
        type: "has pending patches"
      }), event.type === "mutation" && (syncActorRef.send({
        type: "mutation"
      }), editorActor.send({
        type: "mutation",
        patches: event.patches,
        snapshot: event.snapshot,
        value: event.snapshot
      }));
    });
    return () => {
      subscription.unsubscribe();
    };
  }, t8 = [mutationActorRef, syncActorRef, editorActor], $[16] = editorActor, $[17] = mutationActorRef, $[18] = syncActorRef, $[19] = t7, $[20] = t8) : (t7 = $[19], t8 = $[20]), React.useEffect(t7, t8);
  let t10, t9;
  $[21] !== props.editorActor || $[22] !== slateEditor || $[23] !== syncActorRef ? (t9 = () => {
    const subscription_0 = syncActorRef.on("*", (event_0) => {
      bb15: switch (event_0.type) {
        case "invalid value": {
          props.editorActor.send({
            ...event_0,
            type: "notify.invalid value"
          });
          break bb15;
        }
        case "value changed": {
          props.editorActor.send({
            ...event_0,
            type: "notify.value changed"
          });
          break bb15;
        }
        case "patch": {
          props.editorActor.send({
            ...event_0,
            type: "internal.patch",
            value: fromSlateValue(slateEditor.children, props.editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditor))
          });
          break bb15;
        }
        default:
          props.editorActor.send(event_0);
      }
    });
    return () => {
      subscription_0.unsubscribe();
    };
  }, t10 = [props.editorActor, slateEditor, syncActorRef], $[21] = props.editorActor, $[22] = slateEditor, $[23] = syncActorRef, $[24] = t10, $[25] = t9) : (t10 = $[24], t9 = $[25]), React.useEffect(t9, t10);
  let t11, t12;
  $[26] !== readOnly || $[27] !== syncActorRef ? (t11 = () => {
    syncActorRef.send({
      type: "update readOnly",
      readOnly
    });
  }, t12 = [syncActorRef, readOnly], $[26] = readOnly, $[27] = syncActorRef, $[28] = t11, $[29] = t12) : (t11 = $[28], t12 = $[29]), React.useEffect(t11, t12);
  let t13, t14;
  $[30] !== incomingValue || $[31] !== syncActorRef ? (t13 = () => {
    debug$d("Value from props changed, syncing new value"), syncActorRef.send({
      type: "update value",
      value: incomingValue
    });
  }, t14 = [syncActorRef, incomingValue], $[30] = incomingValue, $[31] = syncActorRef, $[32] = t13, $[33] = t14) : (t13 = $[32], t14 = $[33]), React.useEffect(t13, t14);
  let t15;
  $[34] !== editorActor || $[35] !== mutationActorRef ? (t15 = () => {
    debug$d("Subscribing to patch events");
    const sub = editorActor.on("internal.patch", (event_1) => {
      mutationActorRef.send({
        ...event_1,
        type: "patch"
      });
    });
    return () => {
      debug$d("Unsubscribing to patch events"), sub.unsubscribe();
    };
  }, $[34] = editorActor, $[35] = mutationActorRef, $[36] = t15) : t15 = $[36];
  let t16;
  return $[37] !== editorActor || $[38] !== mutationActorRef || $[39] !== slateEditor ? (t16 = [editorActor, mutationActorRef, slateEditor], $[37] = editorActor, $[38] = mutationActorRef, $[39] = slateEditor, $[40] = t16) : t16 = $[40], React.useEffect(t15, t16), null;
}
function _temp2(s_0) {
  return s_0.matches({
    "edit mode": "read only"
  });
}
function _temp(s) {
  return s.context.incomingValue;
}
Synchronizer.displayName = "Synchronizer";
const converterJson = {
  mimeType: "application/json",
  serialize: ({
    snapshot,
    event
  }) => {
    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === "application/x-portable-text");
    return portableTextConverter ? {
      ...portableTextConverter.serialize({
        snapshot,
        event
      }),
      mimeType: "application/json",
      originEvent: event.originEvent
    } : {
      type: "serialization.failure",
      mimeType: "application/json",
      originEvent: event.originEvent,
      reason: "No application/x-portable-text Converter found"
    };
  },
  deserialize: ({
    snapshot,
    event
  }) => {
    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === "application/x-portable-text");
    return portableTextConverter ? {
      ...portableTextConverter.deserialize({
        snapshot,
        event
      }),
      mimeType: "application/json"
    } : {
      type: "deserialization.failure",
      mimeType: "application/json",
      reason: "No application/x-portable-text Converter found"
    };
  }
}, converterPortableText = {
  mimeType: "application/x-portable-text",
  serialize: ({
    snapshot,
    event
  }) => {
    const selection = snapshot.beta.internalDrag?.origin.selection ?? snapshot.context.selection;
    if (!selection)
      return {
        type: "serialization.failure",
        mimeType: "application/x-portable-text",
        originEvent: event.originEvent,
        reason: "No selection"
      };
    const blocks = util_sliceBlocks.sliceBlocks({
      blocks: snapshot.context.value,
      selection
    });
    return blocks.length === 0 ? {
      type: "serialization.failure",
      mimeType: "application/x-portable-text",
      reason: "No blocks serialized",
      originEvent: event.originEvent
    } : {
      type: "serialization.success",
      data: JSON.stringify(blocks),
      mimeType: "application/x-portable-text",
      originEvent: event.originEvent
    };
  },
  deserialize: ({
    snapshot,
    event
  }) => {
    const blocks = JSON.parse(event.data);
    if (!Array.isArray(blocks))
      return {
        type: "deserialization.failure",
        mimeType: "application/x-portable-text",
        reason: "Data is not an array"
      };
    const parsedBlocks = blocks.flatMap((block) => {
      const parsedBlock = parseBlocks.parseBlock({
        context: snapshot.context,
        block,
        options: {
          /**
           * If we are dragging internally then we would like to keep the
           * dropped portable text as is.
           */
          refreshKeys: !snapshot.beta.hasTag?.("dragging internally")
        }
      });
      return parsedBlock ? [parsedBlock] : [];
    });
    return parsedBlocks.length === 0 && blocks.length > 0 ? {
      type: "deserialization.failure",
      mimeType: "application/x-portable-text",
      reason: "No blocks were parsed"
    } : {
      type: "deserialization.success",
      data: parsedBlocks,
      mimeType: "application/x-portable-text"
    };
  }
};
function createConverterTextHtml(legacySchema) {
  return {
    mimeType: "text/html",
    serialize: ({
      snapshot,
      event
    }) => {
      const selection = snapshot.beta.internalDrag?.origin.selection ?? snapshot.context.selection;
      if (!selection)
        return {
          type: "serialization.failure",
          mimeType: "text/html",
          originEvent: event.originEvent,
          reason: "No selection"
        };
      const blocks = util_sliceBlocks.sliceBlocks({
        blocks: snapshot.context.value,
        selection
      }), html = toHtml.toHTML(blocks, {
        onMissingComponent: !1,
        components: {
          unknownType: ({
            children
          }) => children !== void 0 ? `${children}` : ""
        }
      });
      return html === "" ? {
        type: "serialization.failure",
        mimeType: "text/html",
        originEvent: event.originEvent,
        reason: "Serialized HTML is empty"
      } : {
        type: "serialization.success",
        data: html,
        mimeType: "text/html",
        originEvent: event.originEvent
      };
    },
    deserialize: ({
      snapshot,
      event
    }) => {
      const parsedBlocks = blockTools.htmlToBlocks(event.data, legacySchema.portableText, {
        keyGenerator: snapshot.context.keyGenerator,
        unstable_whitespaceOnPasteMode: legacySchema.block.options.unstable_whitespaceOnPasteMode
      }).flatMap((block) => {
        const parsedBlock = parseBlocks.parseBlock({
          context: snapshot.context,
          block,
          options: {
            refreshKeys: !1
          }
        });
        return parsedBlock ? [parsedBlock] : [];
      });
      return parsedBlocks.length === 0 ? {
        type: "deserialization.failure",
        mimeType: "text/html",
        reason: "No blocks deserialized"
      } : {
        type: "deserialization.success",
        data: parsedBlocks,
        mimeType: "text/html"
      };
    }
  };
}
function createConverterTextPlain(legacySchema) {
  return {
    mimeType: "text/plain",
    serialize: ({
      snapshot,
      event
    }) => {
      const selection = snapshot.beta.internalDrag?.origin.selection ?? snapshot.context.selection;
      return selection ? {
        type: "serialization.success",
        data: util_sliceBlocks.sliceBlocks({
          blocks: snapshot.context.value,
          selection
        }).map((block) => types.isPortableTextTextBlock(block) ? block.children.map((child) => child._type === snapshot.context.schema.span.name ? child.text : snapshot.beta.hasTag("dragging internally") ? `[${snapshot.context.schema.inlineObjects.find((inlineObjectType) => inlineObjectType.name === child._type)?.title ?? "Object"}]` : "").join("") : snapshot.beta.hasTag("dragging internally") ? `[${snapshot.context.schema.blockObjects.find((blockObjectType) => blockObjectType.name === block._type)?.title ?? "Object"}]` : "").filter((block) => block !== "").join(`

`),
        mimeType: "text/plain",
        originEvent: event.originEvent
      } : {
        type: "serialization.failure",
        mimeType: "text/plain",
        originEvent: event.originEvent,
        reason: "No selection"
      };
    },
    deserialize: ({
      snapshot,
      event
    }) => {
      const textToHtml = `<html><body>${escapeHtml(event.data).split(/\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\r\n|\r|\n)/g, "<br/>")}</p>` : "<p></p>").join("")}</body></html>`, parsedBlocks = blockTools.htmlToBlocks(textToHtml, legacySchema.portableText, {
        keyGenerator: snapshot.context.keyGenerator
      }).flatMap((block) => {
        const parsedBlock = parseBlocks.parseBlock({
          context: snapshot.context,
          block,
          options: {
            refreshKeys: !1
          }
        });
        return parsedBlock ? [parsedBlock] : [];
      });
      return parsedBlocks.length === 0 ? {
        type: "deserialization.failure",
        mimeType: "text/plain",
        reason: "No blocks deserialized"
      } : {
        type: "deserialization.success",
        data: parsedBlocks,
        mimeType: "text/plain"
      };
    }
  };
}
const entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(str) {
  return String(str).replace(/[&<>"'`=/]/g, (s) => entityMap[s]);
}
function createCoreConverters(legacySchema) {
  return [converterJson, converterPortableText, createConverterTextHtml(legacySchema), createConverterTextPlain(legacySchema)];
}
function compileType(rawType) {
  return schema.Schema.compile({
    name: "blockTypeSchema",
    types: [rawType]
  }).get(rawType.name);
}
const debug$c = debugWithName("operationToPatches");
function createOperationToPatches(editorActor) {
  const textBlockName = editorActor.getSnapshot().context.schema.block.name;
  function insertTextPatch(editor, operation, beforeValue) {
    debug$c.enabled && debug$c("Operation", JSON.stringify(operation, null, 2));
    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];
    if (!block)
      throw new Error("Could not find block");
    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];
    if (!textChild)
      throw new Error("Could not find child");
    const path = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : "", patch = patches.diffMatchPatch(prevText, textChild.text, path);
    return patch.value.length ? [patch] : [];
  }
  function removeTextPatch(editor, operation, beforeValue) {
    const block = editor && editor.children[operation.path[0]];
    if (!block)
      throw new Error("Could not find block");
    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;
    if (child && !textChild)
      throw new Error("Expected span");
    if (!textChild)
      throw new Error("Could not find child");
    const path = [{
      _key: block._key
    }, "children", {
      _key: textChild._key
    }, "text"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = patches.diffMatchPatch(prevText || "", textChild.text, path);
    return patch.value ? [patch] : [];
  }
  function setNodePatch(editor, operation) {
    if (operation.path.length === 1) {
      const block = editor.children[operation.path[0]];
      if (typeof block._key != "string")
        throw new Error("Expected block to have a _key");
      const setNode = omitBy__default.default({
        ...editor.children[operation.path[0]],
        ...operation.newProperties
      }, isUndefined__default.default);
      return [patches.set(fromSlateValue([setNode], textBlockName)[0], [{
        _key: block._key
      }])];
    } else if (operation.path.length === 2) {
      const block = editor.children[operation.path[0]];
      if (editor.isTextBlock(block)) {
        const child = block.children[operation.path[1]];
        if (child) {
          const blockKey = block._key, childKey = child._key, patches$1 = [], keys = Object.keys(operation.newProperties);
          return keys.forEach((keyName) => {
            if (keys.length === 1 && keyName === "_key") {
              const val = get__default.default(operation.newProperties, keyName);
              patches$1.push(patches.set(val, [{
                _key: blockKey
              }, "children", block.children.indexOf(child), keyName]));
            } else {
              const val = get__default.default(operation.newProperties, keyName);
              patches$1.push(patches.set(val, [{
                _key: blockKey
              }, "children", {
                _key: childKey
              }, keyName]));
            }
          }), patches$1;
        }
        throw new Error("Could not find a valid child");
      }
      throw new Error("Could not find a valid block");
    } else
      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);
  }
  function insertNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]], isTextBlock = editor.isTextBlock(block);
    if (operation.path.length === 1) {
      const position = operation.path[0] === 0 ? "before" : "after", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;
      return targetKey ? [patches.insert([fromSlateValue([operation.node], textBlockName)[0]], position, [{
        _key: targetKey
      }])] : [patches.setIfMissing(beforeValue, []), patches.insert([fromSlateValue([operation.node], textBlockName)[0]], "before", [operation.path[0]])];
    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {
      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? "before" : "after", node = {
        ...operation.node
      };
      !node._type && slate.Text.isText(node) && (node._type = "span", node.marks = []);
      const child = fromSlateValue([{
        _key: "bogus",
        _type: textBlockName,
        children: [node]
      }], textBlockName)[0].children[0];
      return [patches.insert([child], position, [{
        _key: block._key
      }, "children", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {
        _key: block.children[operation.path[1] - 1]._key
      }])];
    }
    return debug$c("Something was inserted into a void block. Not producing editor patches."), [];
  }
  function splitNodePatch(editor, operation, beforeValue) {
    const patches$1 = [], splitBlock = editor.children[operation.path[0]];
    if (!editor.isTextBlock(splitBlock))
      throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);
    if (operation.path.length === 1) {
      const oldBlock = beforeValue[operation.path[0]];
      if (editor.isTextBlock(oldBlock)) {
        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];
        targetValue && (patches$1.push(patches.insert([targetValue], "after", [{
          _key: splitBlock._key
        }])), oldBlock.children.slice(operation.position).forEach((span) => {
          const path = [{
            _key: oldBlock._key
          }, "children", {
            _key: span._key
          }];
          patches$1.push(patches.unset(path));
        }));
      }
      return patches$1;
    }
    if (operation.path.length === 2) {
      const splitSpan = splitBlock.children[operation.path[1]];
      if (editor.isTextSpan(splitSpan)) {
        const targetSpans = fromSlateValue([{
          ...splitBlock,
          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)
        }], textBlockName)[0].children;
        patches$1.push(patches.insert(targetSpans, "after", [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }])), patches$1.push(patches.set(splitSpan.text, [{
          _key: splitBlock._key
        }, "children", {
          _key: splitSpan._key
        }, "text"]));
      }
      return patches$1;
    }
    return patches$1;
  }
  function removeNodePatch(editor, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    if (operation.path.length === 1) {
      if (block && block._key)
        return [patches.unset([{
          _key: block._key
        }])];
      throw new Error("Block not found");
    } else if (editor.isTextBlock(block) && operation.path.length === 2) {
      const spanToRemove = block.children[operation.path[1]];
      return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \`_key\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [patches.unset([{
        _key: block._key
      }, "children", {
        _key: spanToRemove._key
      }])] : (debug$c("Span not found in editor trying to remove node"), []);
    } else
      return debug$c("Not creating patch inside object block"), [];
  }
  function mergeNodePatch(editor, operation, beforeValue) {
    const patches$1 = [], block = beforeValue[operation.path[0]], updatedBlock = editor.children[operation.path[0]];
    if (operation.path.length === 1)
      if (block?._key) {
        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];
        patches$1.push(patches.set(newBlock, [{
          _key: newBlock._key
        }])), patches$1.push(patches.unset([{
          _key: block._key
        }]));
      } else
        throw new Error("Target key not found!");
    else if (editor.isTextBlock(block) && editor.isTextBlock(updatedBlock) && operation.path.length === 2) {
      const updatedSpan = updatedBlock.children[operation.path[1] - 1] && editor.isTextSpan(updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && editor.isTextSpan(block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;
      updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches$1.push(patches.set(updatedSpan.text, [{
        _key: block._key
      }, "children", {
        _key: updatedSpan._key
      }, "text"])) : console.warn(`Multiple spans have \`_key\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches$1.push(patches.unset([{
        _key: block._key
      }, "children", {
        _key: removedSpan._key
      }])) : console.warn(`Multiple spans have \`_key\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));
    } else
      debug$c("Void nodes can't be merged, not creating any patches");
    return patches$1;
  }
  function moveNodePatch(editor, operation, beforeValue) {
    const patches$1 = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];
    if (!targetBlock)
      return patches$1;
    if (operation.path.length === 1) {
      const position = operation.path[0] > operation.newPath[0] ? "before" : "after";
      patches$1.push(patches.unset([{
        _key: block._key
      }])), patches$1.push(patches.insert([fromSlateValue([block], textBlockName)[0]], position, [{
        _key: targetBlock._key
      }]));
    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {
      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? "after" : "before", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
      patches$1.push(patches.unset([{
        _key: block._key
      }, "children", {
        _key: child._key
      }])), patches$1.push(patches.insert([childToInsert], position, [{
        _key: targetBlock._key
      }, "children", {
        _key: targetChild._key
      }]));
    }
    return patches$1;
  }
  return {
    insertNodePatch,
    insertTextPatch,
    mergeNodePatch,
    moveNodePatch,
    removeNodePatch,
    removeTextPatch,
    setNodePatch,
    splitNodePatch
  };
}
const insertTextActionImplementation = ({
  action
}) => {
  action.editor.marks ? slate.Transforms.insertNodes(action.editor, {
    text: action.text,
    ...action.editor.marks
  }) : slate.Transforms.insertText(action.editor, action.text), action.editor.marks = null;
};
function isPortableTextSpan(node) {
  return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == "string"));
}
function isPortableTextBlock(node) {
  return (
    // A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    (!("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def) => typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child) => typeof child == "object" && "_type" in child)
  );
}
function getPreviousSpan({
  editor,
  blockPath,
  spanPath
}) {
  let previousSpan;
  for (const [child, childPath] of slate.Node.children(editor, blockPath, {
    reverse: !0
  }))
    if (editor.isTextSpan(child) && slate.Path.isBefore(childPath, spanPath)) {
      previousSpan = child;
      break;
    }
  return previousSpan;
}
function getNextSpan({
  editor,
  blockPath,
  spanPath
}) {
  let nextSpan;
  for (const [child, childPath] of slate.Node.children(editor, blockPath))
    if (editor.isTextSpan(child) && slate.Path.isAfter(childPath, spanPath)) {
      nextSpan = child;
      break;
    }
  return nextSpan;
}
const debug$b = debugWithName("plugin:withPortableTextMarkModel");
function createWithPortableTextMarkModel(editorActor) {
  return function(editor) {
    const {
      apply: apply2,
      normalizeNode
    } = editor, decorators = editorActor.getSnapshot().context.schema.decorators.map((t) => t.name);
    return editor.normalizeNode = (nodeEntry) => {
      const [node, path] = nodeEntry;
      if (editor.isTextBlock(node)) {
        const children = slate.Node.children(editor, path);
        for (const [child, childPath] of children) {
          const nextNode = node.children[childPath[1] + 1];
          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark) => nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark) => child.marks?.includes(mark))) {
            debug$b("Merging spans", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({
              type: "normalizing"
            }), slate.Transforms.mergeNodes(editor, {
              at: [childPath[0], childPath[1] + 1],
              voids: !0
            }), editorActor.send({
              type: "done normalizing"
            });
            return;
          }
        }
      }
      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {
        debug$b("Adding .markDefs to block node"), editorActor.send({
          type: "normalizing"
        }), slate.Transforms.setNodes(editor, {
          markDefs: []
        }, {
          at: path
        }), editorActor.send({
          type: "done normalizing"
        });
        return;
      }
      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {
        debug$b("Adding .marks to span node"), editorActor.send({
          type: "normalizing"
        }), slate.Transforms.setNodes(editor, {
          marks: []
        }, {
          at: path
        }), editorActor.send({
          type: "done normalizing"
        });
        return;
      }
      if (editor.isTextSpan(node)) {
        const blockPath = slate.Path.parent(path), [block] = slate.Editor.node(editor, blockPath), decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), annotations = node.marks?.filter((mark) => !decorators2.includes(mark));
        if (editor.isTextBlock(block) && node.text === "" && annotations && annotations.length > 0) {
          debug$b("Removing annotations from empty span node"), editorActor.send({
            type: "normalizing"
          }), slate.Transforms.setNodes(editor, {
            marks: node.marks?.filter((mark) => decorators2.includes(mark))
          }, {
            at: path
          }), editorActor.send({
            type: "done normalizing"
          });
          return;
        }
      }
      if (editor.isTextBlock(node)) {
        const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name);
        for (const [child, childPath] of slate.Node.children(editor, path))
          if (editor.isTextSpan(child)) {
            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !node.markDefs?.find((def) => def._key === mark));
            if (orphanedAnnotations.length > 0) {
              debug$b("Removing orphaned annotations from span node"), editorActor.send({
                type: "normalizing"
              }), slate.Transforms.setNodes(editor, {
                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))
              }, {
                at: childPath
              }), editorActor.send({
                type: "done normalizing"
              });
              return;
            }
          }
      }
      if (editor.isTextSpan(node)) {
        const blockPath = slate.Path.parent(path), [block] = slate.Editor.node(editor, blockPath);
        if (editor.isTextBlock(block)) {
          const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !block.markDefs?.find((def) => def._key === mark));
          if (orphanedAnnotations.length > 0) {
            debug$b("Removing orphaned annotations from span node"), editorActor.send({
              type: "normalizing"
            }), slate.Transforms.setNodes(editor, {
              marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))
            }, {
              at: path
            }), editorActor.send({
              type: "done normalizing"
            });
            return;
          }
        }
      }
      if (editor.isTextBlock(node)) {
        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];
        for (const markDef of markDefs)
          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));
        if (markDefs.length !== newMarkDefs.length) {
          debug$b("Removing duplicate markDefs"), editorActor.send({
            type: "normalizing"
          }), slate.Transforms.setNodes(editor, {
            markDefs: newMarkDefs
          }, {
            at: path
          }), editorActor.send({
            type: "done normalizing"
          });
          return;
        }
      }
      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === "merge_node" && "markDefs" in op.properties && op.path.length === 1)) {
        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));
        if (node.markDefs && !isEqual__default.default(newMarkDefs, node.markDefs)) {
          debug$b("Removing markDef not in use"), editorActor.send({
            type: "normalizing"
          }), slate.Transforms.setNodes(editor, {
            markDefs: newMarkDefs
          }, {
            at: path
          }), editorActor.send({
            type: "done normalizing"
          });
          return;
        }
      }
      normalizeNode(nodeEntry);
    }, editor.apply = (op) => {
      if (isChangingRemotely(editor)) {
        apply2(op);
        return;
      }
      if (isUndoing(editor) || isRedoing(editor)) {
        apply2(op);
        return;
      }
      if (op.type === "set_selection" && slate.Editor.marks(editor) && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {
        const previousSelectionIsCollapsed = slate.Range.isCollapsed({
          anchor: op.properties.anchor,
          focus: op.properties.focus
        }), newSelectionIsCollapsed = slate.Range.isCollapsed({
          anchor: op.newProperties.anchor,
          focus: op.newProperties.focus
        });
        if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {
          const focusSpan = Array.from(slate.Editor.nodes(editor, {
            mode: "lowest",
            at: op.properties.focus,
            match: (n) => editor.isTextSpan(n),
            voids: !1
          }))[0]?.[0], newFocusSpan = Array.from(slate.Editor.nodes(editor, {
            mode: "lowest",
            at: op.newProperties.focus,
            match: (n) => editor.isTextSpan(n),
            voids: !1
          }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;
          if (movedToNextSpan || movedToPreviousSpan)
            return;
        }
      }
      if (op.type === "insert_node") {
        const {
          selection
        } = editor;
        if (selection) {
          const [_block, blockPath] = slate.Editor.node(editor, selection, {
            depth: 1
          }), previousSpan = getPreviousSpan({
            editor,
            blockPath,
            spanPath: op.path
          }), previousSpanAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], nextSpan = getNextSpan({
            editor,
            blockPath,
            spanPath: [op.path[0], op.path[1] - 1]
          }), nextSpanAnnotations = nextSpan ? nextSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], annotationsEnding = previousSpanAnnotations?.filter((annotation) => !nextSpanAnnotations?.includes(annotation)) ?? [], atTheEndOfAnnotation = annotationsEnding.length > 0;
          if (atTheEndOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsEnding.includes(mark))) {
            slate.Transforms.insertNodes(editor, {
              ...op.node,
              _key: editorActor.getSnapshot().context.keyGenerator(),
              marks: op.node.marks?.filter((mark) => !annotationsEnding.includes(mark)) ?? []
            });
            return;
          }
          const annotationsStarting = nextSpanAnnotations?.filter((annotation) => !previousSpanAnnotations?.includes(annotation)) ?? [], atTheStartOfAnnotation = annotationsStarting.length > 0;
          if (atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsStarting.includes(mark))) {
            slate.Transforms.insertNodes(editor, {
              ...op.node,
              _key: editorActor.getSnapshot().context.keyGenerator(),
              marks: op.node.marks?.filter((mark) => !annotationsStarting.includes(mark)) ?? []
            });
            return;
          }
          const nextSpanDecorators = nextSpan?.marks?.filter((mark) => decorators.includes(mark)) ?? [];
          if (nextSpanDecorators.length > 0 && atTheEndOfAnnotation && !atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.length === 0) {
            slate.Transforms.insertNodes(editor, {
              ...op.node,
              _key: editorActor.getSnapshot().context.keyGenerator(),
              marks: nextSpanDecorators
            });
            return;
          }
        }
      }
      if (op.type === "insert_text") {
        const {
          selection
        } = editor, collapsedSelection = selection ? slate.Range.isCollapsed(selection) : !1;
        if (selection && collapsedSelection) {
          const [_block, blockPath] = slate.Editor.node(editor, selection, {
            depth: 1
          }), [span, spanPath] = Array.from(slate.Editor.nodes(editor, {
            mode: "lowest",
            at: selection.focus,
            match: (n) => editor.isTextSpan(n),
            voids: !1
          }))[0] ?? [void 0, void 0], marks = span.marks ?? [], marksWithoutAnnotations = marks.filter((mark) => decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = span.text.length === 0, atTheBeginningOfSpan = selection.anchor.offset === 0, atTheEndOfSpan = selection.anchor.offset === span.text.length, previousSpan = getPreviousSpan({
            editor,
            blockPath,
            spanPath
          }), nextSpan = getNextSpan({
            editor,
            blockPath,
            spanPath
          }), nextSpanAnnotations = nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark) => !decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)).every((mark) => marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.marks?.every((mark) => marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) => nextSpanAnnotations?.includes(mark));
          if (spanHasAnnotations && !spanIsEmpty) {
            if (atTheBeginningOfSpan) {
              if (previousSpanHasSameMarks) {
                slate.Transforms.insertNodes(editor, {
                  _type: "span",
                  _key: editorActor.getSnapshot().context.keyGenerator(),
                  text: op.text,
                  marks: previousSpan?.marks ?? []
                });
                return;
              } else if (previousSpanHasSameAnnotations) {
                slate.Transforms.insertNodes(editor, {
                  _type: "span",
                  _key: editorActor.getSnapshot().context.keyGenerator(),
                  text: op.text,
                  marks: previousSpan?.marks ?? []
                });
                return;
              } else if (previousSpanHasSameAnnotation) {
                apply2(op);
                return;
              } else if (!previousSpan) {
                slate.Transforms.insertNodes(editor, {
                  _type: "span",
                  _key: editorActor.getSnapshot().context.keyGenerator(),
                  text: op.text,
                  marks: []
                });
                return;
              }
            }
            if (atTheEndOfSpan) {
              if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) {
                slate.Transforms.insertNodes(editor, {
                  _type: "span",
                  _key: editorActor.getSnapshot().context.keyGenerator(),
                  text: op.text,
                  marks: nextSpan?.marks ?? []
                });
                return;
              }
              if (!nextSpan) {
                slate.Transforms.insertNodes(editor, {
                  _type: "span",
                  _key: editorActor.getSnapshot().context.keyGenerator(),
                  text: op.text,
                  marks: []
                });
                return;
              }
            }
          }
          if (atTheBeginningOfSpan && !spanIsEmpty && previousSpan) {
            slate.Transforms.insertNodes(editor, {
              _type: "span",
              _key: editorActor.getSnapshot().context.keyGenerator(),
              text: op.text,
              marks: previousSpanHasAnnotations ? [] : (previousSpan.marks ?? []).filter((mark) => decorators.includes(mark))
            });
            return;
          }
        }
      }
      if (op.type === "remove_text") {
        const {
          selection
        } = editor;
        if (selection && slate.Range.isExpanded(selection)) {
          const [block, blockPath] = slate.Editor.node(editor, selection, {
            depth: 1
          }), [span, spanPath] = Array.from(slate.Editor.nodes(editor, {
            mode: "lowest",
            at: {
              path: op.path,
              offset: op.offset
            },
            match: (n) => editor.isTextSpan(n),
            voids: !1
          }))[0] ?? [void 0, void 0];
          if (span && block && isPortableTextBlock(block)) {
            const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark) => markDefs.find((markDef) => markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({
              editor,
              blockPath,
              spanPath
            }), nextSpan = getNextSpan({
              editor,
              blockPath,
              spanPath
            }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;
            if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {
              const marksWithoutAnnotationMarks = ({
                ...slate.Editor.marks(editor) || {}
              }.marks || []).filter((mark) => decorators.includes(mark));
              slate.Editor.withoutNormalizing(editor, () => {
                apply2(op), slate.Transforms.setNodes(editor, {
                  marks: marksWithoutAnnotationMarks
                }, {
                  at: op.path
                });
              }), editor.onChange();
              return;
            }
          }
        }
      }
      if (op.type === "merge_node" && op.path.length === 1 && "markDefs" in op.properties && op.properties._type === editorActor.getSnapshot().context.schema.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
        const [targetBlock, targetPath] = slate.Editor.node(editor, [op.path[0] - 1]);
        if (editor.isTextBlock(targetBlock)) {
          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = uniq__default.default([...oldDefs, ...op.properties.markDefs]);
          debug$b("Copying markDefs over to merged block", op), slate.Transforms.setNodes(editor, {
            markDefs: newMarkDefs
          }, {
            at: targetPath,
            voids: !1
          }), apply2(op);
          return;
        }
      }
      apply2(op);
    }, editor;
  };
}
const removeDecoratorActionImplementation = ({
  action
}) => {
  const editor = action.editor, mark = action.decorator, {
    selection
  } = editor;
  if (selection) {
    if (slate.Range.isExpanded(selection))
      slate.Transforms.setNodes(editor, {}, {
        match: slate.Text.isText,
        split: !0,
        hanging: !0
      }), editor.selection && [...slate.Editor.nodes(editor, {
        at: editor.selection,
        match: slate.Text.isText
      })].forEach(([node, path]) => {
        const block = editor.children[path[0]];
        slate.Element.isElement(block) && block.children.includes(node) && slate.Transforms.setNodes(editor, {
          marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
          _type: "span"
        }, {
          at: path
        });
      });
    else {
      const [block, blockPath] = slate.Editor.node(editor, selection, {
        depth: 1
      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === "" ? block.children[0] : void 0;
      if (lonelyEmptySpan) {
        const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);
        slate.Transforms.setNodes(editor, {
          marks: existingMarksWithoutDecorator
        }, {
          at: blockPath,
          match: (node) => editor.isTextSpan(node)
        });
      } else {
        const existingMarks = {
          ...slate.Editor.marks(editor) || {}
        }.marks || [], marks = {
          ...slate.Editor.marks(editor) || {},
          marks: existingMarks.filter((eMark) => eMark !== mark)
        };
        editor.marks = {
          marks: marks.marks,
          _type: "span"
        };
      }
    }
    if (editor.selection) {
      const selection2 = editor.selection;
      editor.selection = {
        ...selection2
      };
    }
  }
};
function isDecoratorActive({
  editor,
  decorator
}) {
  if (!editor.selection)
    return !1;
  const selectedTextNodes = Array.from(slate.Editor.nodes(editor, {
    match: slate.Text.isText,
    at: editor.selection
  }));
  return selectedTextNodes.length === 0 ? !1 : slate.Range.isExpanded(editor.selection) ? selectedTextNodes.every((n) => {
    const [node] = n;
    return node.marks?.includes(decorator);
  }) : ({
    ...slate.Editor.marks(editor) || {}
  }.marks || []).includes(decorator);
}
const addAnnotationActionImplementation = ({
  context,
  action
}) => {
  const parsedAnnotation = parseBlocks.parseAnnotation({
    annotation: {
      _type: action.annotation.name,
      ...action.annotation.value
    },
    context,
    options: {
      refreshKeys: !1
    }
  });
  if (!parsedAnnotation)
    throw new Error(`Failed to parse annotation ${JSON.stringify(action.annotation)}`);
  const editor = action.editor;
  if (!editor.selection || slate.Range.isCollapsed(editor.selection))
    return;
  let paths, spanPath, markDefPath;
  const markDefPaths = [], selectedBlocks = slate.Editor.nodes(editor, {
    at: editor.selection,
    match: (node) => editor.isTextBlock(node),
    reverse: slate.Range.isBackward(editor.selection)
  });
  let blockIndex = 0;
  for (const [block, blockPath] of selectedBlocks) {
    if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === "")
      continue;
    const annotationKey = blockIndex === 0 ? parsedAnnotation._key : context.keyGenerator(), markDefs = block.markDefs ?? [];
    markDefs.find((markDef) => markDef._type === parsedAnnotation._type && markDef._key === annotationKey) === void 0 && (slate.Transforms.setNodes(editor, {
      markDefs: [...markDefs, {
        ...parsedAnnotation,
        _key: annotationKey
      }]
    }, {
      at: blockPath
    }), markDefPath = [{
      _key: block._key
    }, "markDefs", {
      _key: annotationKey
    }], slate.Range.isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), slate.Transforms.setNodes(editor, {}, {
      match: slate.Text.isText,
      split: !0
    });
    const children = slate.Node.children(editor, blockPath);
    for (const [span, path] of children) {
      if (!editor.isTextSpan(span) || !slate.Range.includes(editor.selection, path))
        continue;
      const marks = span.marks ?? [], existingSameTypeAnnotations = marks.filter((mark) => markDefs.some((markDef) => markDef._key === mark && markDef._type === parsedAnnotation._type));
      slate.Transforms.setNodes(editor, {
        marks: [...marks.filter((mark) => !existingSameTypeAnnotations.includes(mark)), annotationKey]
      }, {
        at: path
      }), spanPath = [{
        _key: block._key
      }, "children", {
        _key: span._key
      }];
    }
    blockIndex++;
  }
  return markDefPath && spanPath && (paths = {
    markDefPath,
    markDefPaths,
    spanPath
  }), paths;
}, removeAnnotationActionImplementation = ({
  action
}) => {
  const editor = action.editor;
  if (editor.selection)
    if (slate.Range.isCollapsed(editor.selection)) {
      const [block, blockPath] = slate.Editor.node(editor, editor.selection, {
        depth: 1
      });
      if (!editor.isTextBlock(block))
        return;
      const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === action.annotation.name), [selectedChild, selectedChildPath] = slate.Editor.node(editor, editor.selection, {
        depth: 2
      });
      if (!editor.isTextSpan(selectedChild))
        return;
      const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));
      if (!annotationToRemove)
        return;
      const previousSpansWithSameAnnotation = [];
      for (const [child, childPath] of slate.Node.children(editor, blockPath, {
        reverse: !0
      }))
        if (editor.isTextSpan(child) && slate.Path.isBefore(childPath, selectedChildPath))
          if (child.marks?.includes(annotationToRemove))
            previousSpansWithSameAnnotation.push([child, childPath]);
          else
            break;
      const nextSpansWithSameAnnotation = [];
      for (const [child, childPath] of slate.Node.children(editor, blockPath))
        if (editor.isTextSpan(child) && slate.Path.isAfter(childPath, selectedChildPath))
          if (child.marks?.includes(annotationToRemove))
            nextSpansWithSameAnnotation.push([child, childPath]);
          else
            break;
      for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])
        slate.Transforms.setNodes(editor, {
          marks: child.marks?.filter((mark) => mark !== annotationToRemove)
        }, {
          at: childPath
        });
    } else {
      slate.Transforms.setNodes(editor, {}, {
        match: (node) => editor.isTextSpan(node),
        split: !0,
        hanging: !0
      });
      const blocks = slate.Editor.nodes(editor, {
        at: editor.selection,
        match: (node) => editor.isTextBlock(node)
      });
      for (const [block, blockPath] of blocks) {
        const children = slate.Node.children(editor, blockPath);
        for (const [child, childPath] of children) {
          if (!editor.isTextSpan(child) || !slate.Range.includes(editor.selection, childPath))
            continue;
          const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== action.annotation.name);
          marksWithoutAnnotation.length !== marks.length && slate.Transforms.setNodes(editor, {
            marks: marksWithoutAnnotation
          }, {
            at: childPath
          });
        }
      }
    }
};
function toSlatePath(path, editor) {
  if (!editor)
    return [];
  const [block, blockPath] = Array.from(slate.Editor.nodes(editor, {
    at: [],
    match: (n) => types.isKeySegment(path[0]) && n._key === path[0]._key
  }))[0] || [void 0, void 0];
  if (!block || !slate.Element.isElement(block))
    return [];
  if (editor.isVoid(block))
    return [blockPath[0], 0];
  const childPath = [path[2]], childIndex = block.children.findIndex((child) => isEqual__default.default([{
    _key: child._key
  }], childPath));
  if (childIndex >= 0 && block.children[childIndex]) {
    const child = block.children[childIndex];
    return slate.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);
  }
  return [blockPath[0], 0];
}
function toSlateRange(selection, editor) {
  if (!selection || !editor)
    return null;
  const anchor = {
    path: toSlatePath(selection.anchor.path, editor),
    offset: selection.anchor.offset
  }, focus = {
    path: toSlatePath(selection.focus.path, editor),
    offset: selection.focus.offset
  };
  return focus.path.length === 0 || anchor.path.length === 0 ? null : anchor && focus ? {
    anchor,
    focus
  } : null;
}
function moveRangeByOperation(range, operation) {
  const anchor = slate.Point.transform(range.anchor, operation), focus = slate.Point.transform(range.focus, operation);
  return anchor === null || focus === null ? null : slate.Point.equals(anchor, range.anchor) && slate.Point.equals(focus, range.focus) ? range : {
    anchor,
    focus
  };
}
const blockSetBehaviorActionImplementation = ({
  context,
  action
}) => {
  const location = toSlateRange({
    anchor: {
      path: action.at,
      offset: 0
    },
    focus: {
      path: action.at,
      offset: 0
    }
  }, action.editor);
  if (!location)
    throw new Error(`Unable to convert ${JSON.stringify(action.at)} into a Slate Range`);
  const block = slate.Editor.node(action.editor, location, {
    depth: 1
  })?.[0];
  if (!block)
    throw new Error(`Unable to find block at ${JSON.stringify(action.at)}`);
  const parsedBlock = fromSlateValue([block], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)).at(0);
  if (!parsedBlock)
    throw new Error(`Unable to parse block at ${JSON.stringify(action.at)}`);
  const {
    _type,
    ...filteredProps
  } = action.props, updatedBlock = parseBlocks.parseBlock({
    context,
    block: {
      ...parsedBlock,
      ...filteredProps
    },
    options: {
      refreshKeys: !1
    }
  });
  if (!updatedBlock)
    throw new Error(`Unable to update block at ${JSON.stringify(action.at)}`);
  const slateBlock = toSlateValue([updatedBlock], {
    schemaTypes: context.schema
  })?.at(0);
  if (!slateBlock)
    throw new Error("Unable to convert block to Slate value");
  slate.Transforms.setNodes(action.editor, slateBlock, {
    at: location
  });
}, blockUnsetBehaviorActionImplementation = ({
  context,
  action
}) => {
  const location = toSlateRange({
    anchor: {
      path: action.at,
      offset: 0
    },
    focus: {
      path: action.at,
      offset: 0
    }
  }, action.editor);
  if (!location)
    throw new Error(`Unable to convert ${JSON.stringify(action.at)} into a Slate Range`);
  const block = slate.Editor.node(action.editor, location, {
    depth: 1
  })?.[0];
  if (!block)
    throw new Error(`Unable to find block at ${JSON.stringify(action.at)}`);
  const parsedBlock = fromSlateValue([block], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)).at(0);
  if (!parsedBlock)
    throw new Error(`Unable to parse block at ${JSON.stringify(action.at)}`);
  if (parseBlocks.isTextBlock(context.schema, parsedBlock)) {
    const propsToRemove = action.props.filter((prop) => prop !== "_type"), updatedTextBlock = parseBlocks.parseBlock({
      context,
      block: omit__default.default(parsedBlock, propsToRemove),
      options: {
        refreshKeys: !1
      }
    });
    if (!updatedTextBlock)
      throw new Error(`Unable to update block at ${JSON.stringify(action.at)}`);
    const propsToSet = {};
    for (const prop of propsToRemove)
      prop in updatedTextBlock ? propsToSet[prop] = updatedTextBlock[prop] : propsToSet[prop] = void 0;
    slate.Transforms.setNodes(action.editor, propsToSet, {
      at: location
    });
    return;
  }
  const updatedBlockObject = parseBlocks.parseBlock({
    context,
    block: omit__default.default(parsedBlock, action.props.filter((prop) => prop !== "_type")),
    options: {
      refreshKeys: !1
    }
  });
  if (!updatedBlockObject)
    throw new Error(`Unable to update block at ${JSON.stringify(action.at)}`);
  const {
    _type,
    _key,
    ...props
  } = updatedBlockObject;
  slate.Transforms.setNodes(action.editor, {
    _type,
    _key,
    value: props
  }, {
    at: location
  });
};
function getFocusBlock({
  editor
}) {
  if (!editor.selection)
    return [void 0, void 0];
  try {
    return slate.Editor.node(editor, editor.selection.focus.path.slice(0, 1)) ?? [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getSelectionStartBlock({
  editor
}) {
  if (!editor.selection)
    return [void 0, void 0];
  const selectionStartPoint = slate.Range.start(editor.selection);
  return getPointBlock({
    editor,
    point: selectionStartPoint
  });
}
function getSelectionEndBlock({
  editor
}) {
  if (!editor.selection)
    return [void 0, void 0];
  const selectionEndPoint = slate.Range.end(editor.selection);
  return getPointBlock({
    editor,
    point: selectionEndPoint
  });
}
function getPointBlock({
  editor,
  point
}) {
  try {
    const [block] = slate.Editor.node(editor, point.path.slice(0, 1)) ?? [void 0, void 0];
    return block ? [block, point.path.slice(0, 1)] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getFocusChild({
  editor
}) {
  const [focusBlock, focusBlockPath] = getFocusBlock({
    editor
  }), childIndex = editor.selection?.focus.path.at(1);
  if (!focusBlock || !focusBlockPath || childIndex === void 0)
    return [void 0, void 0];
  try {
    const focusChild = slate.Node.child(focusBlock, childIndex);
    return focusChild ? [focusChild, [...focusBlockPath, childIndex]] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getPointChild({
  editor,
  point
}) {
  const [block, blockPath] = getPointBlock({
    editor,
    point
  }), childIndex = point.path.at(1);
  if (!block || !blockPath || childIndex === void 0)
    return [void 0, void 0];
  try {
    const pointChild = slate.Node.child(block, childIndex);
    return pointChild ? [pointChild, [...blockPath, childIndex]] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getFirstBlock({
  editor
}) {
  const firstBlockPath = slate.Editor.start(editor, []).path.at(0);
  try {
    return firstBlockPath !== void 0 ? slate.Editor.node(editor, [firstBlockPath]) ?? [void 0, void 0] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getLastBlock({
  editor
}) {
  const lastBlockPath = slate.Editor.end(editor, []).path.at(0);
  try {
    return lastBlockPath !== void 0 ? slate.Editor.node(editor, [lastBlockPath]) ?? [void 0, void 0] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getNodeBlock({
  editor,
  schema: schema2,
  node
}) {
  if (slate.Editor.isEditor(node))
    return;
  if (isBlockElement({
    editor,
    schema: schema2
  }, node))
    return elementToBlock({
      schema: schema2,
      element: node
    });
  const parent = Array.from(slate.Editor.nodes(editor, {
    mode: "highest",
    at: [],
    match: (n) => isBlockElement({
      editor,
      schema: schema2
    }, n) && n.children.some((child) => child._key === node._key)
  })).at(0)?.at(0);
  return slate.Element.isElement(parent) ? elementToBlock({
    schema: schema2,
    element: parent
  }) : void 0;
}
function elementToBlock({
  schema: schema2,
  element
}) {
  return fromSlateValue([element], schema2.block.name)?.at(0);
}
function isBlockElement({
  editor,
  schema: schema2
}, node) {
  return slate.Element.isElement(node) && !editor.isInline(node) && (schema2.block.name === node._type || schema2.blockObjects.some((blockObject) => blockObject.name === node._type));
}
function isListItemActive({
  editor,
  listItem
}) {
  if (!editor.selection)
    return !1;
  const selectedBlocks = [...slate.Editor.nodes(editor, {
    at: editor.selection,
    match: (node) => editor.isTextBlock(node)
  })];
  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listItem) : !1;
}
function isStyleActive({
  editor,
  style
}) {
  if (!editor.selection)
    return !1;
  const selectedBlocks = [...slate.Editor.nodes(editor, {
    at: editor.selection,
    match: (node) => editor.isTextBlock(node)
  })];
  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => node.style === style) : !1;
}
function slateRangeToSelection({
  schema: schema2,
  editor,
  range
}) {
  const [anchorBlock] = getPointBlock({
    editor,
    point: range.anchor
  }), [focusBlock] = getPointBlock({
    editor,
    point: range.focus
  });
  if (!anchorBlock || !focusBlock)
    return null;
  const [anchorChild] = anchorBlock._type === schema2.block.name ? getPointChild({
    editor,
    point: range.anchor
  }) : [void 0, void 0], [focusChild] = focusBlock._type === schema2.block.name ? getPointChild({
    editor,
    point: range.focus
  }) : [void 0, void 0], selection = {
    anchor: {
      path: [{
        _key: anchorBlock._key
      }],
      offset: range.anchor.offset
    },
    focus: {
      path: [{
        _key: focusBlock._key
      }],
      offset: range.focus.offset
    },
    backward: slate.Range.isBackward(range)
  };
  return anchorChild && (selection.anchor.path.push("children"), selection.anchor.path.push({
    _key: anchorChild._key
  })), focusChild && (selection.focus.path.push("children"), selection.focus.path.push({
    _key: focusChild._key
  })), selection;
}
const decoratorAddActionImplementation = ({
  context,
  action
}) => {
  const editor = action.editor, mark = action.decorator, value = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), manualAnchor = action.at?.anchor ? util_sliceBlocks.blockOffsetToSpanSelectionPoint({
    value,
    blockOffset: action.at.anchor,
    direction: "backward"
  }) : void 0, manualFocus = action.at?.focus ? util_sliceBlocks.blockOffsetToSpanSelectionPoint({
    value,
    blockOffset: action.at.focus,
    direction: "forward"
  }) : void 0, manualSelection = manualAnchor && manualFocus ? {
    anchor: manualAnchor,
    focus: manualFocus
  } : void 0, selection = manualSelection ? toSlateRange(manualSelection, action.editor) ?? editor.selection : editor.selection;
  if (!selection)
    return;
  const editorSelection = slateRangeToSelection({
    schema: context.schema,
    editor,
    range: selection
  }), anchorOffset = editorSelection ? util_selectionPointToBlockOffset.selectionPointToBlockOffset({
    value,
    selectionPoint: editorSelection.anchor
  }) : void 0, focusOffset = editorSelection ? util_selectionPointToBlockOffset.selectionPointToBlockOffset({
    value,
    selectionPoint: editorSelection.focus
  }) : void 0;
  if (!anchorOffset || !focusOffset)
    throw new Error("Unable to find anchor or focus offset");
  if (slate.Range.isExpanded(selection)) {
    slate.Transforms.setNodes(editor, {}, {
      at: selection,
      match: slate.Text.isText,
      split: !0,
      hanging: !0
    });
    const newValue = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), newSelection = util_selectionPointToBlockOffset.blockOffsetsToSelection({
      value: newValue,
      offsets: {
        anchor: anchorOffset,
        focus: focusOffset
      },
      backward: editorSelection?.backward
    }), trimmedSelection = selector_isSelectingEntireBlocks.getTrimmedSelection({
      context: {
        activeDecorators: [],
        converters: [],
        keyGenerator: context.keyGenerator,
        readOnly: !1,
        schema: context.schema,
        selection: newSelection,
        value: newValue
      }
    });
    if (!trimmedSelection)
      throw new Error("Unable to find trimmed selection");
    const newRange = toSlateRange(trimmedSelection, editor);
    if (!newRange)
      throw new Error("Unable to find new selection");
    const splitTextNodes = slate.Range.isRange(newRange) ? [...slate.Editor.nodes(editor, {
      at: newRange,
      match: (node) => slate.Text.isText(node)
    })] : [];
    for (const [node, path] of splitTextNodes) {
      const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];
      slate.Transforms.setNodes(editor, {
        marks
      }, {
        at: path,
        match: slate.Text.isText,
        split: !0,
        hanging: !0
      });
    }
  } else {
    if (!Array.from(slate.Editor.nodes(editor, {
      at: selection,
      match: (node) => editor.isTextSpan(node)
    }))?.at(0))
      return;
    const [block, blockPath] = slate.Editor.node(editor, selection, {
      depth: 1
    }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === "" ? block.children[0] : void 0;
    if (lonelyEmptySpan) {
      const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);
      slate.Transforms.setNodes(editor, {
        marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator
      }, {
        at: blockPath,
        match: (node) => editor.isTextSpan(node)
      });
    } else {
      const existingMarks = {
        ...slate.Editor.marks(editor) || {}
      }.marks || [], marks = {
        ...slate.Editor.marks(editor) || {},
        marks: [...existingMarks, mark]
      };
      editor.marks = marks;
    }
  }
  if (editor.selection) {
    const selection2 = editor.selection;
    editor.selection = {
      ...selection2
    };
  }
}, deleteActionImplementation = ({
  action
}) => {
  const range = toSlateRange(action.at, action.editor);
  if (!range)
    throw new Error(`Failed to get Slate Range for selection ${JSON.stringify(action.at)}`);
  action.editor.delete({
    at: range
  });
}, deleteBackwardActionImplementation = ({
  action
}) => {
  action.editor.deleteBackward(action.unit);
}, deleteBlockActionImplementation = ({
  action
}) => {
  const range = toSlateRange({
    anchor: {
      path: action.at,
      offset: 0
    },
    focus: {
      path: action.at,
      offset: 0
    }
  }, action.editor);
  if (!range) {
    console.error("Unable to find Slate range from selection points");
    return;
  }
  slate.Transforms.removeNodes(action.editor, {
    at: range
  });
}, deleteForwardActionImplementation = ({
  action
}) => {
  action.editor.deleteForward(action.unit);
}, effectActionImplementation = ({
  action
}) => {
  action.effect();
}, insertInlineObjectActionImplementation = ({
  context,
  action
}) => {
  const parsedInlineObject = parseBlocks.parseInlineObject({
    context,
    inlineObject: {
      _type: action.inlineObject.name,
      ...action.inlineObject.value ?? {}
    },
    options: {
      refreshKeys: !1
    }
  });
  if (!parsedInlineObject)
    throw new Error(`Failed to parse inline object ${JSON.stringify(action.inlineObject)}`);
  if (!action.editor.selection) {
    console.error("Unable to insert inline object without selection");
    return;
  }
  const [focusTextBlock] = Array.from(slate.Editor.nodes(action.editor, {
    at: action.editor.selection.focus.path,
    match: (node) => action.editor.isTextBlock(node)
  })).at(0) ?? [void 0, void 0];
  if (!focusTextBlock) {
    console.error("Unable to perform action without focus text block");
    return;
  }
  const child = toSlateValue([{
    _type: context.schema.block.name,
    _key: context.keyGenerator(),
    children: [parsedInlineObject]
  }], {
    schemaTypes: context.schema
  }).at(0)?.children.at(0);
  if (!child) {
    console.error("Unable to insert inline object");
    return;
  }
  slate.Transforms.insertNodes(action.editor, child);
}, insertSpanActionImplementation = ({
  context,
  action
}) => {
  if (!action.editor.selection) {
    console.error("Unable to perform action without selection", action);
    return;
  }
  const [focusBlock, focusBlockPath] = Array.from(slate.Editor.nodes(action.editor, {
    at: action.editor.selection.focus.path,
    match: (node) => action.editor.isTextBlock(node)
  }))[0] ?? [void 0, void 0];
  if (!focusBlock || !focusBlockPath) {
    console.error("Unable to perform action without focus block", action);
    return;
  }
  const markDefs = focusBlock.markDefs ?? [], annotations = action.annotations ? action.annotations.map((annotation) => ({
    _type: annotation.name,
    _key: context.keyGenerator(),
    ...annotation.value
  })) : void 0;
  annotations && annotations.length > 0 && slate.Transforms.setNodes(action.editor, {
    markDefs: [...markDefs, ...annotations]
  }), slate.Transforms.insertNodes(action.editor, {
    _type: "span",
    _key: context.keyGenerator(),
    text: action.text,
    marks: [...annotations?.map((annotation) => annotation._key) ?? [], ...action.decorators ?? []]
  });
}, insertBlockActionImplementation = ({
  context,
  action
}) => {
  const parsedBlock = parseBlocks.parseBlock({
    block: action.block,
    context,
    options: {
      refreshKeys: !1
    }
  });
  if (!parsedBlock)
    throw new Error(`Failed to parse block ${JSON.stringify(action.block)}`);
  const fragment = toSlateValue([parsedBlock], {
    schemaTypes: context.schema
  })[0];
  if (!fragment)
    throw new Error(`Failed to convert block to Slate fragment ${JSON.stringify(parsedBlock)}`);
  insertBlock({
    block: fragment,
    placement: action.placement,
    select: action.select ?? "start",
    editor: action.editor,
    schema: context.schema
  });
};
function insertBlock({
  block,
  placement,
  select,
  editor,
  schema: schema2
}) {
  const [startBlock, startBlockPath] = getSelectionStartBlock({
    editor
  }), [endBlock, endBlockPath] = getSelectionEndBlock({
    editor
  });
  if (!editor.selection || !startBlock || !startBlockPath || !endBlock || !endBlockPath) {
    select !== "none" && slateDom.DOMEditor.focus(editor);
    const [lastBlock, lastBlockPath] = getLastBlock({
      editor
    });
    if (placement === "before")
      slate.Transforms.insertNodes(editor, [block], {
        at: [0]
      }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, [0])) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, [0]));
    else if (placement === "after") {
      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0];
      slate.Transforms.insertNodes(editor, [block], {
        at: nextPath,
        select: !1
      }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, nextPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, nextPath));
    } else {
      if (lastBlock && isEqualToEmptyEditor([lastBlock], schema2)) {
        slate.Transforms.removeNodes(editor, {
          at: lastBlockPath
        }), slate.Transforms.insertNodes(editor, [block], {
          at: lastBlockPath,
          select: !1
        }), slate.Transforms.deselect(editor), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, lastBlockPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, lastBlockPath));
        return;
      }
      if (editor.isTextBlock(block) && lastBlock && editor.isTextBlock(lastBlock)) {
        const selectionBefore = slate.Editor.end(editor, lastBlockPath);
        slate.Transforms.insertFragment(editor, [block], {
          at: slate.Editor.end(editor, lastBlockPath)
        }), select === "start" ? slate.Transforms.select(editor, selectionBefore) : select === "none" && slate.Transforms.deselect(editor);
        return;
      }
      const nextPath = lastBlockPath ? [lastBlockPath[0] + 1] : [0];
      slate.Transforms.insertNodes(editor, [block], {
        at: nextPath,
        select: !1
      }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, nextPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, nextPath));
    }
  } else if (placement === "before") {
    const currentSelection = editor.selection, selectionStartPoint = slate.Range.start(currentSelection);
    slate.Transforms.insertNodes(editor, [block], {
      at: [selectionStartPoint.path[0]],
      select: !1
    }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, [selectionStartPoint.path[0]])) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, [selectionStartPoint.path[0]]));
  } else if (placement === "after") {
    const currentSelection = editor.selection, nextPath = [slate.Range.end(currentSelection).path[0] + 1];
    slate.Transforms.insertNodes(editor, [block], {
      at: nextPath,
      select: !1
    }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, nextPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, nextPath));
  } else {
    const currentSelection = editor.selection, endBlockEndPoint = slate.Editor.start(editor, endBlockPath);
    if (slate.Range.isExpanded(currentSelection) && !editor.isTextBlock(block)) {
      slate.Transforms.delete(editor, {
        at: currentSelection
      });
      const newSelection = editor.selection, [focusBlock, focusBlockPath] = getFocusBlock({
        editor
      });
      slate.Transforms.insertNodes(editor, [block], {
        voids: !0
      });
      const adjustedSelection = newSelection.anchor.offset === 0 ? slate.Range.transform(newSelection, {
        type: "insert_node",
        node: block,
        path: [newSelection.anchor.path[0]]
      }) : newSelection;
      select === "none" && adjustedSelection && slate.Transforms.select(editor, adjustedSelection), focusBlock && isEqualToEmptyEditor([focusBlock], schema2) && slate.Transforms.removeNodes(editor, {
        at: focusBlockPath
      });
      return;
    }
    if (editor.isTextBlock(endBlock) && editor.isTextBlock(block)) {
      const selectionStartPoint = slate.Range.start(currentSelection);
      if (select === "end") {
        slate.Transforms.insertFragment(editor, [block], {
          voids: !0
        });
        return;
      }
      slate.Transforms.insertFragment(editor, [block], {
        at: currentSelection,
        voids: !0
      }), select === "start" ? slate.Transforms.select(editor, selectionStartPoint) : slate.Point.equals(selectionStartPoint, endBlockEndPoint) || slate.Transforms.select(editor, selectionStartPoint);
    } else if (editor.isTextBlock(endBlock)) {
      const endBlockStartPoint = slate.Editor.start(editor, endBlockPath), endBlockEndPoint2 = slate.Editor.end(editor, endBlockPath), selectionStartPoint = slate.Range.start(currentSelection), selectionEndPoint = slate.Range.end(currentSelection);
      if (slate.Range.isCollapsed(currentSelection) && slate.Point.equals(selectionStartPoint, endBlockStartPoint))
        slate.Transforms.insertNodes(editor, [block], {
          at: endBlockPath,
          select: !1
        }), (select === "start" || select === "end") && slate.Transforms.select(editor, slate.Editor.start(editor, endBlockPath)), isEqualToEmptyEditor([endBlock], schema2) && slate.Transforms.removeNodes(editor, {
          at: slate.Path.next(endBlockPath)
        });
      else if (slate.Range.isCollapsed(currentSelection) && slate.Point.equals(selectionEndPoint, endBlockEndPoint2)) {
        const nextPath = [endBlockPath[0] + 1];
        slate.Transforms.insertNodes(editor, [block], {
          at: nextPath,
          select: !1
        }), (select === "start" || select === "end") && slate.Transforms.select(editor, slate.Editor.start(editor, nextPath));
      } else if (slate.Range.isExpanded(currentSelection) && slate.Point.equals(selectionStartPoint, endBlockStartPoint) && slate.Point.equals(selectionEndPoint, endBlockEndPoint2))
        slate.Transforms.insertFragment(editor, [block], {
          at: currentSelection
        }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, endBlockPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, endBlockPath));
      else if (slate.Range.isExpanded(currentSelection) && slate.Point.equals(selectionStartPoint, endBlockStartPoint))
        slate.Transforms.insertFragment(editor, [block], {
          at: currentSelection
        }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, endBlockPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, endBlockPath));
      else if (slate.Range.isExpanded(currentSelection) && slate.Point.equals(selectionEndPoint, endBlockEndPoint2))
        slate.Transforms.insertFragment(editor, [block], {
          at: currentSelection
        }), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, slate.Path.next(endBlockPath))) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, slate.Path.next(endBlockPath)));
      else {
        const currentSelection2 = editor.selection, [focusChild] = getFocusChild({
          editor
        });
        if (focusChild && editor.isTextSpan(focusChild))
          slate.Transforms.insertFragment(editor, [block], {
            at: currentSelection2
          }), select === "start" || select === "end" ? slate.Transforms.select(editor, [endBlockPath[0] + 1]) : slate.Transforms.select(editor, currentSelection2);
        else {
          const nextPath = [endBlockPath[0] + 1];
          slate.Transforms.insertNodes(editor, [block], {
            at: nextPath,
            select: !1
          }), slate.Transforms.select(editor, currentSelection2), select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, nextPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, nextPath));
        }
      }
    } else {
      slate.Transforms.insertNodes(editor, [block], {
        select: !1
      });
      const nextPath = [endBlockPath[0] + 1];
      select === "start" ? slate.Transforms.select(editor, slate.Editor.start(editor, nextPath)) : select === "end" && slate.Transforms.select(editor, slate.Editor.end(editor, nextPath));
    }
  }
}
const moveBackwardActionImplementation = ({
  action
}) => {
  slate.Transforms.move(action.editor, {
    unit: "character",
    distance: action.distance,
    reverse: !0
  });
}, moveBlockActionImplementation = ({
  action
}) => {
  const at = [toSlatePath(action.at, action.editor)[0]], to = [toSlatePath(action.to, action.editor)[0]];
  slate.Transforms.moveNodes(action.editor, {
    at,
    to,
    mode: "highest"
  });
}, moveForwardActionImplementation = ({
  action
}) => {
  slate.Transforms.move(action.editor, {
    unit: "character",
    distance: action.distance
  });
}, selectActionImplementation = ({
  action
}) => {
  const newSelection = toSlateRange(action.at, action.editor);
  newSelection ? slate.Transforms.select(action.editor, newSelection) : slate.Transforms.deselect(action.editor);
}, debug$a = debugWithName("behaviors:action"), behaviorActionImplementations = {
  "annotation.add": addAnnotationActionImplementation,
  "annotation.remove": removeAnnotationActionImplementation,
  "block.set": blockSetBehaviorActionImplementation,
  "block.unset": blockUnsetBehaviorActionImplementation,
  "decorator.add": decoratorAddActionImplementation,
  "decorator.remove": removeDecoratorActionImplementation,
  delete: deleteActionImplementation,
  "delete.backward": deleteBackwardActionImplementation,
  "delete.forward": deleteForwardActionImplementation,
  "delete.block": deleteBlockActionImplementation,
  "history.redo": historyRedoActionImplementation,
  "history.undo": historyUndoActionImplementation,
  "insert.block": insertBlockActionImplementation,
  "insert.inline object": insertInlineObjectActionImplementation,
  "insert.span": insertSpanActionImplementation,
  "insert.text": insertTextActionImplementation,
  effect: effectActionImplementation,
  "move.backward": moveBackwardActionImplementation,
  "move.block": moveBlockActionImplementation,
  "move.forward": moveForwardActionImplementation,
  select: selectActionImplementation
};
function performAction({
  context,
  action
}) {
  switch (debug$a(JSON.stringify(omit__default.default(action, ["editor"]), null, 2)), action.type) {
    case "annotation.add": {
      behaviorActionImplementations["annotation.add"]({
        context,
        action
      });
      break;
    }
    case "annotation.remove": {
      behaviorActionImplementations["annotation.remove"]({
        context,
        action
      });
      break;
    }
    case "block.set": {
      behaviorActionImplementations["block.set"]({
        context,
        action
      });
      break;
    }
    case "block.unset": {
      behaviorActionImplementations["block.unset"]({
        context,
        action
      });
      break;
    }
    case "decorator.add": {
      behaviorActionImplementations["decorator.add"]({
        context,
        action
      });
      break;
    }
    case "decorator.remove": {
      behaviorActionImplementations["decorator.remove"]({
        context,
        action
      });
      break;
    }
    case "delete": {
      behaviorActionImplementations.delete({
        context,
        action
      });
      break;
    }
    case "delete.backward": {
      behaviorActionImplementations["delete.backward"]({
        context,
        action
      });
      break;
    }
    case "delete.block": {
      behaviorActionImplementations["delete.block"]({
        context,
        action
      });
      break;
    }
    case "delete.forward": {
      behaviorActionImplementations["delete.forward"]({
        context,
        action
      });
      break;
    }
    case "effect": {
      behaviorActionImplementations.effect({
        context,
        action
      });
      break;
    }
    case "history.redo": {
      behaviorActionImplementations["history.redo"]({
        context,
        action
      });
      break;
    }
    case "history.undo": {
      behaviorActionImplementations["history.undo"]({
        context,
        action
      });
      break;
    }
    case "insert.block": {
      behaviorActionImplementations["insert.block"]({
        context,
        action
      });
      break;
    }
    case "insert.inline object": {
      behaviorActionImplementations["insert.inline object"]({
        context,
        action
      });
      break;
    }
    case "insert.span": {
      behaviorActionImplementations["insert.span"]({
        context,
        action
      });
      break;
    }
    case "insert.text": {
      behaviorActionImplementations["insert.text"]({
        context,
        action
      });
      break;
    }
    case "move.backward": {
      behaviorActionImplementations["move.backward"]({
        context,
        action
      });
      break;
    }
    case "move.block": {
      behaviorActionImplementations["move.block"]({
        context,
        action
      });
      break;
    }
    case "move.forward": {
      behaviorActionImplementations["move.forward"]({
        context,
        action
      });
      break;
    }
    default: {
      behaviorActionImplementations.select({
        context,
        action
      });
      break;
    }
  }
}
function createWithEventListeners(editorActor) {
  return function(editor) {
    if (editorActor.getSnapshot().context.maxBlocks !== void 0)
      return editor;
    const {
      deleteBackward,
      deleteForward,
      insertBreak,
      insertText,
      select
    } = editor;
    return editor.deleteBackward = (unit) => {
      if (isApplyingBehaviorActions(editor)) {
        deleteBackward(unit);
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "delete.backward",
          unit
        },
        editor
      });
    }, editor.deleteForward = (unit) => {
      if (isApplyingBehaviorActions(editor)) {
        deleteForward(unit);
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "delete.forward",
          unit
        },
        editor
      });
    }, editor.insertBreak = () => {
      if (isApplyingBehaviorActions(editor)) {
        insertBreak();
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "insert.break"
        },
        editor
      });
    }, editor.insertData = (dataTransfer) => {
      if (isApplyingBehaviorActions(editor))
        throw new Error("Unexpected call to .insertData(...)");
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "input.*",
          originEvent: {
            dataTransfer
          }
        },
        editor
      });
    }, editor.insertSoftBreak = () => {
      if (isApplyingBehaviorActions(editor)) {
        insertTextActionImplementation({
          context: {
            keyGenerator: editorActor.getSnapshot().context.keyGenerator,
            schema: editorActor.getSnapshot().context.schema
          },
          action: {
            text: `
`,
            editor
          }
        });
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "insert.soft break"
        },
        editor
      });
    }, editor.insertText = (text, options) => {
      if (isApplyingBehaviorActions(editor)) {
        insertText(text, options);
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "insert.text",
          text
        },
        editor
      });
    }, editor.redo = () => {
      if (isApplyingBehaviorActions(editor)) {
        performAction({
          context: {
            keyGenerator: editorActor.getSnapshot().context.keyGenerator,
            schema: editorActor.getSnapshot().context.schema
          },
          action: {
            type: "history.redo",
            editor
          }
        });
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.redo"
        },
        editor
      });
    }, editor.select = (location) => {
      if (isApplyingBehaviorActions(editor)) {
        select(location);
        return;
      }
      const range = slate.Editor.range(editor, location);
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "select",
          at: slateRangeToSelection({
            schema: editorActor.getSnapshot().context.schema,
            editor,
            range
          })
        },
        editor
      });
    }, editor.setFragmentData = () => {
      console.warn("Unexpected call to .setFragmentData(...)");
    }, editor.undo = () => {
      if (isApplyingBehaviorActions(editor)) {
        performAction({
          context: {
            keyGenerator: editorActor.getSnapshot().context.keyGenerator,
            schema: editorActor.getSnapshot().context.schema
          },
          action: {
            type: "history.undo",
            editor
          }
        });
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.undo"
        },
        editor
      });
    }, editor;
  };
}
function createWithMaxBlocks(editorActor) {
  return function(editor) {
    const {
      apply: apply2
    } = editor;
    return editor.apply = (operation) => {
      if (editorActor.getSnapshot().matches({
        "edit mode": "read only"
      })) {
        apply2(operation);
        return;
      }
      if (isChangingRemotely(editor)) {
        apply2(operation);
        return;
      }
      if (isUndoing(editor) || isRedoing(editor)) {
        apply2(operation);
        return;
      }
      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1;
      rows > 0 && editor.children.length >= rows && (operation.type === "insert_node" || operation.type === "split_node") && operation.path.length === 1 || apply2(operation);
    }, editor;
  };
}
function createWithObjectKeys(editorActor) {
  return function(editor) {
    const {
      apply: apply2,
      normalizeNode
    } = editor;
    return editor.apply = (operation) => {
      if (isChangingRemotely(editor)) {
        apply2(operation);
        return;
      }
      if (isUndoing(editor) || isRedoing(editor)) {
        apply2(operation);
        return;
      }
      if (operation.type === "split_node") {
        const existingKeys = [...slate.Node.descendants(editor)].map(([node]) => node._key);
        apply2({
          ...operation,
          properties: {
            ...operation.properties,
            _key: operation.properties._key === void 0 || existingKeys.includes(operation.properties._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.properties._key
          }
        });
        return;
      }
      if (operation.type === "insert_node" && !slate.Editor.isEditor(operation.node)) {
        const existingKeys = [...slate.Node.descendants(editor)].map(([node]) => node._key);
        apply2({
          ...operation,
          node: {
            ...operation.node,
            _key: operation.node._key === void 0 || existingKeys.includes(operation.node._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.node._key
          }
        });
        return;
      }
      apply2(operation);
    }, editor.normalizeNode = (entry) => {
      const [node, path] = entry;
      if (slate.Element.isElement(node) && node._type === editorActor.getSnapshot().context.schema.block.name) {
        if (!node._key) {
          editorActor.send({
            type: "normalizing"
          }), slate.Transforms.setNodes(editor, {
            _key: editorActor.getSnapshot().context.keyGenerator()
          }, {
            at: path
          }), editorActor.send({
            type: "done normalizing"
          });
          return;
        }
        for (const [child, childPath] of slate.Node.children(editor, path))
          if (!child._key) {
            editorActor.send({
              type: "normalizing"
            }), slate.Transforms.setNodes(editor, {
              _key: editorActor.getSnapshot().context.keyGenerator()
            }, {
              at: childPath
            }), editorActor.send({
              type: "done normalizing"
            });
            return;
          }
      }
      normalizeNode(entry);
    }, editor;
  };
}
const debug$9 = debugWithName("applyPatches"), debugVerbose = debug$9.enabled && !0;
function createApplyPatch(schema2) {
  return (editor, patch) => {
    let changed = !1;
    debugVerbose && (debug$9(`

NEW PATCH =============================================================`), debug$9(JSON.stringify(patch, null, 2)));
    try {
      switch (patch.type) {
        case "insert":
          changed = insertPatch(editor, patch, schema2);
          break;
        case "unset":
          changed = unsetPatch(editor, patch);
          break;
        case "set":
          changed = setPatch(editor, patch);
          break;
        case "diffMatchPatch":
          changed = diffMatchPatch(editor, patch);
          break;
        default:
          debug$9("Unhandled patch", patch.type);
      }
    } catch (err) {
      console.error(err);
    }
    return changed;
  };
}
function diffMatchPatch(editor, patch) {
  const {
    block,
    child,
    childPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (!block)
    return debug$9("Block not found"), !1;
  if (!child || !childPath)
    return debug$9("Child not found"), !1;
  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === "children" && patch.path[3] === "text") || !slate.Text.isText(child))
    return !1;
  const patches2 = parse(patch.value), [newValue] = apply(patches2, child.text, {
    allowExceedingIndices: !0
  }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);
  debugState(editor, "before");
  let offset = 0;
  for (const [op, text] of diff$1)
    op === DIFF_INSERT ? (editor.apply({
      type: "insert_text",
      path: childPath,
      offset,
      text
    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({
      type: "remove_text",
      path: childPath,
      offset,
      text
    }) : op === DIFF_EQUAL && (offset += text.length);
  return debugState(editor, "after"), !0;
}
function insertPatch(editor, patch, schema2) {
  const {
    block: targetBlock,
    child: targetChild,
    blockPath: targetBlockPath,
    childPath: targetChildPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (!targetBlock || !targetBlockPath)
    return debug$9("Block not found"), !1;
  if (patch.path.length > 1 && patch.path[1] !== "children")
    return debug$9("Ignoring patch targeting void value"), !1;
  if (patch.path.length === 1) {
    const {
      items: items2,
      position: position2
    } = patch, blocksToInsert = toSlateValue(items2, {
      schemaTypes: schema2
    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === "after" ? targetBlockIndex + 1 : targetBlockIndex;
    return debug$9(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, "before"), slate.Transforms.insertNodes(editor, blocksToInsert, {
      at: [normalizedIdx2]
    }), debugState(editor, "after"), !0;
  }
  const {
    items,
    position
  } = patch;
  if (!targetChild || !targetChildPath)
    return debug$9("Child not found"), !1;
  const childrenToInsert = targetBlock && toSlateValue([{
    ...targetBlock,
    children: items
  }], {
    schemaTypes: schema2
  }, KEY_TO_SLATE_ELEMENT.get(editor)), targetChildIndex = targetChildPath[1], normalizedIdx = position === "after" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];
  return debug$9(`Inserting children at path ${childInsertPath}`), debugState(editor, "before"), childrenToInsert && slate.Element.isElement(childrenToInsert[0]) && slate.Transforms.insertNodes(editor, childrenToInsert[0].children, {
    at: childInsertPath
  }), debugState(editor, "after"), !0;
}
function setPatch(editor, patch) {
  let value = patch.value;
  typeof patch.path[3] == "string" && (value = {}, value[patch.path[3]] = patch.value);
  const {
    block,
    blockPath,
    child,
    childPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (!block)
    return debug$9("Block not found"), !1;
  const isTextBlock = editor.isTextBlock(block);
  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== "children")
    return debug$9("Ignoring setting void value"), !1;
  if (debugState(editor, "before"), isTextBlock && child && childPath) {
    if (slate.Text.isText(value) && slate.Text.isText(child)) {
      const newText = child.text;
      value.text !== newText && (debug$9("Setting text property"), editor.apply({
        type: "remove_text",
        path: childPath,
        offset: 0,
        text: newText
      }), editor.apply({
        type: "insert_text",
        path: childPath,
        offset: 0,
        text: value.text
      }), editor.onChange());
    } else
      debug$9("Setting non-text property"), editor.apply({
        type: "set_node",
        path: childPath,
        properties: {},
        newProperties: value
      });
    return !0;
  } else if (slate.Element.isElement(block) && patch.path.length === 1 && blockPath) {
    debug$9("Setting block property");
    const {
      children,
      ...nextRest
    } = value, {
      children: prevChildren,
      ...prevRest
    } = block || {
      children: void 0
    };
    editor.apply({
      type: "set_node",
      path: blockPath,
      properties: {
        ...prevRest
      },
      newProperties: nextRest
    }), debug$9("Setting children"), block.children.forEach((c, cIndex) => {
      editor.apply({
        type: "remove_node",
        path: blockPath.concat(block.children.length - 1 - cIndex),
        node: c
      });
    }), Array.isArray(children) && children.forEach((c, cIndex) => {
      editor.apply({
        type: "insert_node",
        path: blockPath.concat(cIndex),
        node: c
      });
    });
  } else if (block && "value" in block)
    if (patch.path.length > 1 && patch.path[1] !== "children") {
      const newVal = patches.applyAll(block.value, [{
        ...patch,
        path: patch.path.slice(1)
      }]);
      slate.Transforms.setNodes(editor, {
        ...block,
        value: newVal
      }, {
        at: blockPath
      });
    } else
      return !1;
  return debugState(editor, "after"), !0;
}
function unsetPatch(editor, patch) {
  if (patch.path.length === 0) {
    debug$9("Removing everything"), debugState(editor, "before");
    const previousSelection = editor.selection;
    return slate.Transforms.deselect(editor), editor.children.forEach((_child, i) => {
      slate.Transforms.removeNodes(editor, {
        at: [i]
      });
    }), slate.Transforms.insertNodes(editor, editor.pteCreateTextBlock({
      decorators: []
    })), previousSelection && slate.Transforms.select(editor, {
      anchor: {
        path: [0, 0],
        offset: 0
      },
      focus: {
        path: [0, 0],
        offset: 0
      }
    }), editor.onChange(), debugState(editor, "after"), !0;
  }
  const {
    block,
    blockPath,
    child,
    childPath
  } = findBlockAndChildFromPath(editor, patch.path);
  if (patch.path.length === 1) {
    if (!block || !blockPath)
      return debug$9("Block not found"), !1;
    const blockIndex = blockPath[0];
    return debug$9(`Removing block at path [${blockIndex}]`), debugState(editor, "before"), slate.Transforms.removeNodes(editor, {
      at: [blockIndex]
    }), debugState(editor, "after"), !0;
  }
  return editor.isTextBlock(block) && patch.path[1] === "children" && patch.path.length === 3 ? !child || !childPath ? (debug$9("Child not found"), !1) : (debug$9(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, "before"), debugVerbose && debug$9(`Removing child at path ${JSON.stringify(childPath)}`), slate.Transforms.removeNodes(editor, {
    at: childPath
  }), debugState(editor, "after"), !0) : !1;
}
function isKeyedSegment(segment) {
  return typeof segment == "object" && "_key" in segment;
}
function debugState(editor, stateName) {
  debugVerbose && (debug$9(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$9(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));
}
function findBlockFromPath(editor, path) {
  let blockIndex = -1;
  const block = editor.children.find((node, index) => {
    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];
    return isMatch && (blockIndex = index), isMatch;
  });
  return block ? {
    block,
    path: [blockIndex]
  } : {};
}
function findBlockAndChildFromPath(editor, path) {
  const {
    block,
    path: blockPath
  } = findBlockFromPath(editor, path);
  if (!(slate.Element.isElement(block) && path[1] === "children"))
    return {
      block,
      blockPath,
      child: void 0,
      childPath: void 0
    };
  let childIndex = -1;
  const child = block.children.find((node, index) => {
    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];
    return isMatch && (childIndex = index), isMatch;
  });
  return child ? {
    block,
    child,
    blockPath,
    childPath: blockPath?.concat(childIndex)
  } : {
    block,
    blockPath,
    child: void 0,
    childPath: void 0
  };
}
const debug$8 = debugWithName("plugin:withPatches");
function createWithPatches({
  editorActor,
  patchFunctions,
  subscriptions
}) {
  let previousChildren;
  const applyPatch = createApplyPatch(editorActor.getSnapshot().context.schema);
  return function(editor) {
    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];
    const {
      apply: apply2
    } = editor;
    let bufferedPatches = [];
    const handleBufferedRemotePatches = () => {
      if (bufferedPatches.length === 0)
        return;
      const patches2 = bufferedPatches;
      bufferedPatches = [];
      let changed = !1;
      withRemoteChanges(editor, () => {
        slate.Editor.withoutNormalizing(editor, () => {
          withoutPatching(editor, () => {
            withoutSaving(editor, () => {
              patches2.forEach((patch) => {
                debug$8.enabled && debug$8(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch(editor, patch);
              });
            });
          });
        }), changed && (editor.normalize(), editor.onChange());
      });
    }, handlePatches = ({
      patches: patches2
    }) => {
      const remotePatches = patches2.filter((p) => p.origin !== "local");
      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());
    };
    return subscriptions.push(() => {
      debug$8("Subscribing to remote patches");
      const sub = editorActor.on("patches", handlePatches);
      return () => {
        debug$8("Unsubscribing to remote patches"), sub.unsubscribe();
      };
    }), editor.apply = (operation) => {
      let patches$1 = [];
      previousChildren = editor.children;
      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, editorActor.getSnapshot().context.schema);
      apply2(operation);
      const editorIsEmpty = isEqualToEmptyEditor(editor.children, editorActor.getSnapshot().context.schema);
      if (!isPatching(editor))
        return editor;
      switch (editorWasEmpty && !editorIsEmpty && operation.type !== "set_selection" && patches$1.push(patches.insert(previousChildren, "before", [0])), operation.type) {
        case "insert_text":
          patches$1 = [...patches$1, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];
          break;
        case "remove_text":
          patches$1 = [...patches$1, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];
          break;
        case "remove_node":
          patches$1 = [...patches$1, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];
          break;
        case "split_node":
          patches$1 = [...patches$1, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];
          break;
        case "insert_node":
          patches$1 = [...patches$1, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];
          break;
        case "set_node":
          patches$1 = [...patches$1, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];
          break;
        case "merge_node":
          patches$1 = [...patches$1, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];
          break;
        case "move_node":
          patches$1 = [...patches$1, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];
          break;
      }
      if (!editorWasEmpty && editorIsEmpty && ["merge_node", "set_node", "remove_text", "remove_node"].includes(operation.type) && (patches$1 = [...patches$1, patches.unset([])], editorActor.send({
        type: "notify.unset",
        previousValue: fromSlateValue(previousChildren, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor))
      })), editorWasEmpty && patches$1.length > 0 && (patches$1 = [patches.setIfMissing([], []), ...patches$1]), patches$1.length > 0)
        for (const patch of patches$1)
          editorActor.send({
            type: "internal.patch",
            patch: {
              ...patch,
              origin: "local"
            },
            actionId: getCurrentActionId(editor),
            value: fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor))
          });
      return editor;
    }, editor;
  };
}
const debug$7 = debugWithName("plugin:withPlaceholderBlock");
function createWithPlaceholderBlock(editorActor) {
  return function(editor) {
    const {
      apply: apply2
    } = editor;
    return editor.apply = (op) => {
      if (editorActor.getSnapshot().matches({
        "edit mode": "read only"
      })) {
        apply2(op);
        return;
      }
      if (isChangingRemotely(editor)) {
        apply2(op);
        return;
      }
      if (isUndoing(editor) || isRedoing(editor)) {
        apply2(op);
        return;
      }
      if (op.type === "remove_node") {
        const node = op.node;
        if (op.path[0] === 0 && slate.Editor.isVoid(editor, node)) {
          const nextPath = slate.Path.next(op.path);
          editor.children[nextPath[0]] || (debug$7("Adding placeholder block"), slate.Editor.insertNode(editor, editor.pteCreateTextBlock({
            decorators: []
          })));
        }
      }
      apply2(op);
    }, editor;
  };
}
const debug$6 = debugWithName("plugin:withPortableTextBlockStyle");
function createWithPortableTextBlockStyle(editorActor) {
  const defaultStyle = editorActor.getSnapshot().context.schema.styles[0].name;
  return function(editor) {
    const {
      normalizeNode
    } = editor;
    return editor.normalizeNode = (nodeEntry) => {
      const [, path] = nodeEntry;
      for (const op of editor.operations)
        if (op.type === "split_node" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate.Path.equals(path, op.path)) {
          const [child] = slate.Editor.node(editor, [op.path[0] + 1, 0]);
          if (slate.Text.isText(child) && child.text === "") {
            debug$6(`Normalizing split node to ${defaultStyle} style`, op), editorActor.send({
              type: "normalizing"
            }), slate.Transforms.setNodes(editor, {
              style: defaultStyle
            }, {
              at: [op.path[0] + 1],
              voids: !1
            }), editorActor.send({
              type: "done normalizing"
            });
            return;
          }
        }
      normalizeNode(nodeEntry);
    }, editor;
  };
}
debugWithName("plugin:withPortableTextSelections");
function createWithPortableTextSelections(editorActor) {
  let prevSelection = null;
  return function(editor) {
    const emitPortableTextSelection = () => {
      if (prevSelection !== editor.selection) {
        let ptRange = null;
        if (editor.selection) {
          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
          existing ? ptRange = existing : (ptRange = slateRangeToSelection({
            schema: editorActor.getSnapshot().context.schema,
            editor,
            range: editor.selection
          }), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange));
        }
        ptRange ? editorActor.send({
          type: "notify.selection",
          selection: ptRange
        }) : editorActor.send({
          type: "notify.selection",
          selection: null
        });
      }
      prevSelection = editor.selection;
    }, {
      onChange
    } = editor;
    return editor.onChange = () => {
      onChange(), editorActor.getSnapshot().matches({
        setup: "setting up"
      }) || emitPortableTextSelection();
    }, editor;
  };
}
const debug$5 = debugWithName("plugin:withSchemaTypes");
function createWithSchemaTypes({
  editorActor
}) {
  return function(editor) {
    editor.isTextBlock = (value) => types.isPortableTextTextBlock(value) && value._type === editorActor.getSnapshot().context.schema.block.name, editor.isTextSpan = (value) => types.isPortableTextSpan(value) && value._type === editorActor.getSnapshot().context.schema.span.name, editor.isListBlock = (value) => types.isPortableTextListBlock(value) && value._type === editorActor.getSnapshot().context.schema.block.name, editor.isVoid = (element) => editorActor.getSnapshot().context.schema.block.name !== element._type && (editorActor.getSnapshot().context.schema.blockObjects.map((obj) => obj.name).includes(element._type) || editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type) && "__inline" in element && element.__inline === !0;
    const {
      normalizeNode
    } = editor;
    return editor.normalizeNode = (entry) => {
      const [node, path] = entry;
      if (node._type === void 0 && path.length === 2) {
        debug$5("Setting span type on text node without a type");
        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();
        editorActor.send({
          type: "normalizing"
        }), slate.Transforms.setNodes(editor, {
          ...span,
          _type: editorActor.getSnapshot().context.schema.span.name,
          _key: key
        }, {
          at: path
        }), editorActor.send({
          type: "done normalizing"
        });
        return;
      }
      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {
        debug$5("Setting missing key on child node without a key");
        const key = editorActor.getSnapshot().context.keyGenerator();
        editorActor.send({
          type: "normalizing"
        }), slate.Transforms.setNodes(editor, {
          _key: key
        }, {
          at: path
        }), editorActor.send({
          type: "done normalizing"
        });
        return;
      }
      normalizeNode(entry);
    }, editor;
  };
}
function createWithUtils({
  editorActor
}) {
  return function(editor) {
    return editor.pteCreateTextBlock = (options) => toSlateValue([{
      _type: editorActor.getSnapshot().context.schema.block.name,
      _key: editorActor.getSnapshot().context.keyGenerator(),
      style: editorActor.getSnapshot().context.schema.styles[0].name || "normal",
      ...options.listItem ? {
        listItem: options.listItem
      } : {},
      ...options.level ? {
        level: options.level
      } : {},
      markDefs: [],
      children: [{
        _type: "span",
        _key: editorActor.getSnapshot().context.keyGenerator(),
        text: "",
        marks: options.decorators.filter((decorator) => editorActor.getSnapshot().context.schema.decorators.find(({
          name
        }) => name === decorator))
      }]
    }], {
      schemaTypes: editorActor.getSnapshot().context.schema
    })[0], editor;
  };
}
const withPlugins = (editor, options) => {
  const e = editor, {
    editorActor
  } = options, operationToPatches = createOperationToPatches(editorActor), withObjectKeys = createWithObjectKeys(editorActor), withSchemaTypes = createWithSchemaTypes({
    editorActor
  }), withPatches = createWithPatches({
    editorActor,
    patchFunctions: operationToPatches,
    subscriptions: options.subscriptions
  }), withMaxBlocks = createWithMaxBlocks(editorActor), withUndoRedo = createWithUndoRedo({
    editorActor,
    subscriptions: options.subscriptions
  }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor), withPortableTextBlockStyle = createWithPortableTextBlockStyle(editorActor), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({
    editorActor
  }), withPortableTextSelections = createWithPortableTextSelections(editorActor);
  return createWithEventListeners(editorActor)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(e)))))))))));
}, debug$4 = debugWithName("component:PortableTextEditor:SlateContainer"), slateEditors = /* @__PURE__ */ new WeakMap();
function createSlateEditor(config) {
  const existingSlateEditor = slateEditors.get(config.editorActor);
  if (existingSlateEditor)
    return debug$4("Reusing existing Slate editor instance", config.editorActor.id), existingSlateEditor;
  debug$4("Creating new Slate editor instance", config.editorActor.id);
  const unsubscriptions = [], subscriptions = [], instance = withPlugins(slateReact.withReact(slate.createEditor()), {
    editorActor: config.editorActor,
    subscriptions
  });
  KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {});
  for (const subscription of subscriptions)
    unsubscriptions.push(subscription());
  const initialValue = [instance.pteCreateTextBlock({
    decorators: []
  })], slateEditor = {
    instance,
    initialValue
  };
  return slateEditors.set(config.editorActor, slateEditor), slateEditor;
}
function createLegacySchema(portableTextType) {
  if (!portableTextType)
    throw new Error("Parameter 'portabletextType' missing (required)");
  const blockType = portableTextType.of?.find(findBlockType);
  if (!blockType)
    throw new Error("Block type is not defined in this schema (required)");
  const childrenField = blockType.fields?.find((field) => field.name === "children");
  if (!childrenField)
    throw new Error("Children field for block type found in schema (required)");
  const ofType = childrenField.type.of;
  if (!ofType)
    throw new Error("Valid types for block children not found in schema (required)");
  const spanType = ofType.find((memberType) => memberType.name === "span");
  if (!spanType)
    throw new Error("Span type not found in schema (required)");
  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== "span") || [], blockObjectTypes = portableTextType.of?.filter((field) => field.name !== blockType.name) || [];
  return {
    styles: resolveEnabledStyles(blockType),
    decorators: resolveEnabledDecorators(spanType),
    lists: resolveEnabledListItems(blockType),
    block: blockType,
    span: spanType,
    portableText: portableTextType,
    inlineObjects: inlineObjectTypes,
    blockObjects: blockObjectTypes,
    annotations: spanType.annotations
  };
}
function resolveEnabledStyles(blockType) {
  const styleField = blockType.fields?.find((btField) => btField.name === "style");
  if (!styleField)
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter((style) => style.value);
  if (!textStyles || textStyles.length === 0)
    throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
  return textStyles;
}
function resolveEnabledDecorators(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
  const listField = blockType.fields?.find((btField) => btField.name === "listItem");
  if (!listField)
    throw new Error("A field with name 'listItem' is not defined in the block type (required).");
  const listItems = listField.type.options?.list && listField.type.options.list.filter((list) => list.value);
  if (!listItems)
    throw new Error("The list field need at least to be an empty array");
  return listItems;
}
function findBlockType(type) {
  return type.type ? findBlockType(type.type) : type.name === "block" ? type : null;
}
function defineSchema(definition) {
  return definition;
}
const temporaryImageName = `tmp-${defaultKeyGenerator()}-image`, temporaryUrlName = `tmp-${defaultKeyGenerator()}-url`, temporaryObjectNames = {
  image: temporaryImageName,
  url: temporaryUrlName
}, objectNames = {
  [temporaryImageName]: "image",
  [temporaryUrlName]: "url"
}, defaultObjectTitles = {
  image: "Image",
  url: "URL"
};
function legacySchemaToEditorSchema(schema2) {
  return {
    annotations: schema2.annotations.map((annotation) => ({
      name: annotation.name,
      fields: annotation.fields.map((field) => ({
        name: field.name,
        type: field.type.jsonType
      })),
      title: annotation.title
    })),
    block: {
      name: schema2.block.name
    },
    blockObjects: schema2.blockObjects.map((blockObject) => ({
      name: blockObject.name,
      fields: blockObject.fields.map((field) => ({
        name: field.name,
        type: field.type.jsonType
      })),
      title: blockObject.title
    })),
    decorators: schema2.decorators.map((decorator) => ({
      name: decorator.value,
      title: decorator.title,
      value: decorator.value
    })),
    inlineObjects: schema2.inlineObjects.map((inlineObject) => ({
      name: inlineObject.name,
      fields: inlineObject.fields.map((field) => ({
        name: field.name,
        type: field.type.jsonType
      })),
      title: inlineObject.title
    })),
    span: {
      name: schema2.span.name
    },
    styles: schema2.styles.map((style) => ({
      name: style.value,
      title: style.title,
      value: style.value
    })),
    lists: schema2.lists.map((list) => ({
      name: list.value,
      title: list.title,
      value: list.value
    }))
  };
}
function compileSchemaDefinitionToLegacySchema(definition) {
  const blockObjects = definition?.blockObjects?.map((blockObject) => types.defineType({
    type: "object",
    // Very naive way to work around `SanitySchema.compile` adding default
    // fields to objects with certain names.
    name: temporaryObjectNames[blockObject.name] ?? blockObject.name,
    title: blockObject.title === void 0 ? (
      // This avoids the default title which is a title case of the object name
      defaultObjectTitles[blockObject.name]
    ) : blockObject.title,
    fields: blockObject.fields?.map((field) => ({
      name: field.name,
      type: field.type
    })) ?? []
  })) ?? [], inlineObjects = definition?.inlineObjects?.map((inlineObject) => types.defineType({
    type: "object",
    // Very naive way to work around `SanitySchema.compile` adding default
    // fields to objects with certain names.
    name: temporaryObjectNames[inlineObject.name] ?? inlineObject.name,
    title: inlineObject.title === void 0 ? (
      // This avoids the default title which is a title case of the object name
      defaultObjectTitles[inlineObject.name]
    ) : inlineObject.title,
    fields: inlineObject.fields?.map((field) => ({
      name: field.name,
      type: field.type
    })) ?? []
  })) ?? [], portableTextSchema = types.defineField({
    type: "array",
    name: "portable-text",
    of: [...blockObjects.map((blockObject) => ({
      type: blockObject.name
    })), {
      type: "block",
      name: "block",
      of: inlineObjects.map((inlineObject) => ({
        type: inlineObject.name
      })),
      marks: {
        decorators: definition?.decorators?.map((decorator) => ({
          title: decorator.title ?? startCase__default.default(decorator.name),
          value: decorator.name
        })) ?? [],
        annotations: definition?.annotations?.map((annotation) => ({
          name: annotation.name,
          type: "object",
          title: annotation.title,
          fields: annotation.fields?.map((field) => ({
            name: field.name,
            type: field.type
          })) ?? []
        })) ?? []
      },
      lists: definition?.lists?.map((list) => ({
        value: list.name,
        title: list.title ?? startCase__default.default(list.name)
      })) ?? [],
      styles: definition?.styles?.map((style) => ({
        value: style.name,
        title: style.title ?? startCase__default.default(style.name)
      })) ?? []
    }]
  }), schema$1 = schema.Schema.compile({
    types: [portableTextSchema, ...blockObjects, ...inlineObjects]
  }).get("portable-text"), pteSchema = createLegacySchema(schema$1);
  return {
    ...pteSchema,
    blockObjects: pteSchema.blockObjects.map((blockObject) => objectNames[blockObject.name] !== void 0 ? {
      ...blockObject,
      name: objectNames[blockObject.name],
      type: {
        ...blockObject.type,
        name: objectNames[blockObject.name]
      }
    } : blockObject),
    inlineObjects: pteSchema.inlineObjects.map((inlineObject) => objectNames[inlineObject.name] !== void 0 ? {
      ...inlineObject,
      name: objectNames[inlineObject.name]
    } : inlineObject)
  };
}
function slateChildrenToBlocks(schema2, value) {
  const blocks = new Array(value.length);
  for (let blockIndex = 0; blockIndex < value.length; blockIndex++) {
    const descendant = value[blockIndex];
    if (descendant._type !== schema2.block.name) {
      blocks[blockIndex] = {
        _key: descendant._key,
        _type: descendant._type,
        ..."value" in descendant && typeof descendant.value == "object" ? descendant.value : {}
      };
      continue;
    }
    const children = "children" in descendant ? descendant.children : [], processedChildren = new Array(children.length);
    for (let childIndex = 0; childIndex < children.length; childIndex++) {
      const child = children[childIndex];
      processedChildren[childIndex] = child._type === schema2.span.name ? child : {
        _key: child._key,
        _type: child._type,
        ..."value" in child && typeof child.value == "object" ? child.value : {}
      };
    }
    blocks[blockIndex] = {
      ...descendant,
      children: processedChildren
    };
  }
  return blocks;
}
function getActiveDecorators({
  schema: schema2,
  slateEditorInstance
}) {
  const decorators = schema2.decorators.map((decorator) => decorator.name);
  return ({
    ...slate.Editor.marks(slateEditorInstance) ?? {}
  }.marks ?? []).filter((mark) => decorators.includes(mark));
}
function defaultCompare(a, b) {
  return a === b;
}
function useEditorSelector(editor, selector, t0) {
  const $ = reactCompilerRuntime.c(3), compare = t0 === void 0 ? defaultCompare : t0;
  let t1;
  return $[0] !== editor || $[1] !== selector ? (t1 = (editorActorSnapshot) => {
    const snapshot = getEditorSnapshot({
      editorActorSnapshot,
      slateEditorInstance: editor._internal.slateEditor.instance
    });
    return selector(snapshot);
  }, $[0] = editor, $[1] = selector, $[2] = t1) : t1 = $[2], react.useSelector(editor._internal.editorActor, t1, compare);
}
function getEditorSnapshot({
  editorActorSnapshot,
  slateEditorInstance
}) {
  return {
    context: {
      converters: [...editorActorSnapshot.context.converters],
      activeDecorators: getActiveDecorators({
        schema: editorActorSnapshot.context.schema,
        slateEditorInstance
      }),
      keyGenerator: editorActorSnapshot.context.keyGenerator,
      readOnly: editorActorSnapshot.matches({
        "edit mode": "read only"
      }),
      schema: editorActorSnapshot.context.schema,
      selection: editorActorSnapshot.context.selection,
      value: slateChildrenToBlocks(editorActorSnapshot.context.schema, slateEditorInstance.children)
    },
    beta: {
      hasTag: (tag) => editorActorSnapshot.hasTag(tag),
      internalDrag: editorActorSnapshot.context.internalDrag
    }
  };
}
const debug$3 = debugWithName("API:editable");
function createEditableAPI(editor, editorActor) {
  const types2 = editorActor.getSnapshot().context.schema;
  return {
    focus: () => {
      editorActor.send({
        type: "focus",
        editor
      });
    },
    blur: () => {
      editorActor.send({
        type: "blur",
        editor
      });
    },
    toggleMark: (mark) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "decorator.toggle",
          decorator: mark
        },
        editor
      });
    },
    toggleList: (listItem) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "list item.toggle",
          listItem
        },
        editor
      });
    },
    toggleBlockStyle: (style) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "style.toggle",
          style
        },
        editor
      });
    },
    isMarkActive: (mark) => {
      try {
        return isDecoratorActive({
          editor,
          decorator: mark
        });
      } catch (err) {
        return console.warn(err), !1;
      }
    },
    marks: () => ({
      ...slate.Editor.marks(editor) || {}
    }).marks || [],
    undo: () => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.undo"
        },
        editor
      });
    },
    redo: () => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.redo"
        },
        editor
      });
    },
    select: (selection) => {
      const slateSelection = toSlateRange(selection, editor);
      slateSelection ? slate.Transforms.select(editor, slateSelection) : slate.Transforms.deselect(editor), editor.onChange();
    },
    focusBlock: () => {
      if (editor.selection) {
        const block = slate.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
        if (block)
          return fromSlateValue([block], types2.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
      }
    },
    focusChild: () => {
      if (editor.selection) {
        const block = slate.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));
        if (block && editor.isTextBlock(block))
          return fromSlateValue([block], types2.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];
      }
    },
    insertChild: (type, value) => {
      if (type.name !== types2.span.name)
        return editorActor.send({
          type: "behavior event",
          behaviorEvent: {
            type: "insert.inline object",
            inlineObject: {
              name: type.name,
              value
            }
          },
          editor
        }), editor.selection ? slateRangeToSelection({
          schema: editorActor.getSnapshot().context.schema,
          editor,
          range: editor.selection
        })?.focus.path ?? [] : [];
      if (!editor.selection)
        throw new Error("The editor has no selection");
      const [focusBlock] = Array.from(slate.Editor.nodes(editor, {
        at: editor.selection.focus.path.slice(0, 1),
        match: (n) => n._type === types2.block.name
      }))[0] || [void 0];
      if (!focusBlock)
        throw new Error("No focused text block");
      if (type.name !== types2.span.name && !types2.inlineObjects.some((t) => t.name === type.name))
        throw new Error("This type cannot be inserted as a child to a text block");
      const child = toSlateValue([{
        _key: editorActor.getSnapshot().context.keyGenerator(),
        _type: types2.block.name,
        children: [{
          _key: editorActor.getSnapshot().context.keyGenerator(),
          _type: type.name,
          ...value || {}
        }]
      }], {
        schemaTypes: editorActor.getSnapshot().context.schema
      })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types2.span.name, focusNode = slate.Node.get(editor, focusChildPath);
      return isSpanNode && focusNode._type !== types2.span.name && (debug$3("Inserting span child next to inline object child, moving selection + 1"), editor.move({
        distance: 1,
        unit: "character"
      })), slate.Transforms.insertNodes(editor, child, {
        select: !0,
        at: editor.selection
      }), editor.onChange(), editor.selection ? slateRangeToSelection({
        schema: editorActor.getSnapshot().context.schema,
        editor,
        range: editor.selection
      })?.focus.path ?? [] : [];
    },
    insertBlock: (type, value) => (editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "insert.block",
        block: {
          _type: type.name,
          ...value || {}
        },
        placement: "auto"
      },
      editor
    }), editor.selection ? slateRangeToSelection({
      schema: editorActor.getSnapshot().context.schema,
      editor,
      range: editor.selection
    })?.focus.path ?? [] : []),
    hasBlockStyle: (style) => {
      try {
        return isStyleActive({
          editor,
          style
        });
      } catch {
        return !1;
      }
    },
    hasListStyle: (listItem) => {
      try {
        return isListItemActive({
          editor,
          listItem
        });
      } catch {
        return !1;
      }
    },
    isVoid: (element) => ![types2.block.name, types2.span.name].includes(element._type),
    findByPath: (path) => {
      const slatePath = toSlateRange({
        focus: {
          path,
          offset: 0
        },
        anchor: {
          path,
          offset: 0
        }
      }, editor);
      if (slatePath) {
        const [block, blockPath] = slate.Editor.node(editor, slatePath.focus.path.slice(0, 1));
        if (block && blockPath && typeof block._key == "string") {
          if (path.length === 1 && slatePath.focus.path.length === 1)
            return [fromSlateValue([block], types2.block.name)[0], [{
              _key: block._key
            }]];
          const ptBlock = fromSlateValue([block], types2.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
          if (editor.isTextBlock(ptBlock)) {
            const ptChild = ptBlock.children[slatePath.focus.path[1]];
            if (ptChild)
              return [ptChild, [{
                _key: block._key
              }, "children", {
                _key: ptChild._key
              }]];
          }
        }
      }
      return [void 0, void 0];
    },
    findDOMNode: (element) => {
      let node;
      try {
        const [item] = Array.from(slate.Editor.nodes(editor, {
          at: [],
          match: (n) => n._key === element._key
        }) || [])[0] || [void 0];
        node = slateReact.ReactEditor.toDOMNode(editor, item);
      } catch {
      }
      return node;
    },
    activeAnnotations: () => {
      if (!editor.selection || editor.selection.focus.path.length < 2)
        return [];
      try {
        const activeAnnotations = [], spans = slate.Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => slate.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
        });
        for (const [span, path] of spans) {
          const [block] = slate.Editor.node(editor, path, {
            depth: 1
          });
          editor.isTextBlock(block) && block.markDefs?.forEach((def) => {
            slate.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);
          });
        }
        return activeAnnotations;
      } catch {
        return [];
      }
    },
    isAnnotationActive: (annotationType) => isAnnotationActive({
      editor,
      annotation: {
        name: annotationType
      }
    }),
    addAnnotation: (type, value) => {
      let paths;
      return slate.Editor.withoutNormalizing(editor, () => {
        paths = addAnnotationActionImplementation({
          context: {
            keyGenerator: editorActor.getSnapshot().context.keyGenerator,
            schema: types2
          },
          action: {
            annotation: {
              name: type.name,
              value: value ?? {}
            },
            editor
          }
        });
      }), editor.onChange(), paths;
    },
    delete: (selection, options) => {
      if (selection) {
        const range = toSlateRange(selection, editor);
        if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))
          throw new Error("Invalid range");
        if (range) {
          if (!options?.mode || options?.mode === "selected") {
            debug$3("Deleting content in selection"), slate.Transforms.delete(editor, {
              at: range,
              hanging: !0,
              voids: !0
            }), editor.onChange();
            return;
          }
          options?.mode === "blocks" && (debug$3("Deleting blocks touched by selection"), slate.Transforms.removeNodes(editor, {
            at: range,
            voids: !0,
            match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate.Element.isElement(node)
          })), options?.mode === "children" && (debug$3("Deleting children touched by selection"), slate.Transforms.removeNodes(editor, {
            at: range,
            voids: !0,
            match: (node) => node._type === types2.span.name || // Text children
            !editor.isTextBlock(node) && slate.Element.isElement(node)
          })), editor.children.length === 0 && (editor.children = [editor.pteCreateTextBlock({
            decorators: []
          })]), editor.onChange();
        }
      }
    },
    removeAnnotation: (type) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "annotation.remove",
          annotation: {
            name: type.name
          }
        },
        editor
      });
    },
    getSelection: () => {
      let ptRange = null;
      if (editor.selection) {
        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
        if (existing)
          return existing;
        ptRange = slateRangeToSelection({
          schema: editorActor.getSnapshot().context.schema,
          editor,
          range: editor.selection
        }), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
      }
      return ptRange;
    },
    getValue: () => fromSlateValue(editor.children, types2.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
    isCollapsedSelection: () => !!editor.selection && slate.Range.isCollapsed(editor.selection),
    isExpandedSelection: () => !!editor.selection && slate.Range.isExpanded(editor.selection),
    insertBreak: () => {
      editor.insertBreak(), editor.onChange();
    },
    getFragment: () => fromSlateValue(editor.getFragment(), types2.block.name),
    isSelectionsOverlapping: (selectionA, selectionB) => {
      const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);
      return slate.Range.isRange(rangeA) && slate.Range.isRange(rangeB) && slate.Range.includes(rangeA, rangeB);
    }
  };
}
function isAnnotationActive({
  editor,
  annotation
}) {
  if (!editor.selection || editor.selection.focus.path.length < 2)
    return !1;
  try {
    const spans = [...slate.Editor.nodes(editor, {
      at: editor.selection,
      match: (node) => slate.Text.isText(node)
    })];
    if (spans.length === 0 || spans.some(([span]) => !types.isPortableTextSpan(span) || !span.marks || span.marks?.length === 0)) return !1;
    const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {
      const [block] = slate.Editor.node(editor, path, {
        depth: 1
      });
      return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;
    }, []);
    return spans.every(([span]) => types.isPortableTextSpan(span) ? span.marks?.map((markKey) => selectionMarkDefs.find((def) => def?._key === markKey)?._type)?.includes(annotation.name) : !1);
  } catch {
    return !1;
  }
}
function compileSchemasFromEditorConfig(config) {
  const legacySchema = config.schemaDefinition ? compileSchemaDefinitionToLegacySchema(config.schemaDefinition) : createLegacySchema(config.schema.hasOwnProperty("jsonType") ? config.schema : compileType(config.schema)), schema2 = legacySchemaToEditorSchema(legacySchema);
  return {
    legacySchema,
    schema: schema2
  };
}
function editorConfigToMachineInput(config) {
  const {
    legacySchema,
    schema: schema2
  } = compileSchemasFromEditorConfig(config);
  return {
    behaviors: config.behaviors,
    converters: createCoreConverters(legacySchema),
    getLegacySchema: () => legacySchema,
    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,
    maxBlocks: config.maxBlocks,
    readOnly: config.readOnly,
    schema: schema2,
    initialValue: config.initialValue
  };
}
function createInternalEditor(editorActor) {
  const slateEditor = createSlateEditor({
    editorActor
  }), editable = createEditableAPI(slateEditor.instance, editorActor);
  return {
    getSnapshot: () => getEditorSnapshot({
      editorActorSnapshot: editorActor.getSnapshot(),
      slateEditorInstance: slateEditor.instance
    }),
    registerBehavior: (config) => (editorActor.send({
      type: "add behavior",
      behavior: config.behavior
    }), () => {
      editorActor.send({
        type: "remove behavior",
        behavior: config.behavior
      });
    }),
    send: (event) => {
      switch (event.type) {
        case "add behavior":
        case "remove behavior":
        case "update behaviors":
        case "update key generator":
        case "update readOnly":
        case "patches":
        case "update value":
        case "update schema":
        case "update maxBlocks":
          editorActor.send(event);
          break;
        case "blur":
          editorActor.send({
            type: "blur",
            editor: slateEditor.instance
          });
          break;
        case "focus":
          editorActor.send({
            type: "focus",
            editor: slateEditor.instance
          });
          break;
        case "insert.block object":
          editorActor.send({
            type: "behavior event",
            behaviorEvent: {
              type: "insert.block",
              block: {
                _type: event.blockObject.name,
                ...event.blockObject.value ?? {}
              },
              placement: event.placement
            },
            editor: slateEditor.instance
          });
          break;
        default:
          editorActor.send({
            type: "behavior event",
            behaviorEvent: event,
            editor: slateEditor.instance
          });
      }
    },
    on: (event, listener) => editorActor.on(event, (event2) => {
      switch (event2.type) {
        case "blurred":
        case "done loading":
        case "editable":
        case "error":
        case "focused":
        case "invalid value":
        case "loading":
        case "mutation":
        case "patch":
        case "read only":
        case "ready":
        case "selection":
        case "value changed":
          listener(event2);
          break;
      }
    }),
    _internal: {
      editable,
      editorActor,
      slateEditor
    }
  };
}
const EditorActorContext = React.createContext({});
function getGlobalScope() {
  if (typeof globalThis < "u") return globalThis;
  if (typeof window < "u") return window;
  if (typeof self < "u") return self;
  if (typeof global < "u") return global;
  throw new Error("@portabletext/editor: could not locate global scope");
}
const globalScope = getGlobalScope();
function createGloballyScopedContext(key, defaultValue) {
  const symbol = Symbol.for(key);
  return typeof document > "u" ? React.createContext(defaultValue) : (globalScope[symbol] = globalScope[symbol] ?? React.createContext(defaultValue), globalScope[symbol]);
}
const EditorContext = createGloballyScopedContext("@portabletext/editor/context/editor", null), abstractAnnotationBehaviors = [behavior_core.defineBehavior({
  on: "annotation.toggle",
  guard: ({
    snapshot,
    event
  }) => selector_isSelectingEntireBlocks.isActiveAnnotation(event.annotation.name)(snapshot),
  actions: [({
    event
  }) => [behavior_core.raise({
    type: "annotation.remove",
    annotation: event.annotation
  })]]
}), behavior_core.defineBehavior({
  on: "annotation.toggle",
  guard: ({
    snapshot,
    event
  }) => !selector_isSelectingEntireBlocks.isActiveAnnotation(event.annotation.name)(snapshot),
  actions: [({
    event
  }) => [behavior_core.raise({
    type: "annotation.add",
    annotation: event.annotation
  })]]
})], abstractDecoratorBehaviors = [behavior_core.defineBehavior({
  on: "decorator.toggle",
  guard: ({
    snapshot,
    event
  }) => selector_isSelectingEntireBlocks.isActiveDecorator(event.decorator)(snapshot),
  actions: [({
    event
  }) => [behavior_core.raise({
    type: "decorator.remove",
    decorator: event.decorator
  })]]
}), behavior_core.defineBehavior({
  on: "decorator.toggle",
  guard: ({
    snapshot,
    event
  }) => {
    const manualSelection = event.at ? util_selectionPointToBlockOffset.blockOffsetsToSelection({
      value: snapshot.context.value,
      offsets: event.at
    }) : null;
    return manualSelection ? !selector_isSelectingEntireBlocks.isActiveDecorator(event.decorator)({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: manualSelection
      }
    }) : !selector_isSelectingEntireBlocks.isActiveDecorator(event.decorator)(snapshot);
  },
  actions: [({
    event
  }) => [behavior_core.raise({
    ...event,
    type: "decorator.add"
  })]]
})], abstractDeleteBehaviors = [behavior_core.defineBehavior({
  on: "delete.text",
  guard: ({
    snapshot,
    event
  }) => {
    const selection = util_selectionPointToBlockOffset.blockOffsetsToSelection({
      value: snapshot.context.value,
      offsets: event.at
    });
    if (!selection)
      return !1;
    const trimmedSelection = selector_isSelectingEntireBlocks.getTrimmedSelection({
      context: {
        converters: [],
        schema: snapshot.context.schema,
        keyGenerator: snapshot.context.keyGenerator,
        activeDecorators: [],
        readOnly: !1,
        value: snapshot.context.value,
        selection
      }
    });
    return trimmedSelection ? {
      selection: trimmedSelection
    } : !1;
  },
  actions: [(_, {
    selection
  }) => [behavior_core.raise({
    type: "delete",
    at: selection
  })]]
})], abstractInsertBehaviors = [behavior_core.defineBehavior({
  on: "insert.blocks",
  guard: ({
    event
  }) => event.placement === "before",
  actions: [({
    event
  }) => event.blocks.map((block, index) => behavior_core.raise({
    type: "insert.block",
    block,
    placement: index === 0 ? "before" : "after",
    select: "end"
  }))]
}), behavior_core.defineBehavior({
  on: "insert.blocks",
  guard: ({
    event
  }) => event.placement === "after",
  actions: [({
    event
  }) => event.blocks.map((block) => behavior_core.raise({
    type: "insert.block",
    block,
    placement: "after",
    select: "end"
  }))]
}), behavior_core.defineBehavior({
  on: "insert.blocks",
  guard: ({
    snapshot,
    event
  }) => {
    if (event.placement !== "auto")
      return !1;
    const focusTextBlock = selector_isOverlappingSelection.getFocusTextBlock(snapshot);
    return focusTextBlock ? {
      focusTextBlock
    } : !1;
  },
  actions: [({
    event
  }, {
    focusTextBlock
  }) => event.blocks.length === 1 ? [behavior_core.raise({
    type: "insert.block",
    block: event.blocks[0],
    placement: "auto",
    select: "end"
  })] : util_sliceBlocks.isEmptyTextBlock(focusTextBlock.node) ? event.blocks.map((block, index) => behavior_core.raise({
    type: "insert.block",
    block,
    placement: index === 0 ? "auto" : "after",
    select: "end"
  })) : event.blocks.flatMap((block, index) => index === 0 ? [behavior_core.raise({
    type: "split"
  }), behavior_core.raise({
    type: "select.previous block",
    select: "end"
  }), behavior_core.raise({
    type: "insert.block",
    block,
    placement: "auto",
    select: "end"
  })] : index === event.blocks.length - 1 ? [behavior_core.raise({
    type: "select.next block",
    select: "start"
  }), behavior_core.raise({
    type: "insert.block",
    block,
    placement: "auto",
    select: "end"
  })] : [behavior_core.raise({
    type: "insert.block",
    block,
    placement: "after",
    select: "end"
  })])]
}), behavior_core.defineBehavior({
  on: "insert.blocks",
  guard: ({
    event
  }) => event.placement === "auto",
  actions: [({
    event
  }) => event.blocks.map((block, index) => behavior_core.raise({
    type: "insert.block",
    block,
    placement: index === 0 ? "auto" : "after",
    select: "end"
  }))]
}), behavior_core.defineBehavior({
  on: "insert.break",
  actions: [() => [behavior_core.raise({
    type: "split"
  })]]
}), behavior_core.defineBehavior({
  on: "insert.soft break",
  actions: [() => [behavior_core.raise({
    type: "insert.text",
    text: `
`
  })]]
})], abstractListItemBehaviors = [behavior_core.defineBehavior({
  on: "list item.add",
  guard: ({
    snapshot
  }) => ({
    selectedTextBlocks: selector_isSelectingEntireBlocks.getSelectedTextBlocks(snapshot)
  }),
  actions: [({
    event
  }, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => behavior_core.raise({
    type: "block.set",
    at: block.path,
    props: {
      level: 1,
      listItem: event.listItem
    }
  }))]
}), behavior_core.defineBehavior({
  on: "list item.remove",
  guard: ({
    snapshot
  }) => ({
    selectedTextBlocks: selector_isSelectingEntireBlocks.getSelectedTextBlocks(snapshot)
  }),
  actions: [(_, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => behavior_core.raise({
    type: "block.unset",
    at: block.path,
    props: ["level", "listItem"]
  }))]
}), behavior_core.defineBehavior({
  on: "list item.toggle",
  guard: ({
    snapshot,
    event
  }) => selector_isSelectingEntireBlocks.isActiveListItem(event.listItem)(snapshot),
  actions: [({
    event
  }) => [behavior_core.raise({
    type: "list item.remove",
    listItem: event.listItem
  })]]
}), behavior_core.defineBehavior({
  on: "list item.toggle",
  guard: ({
    snapshot,
    event
  }) => !selector_isSelectingEntireBlocks.isActiveListItem(event.listItem)(snapshot),
  actions: [({
    event
  }) => [behavior_core.raise({
    type: "list item.add",
    listItem: event.listItem
  })]]
})], abstractMoveBehaviors = [behavior_core.defineBehavior({
  on: "move.block up",
  guard: ({
    snapshot,
    event
  }) => {
    const previousBlock = selector_isOverlappingSelection.getPreviousBlock({
      context: {
        ...snapshot.context,
        selection: {
          anchor: {
            path: event.at,
            offset: 0
          },
          focus: {
            path: event.at,
            offset: 0
          }
        }
      }
    });
    return previousBlock ? {
      previousBlock
    } : !1;
  },
  actions: [({
    event
  }, {
    previousBlock
  }) => [behavior_core.raise({
    type: "move.block",
    at: event.at,
    to: previousBlock.path
  })]]
}), behavior_core.defineBehavior({
  on: "move.block down",
  guard: ({
    snapshot,
    event
  }) => {
    const nextBlock = selector_isOverlappingSelection.getNextBlock({
      context: {
        ...snapshot.context,
        selection: {
          anchor: {
            path: event.at,
            offset: 0
          },
          focus: {
            path: event.at,
            offset: 0
          }
        }
      }
    });
    return nextBlock ? {
      nextBlock
    } : !1;
  },
  actions: [({
    event
  }, {
    nextBlock
  }) => [behavior_core.raise({
    type: "move.block",
    at: event.at,
    to: nextBlock.path
  })]]
})], abstractSelectBehaviors = [behavior_core.defineBehavior({
  on: "select.previous block",
  guard: ({
    snapshot,
    event
  }) => {
    const previousBlock = selector_isOverlappingSelection.getPreviousBlock(snapshot);
    if (!previousBlock)
      return !1;
    const point = event.select === "end" ? util_sliceBlocks.getBlockEndPoint(previousBlock) : util_sliceBlocks.getBlockStartPoint(previousBlock);
    return {
      selection: {
        anchor: point,
        focus: point
      }
    };
  },
  actions: [(_, {
    selection
  }) => [behavior_core.raise({
    type: "select",
    at: selection
  })]]
}), behavior_core.defineBehavior({
  on: "select.next block",
  guard: ({
    snapshot,
    event
  }) => {
    const nextBlock = selector_isOverlappingSelection.getNextBlock(snapshot);
    if (!nextBlock)
      return !1;
    const point = event.select === "end" ? util_sliceBlocks.getBlockEndPoint(nextBlock) : util_sliceBlocks.getBlockStartPoint(nextBlock);
    return {
      selection: {
        anchor: point,
        focus: point
      }
    };
  },
  actions: [(_, {
    selection
  }) => [behavior_core.raise({
    type: "select",
    at: selection
  })]]
})], abstractSplitBehaviors = [behavior_core.defineBehavior({
  on: "split",
  guard: ({
    snapshot
  }) => {
    if (!snapshot.context.selection)
      return !1;
    const selectionStartPoint = util_getSelectionStartPoint.getSelectionStartPoint(snapshot.context.selection), selectionEndPoint = util_getSelectionStartPoint.getSelectionEndPoint(snapshot.context.selection), focusTextBlock = selector_isOverlappingSelection.getFocusTextBlock({
      context: {
        ...snapshot.context,
        selection: {
          anchor: selectionStartPoint,
          focus: selectionEndPoint
        }
      }
    });
    if (focusTextBlock) {
      const blockEndPoint = util_sliceBlocks.getBlockEndPoint(focusTextBlock), newTextBlockSelection = {
        anchor: selectionEndPoint,
        focus: blockEndPoint
      }, newTextBlock = parseBlocks.parseBlock({
        block: util_sliceBlocks.sliceBlocks({
          blocks: [focusTextBlock.node],
          selection: newTextBlockSelection
        }).at(0),
        context: snapshot.context,
        options: {
          refreshKeys: !0
        }
      });
      return !newTextBlock || !parseBlocks.isTextBlock(snapshot.context.schema, newTextBlock) ? !1 : {
        newTextBlock,
        newTextBlockSelection,
        selection: {
          anchor: selectionStartPoint,
          focus: blockEndPoint
        }
      };
    }
    if (selector_isOverlappingSelection.getFocusBlockObject({
      context: {
        ...snapshot.context,
        selection: {
          anchor: selectionStartPoint,
          focus: selectionEndPoint
        }
      }
    })) {
      const newTextBlock = parseBlocks.parseBlock({
        block: {
          _type: snapshot.context.schema.block.name,
          children: []
        },
        context: snapshot.context,
        options: {
          refreshKeys: !0
        }
      });
      return newTextBlock ? {
        newTextBlock,
        newTextBlockSelection: {
          anchor: selectionEndPoint,
          focus: selectionEndPoint
        },
        selection: snapshot.context.selection
      } : !1;
    }
    return !1;
  },
  actions: [(_, {
    newTextBlock,
    selection
  }) => [behavior_core.raise({
    type: "delete",
    at: selection
  }), behavior_core.raise({
    type: "insert.block",
    block: newTextBlock,
    placement: "after",
    select: "start"
  })]]
})], abstractStyleBehaviors = [behavior_core.defineBehavior({
  on: "style.add",
  guard: ({
    snapshot
  }) => ({
    selectedTextBlocks: selector_isSelectingEntireBlocks.getSelectedTextBlocks(snapshot)
  }),
  actions: [({
    event
  }, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => behavior_core.raise({
    type: "block.set",
    at: block.path,
    props: {
      style: event.style
    }
  }))]
}), behavior_core.defineBehavior({
  on: "style.remove",
  guard: ({
    snapshot
  }) => ({
    selectedTextBlocks: selector_isSelectingEntireBlocks.getSelectedTextBlocks(snapshot)
  }),
  actions: [(_, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => behavior_core.raise({
    type: "block.unset",
    at: block.path,
    props: ["style"]
  }))]
}), behavior_core.defineBehavior({
  on: "style.toggle",
  guard: ({
    snapshot,
    event
  }) => selector_isSelectingEntireBlocks.isActiveStyle(event.style)(snapshot),
  actions: [({
    event
  }) => [behavior_core.raise({
    type: "style.remove",
    style: event.style
  })]]
}), behavior_core.defineBehavior({
  on: "style.toggle",
  guard: ({
    snapshot,
    event
  }) => !selector_isSelectingEntireBlocks.isActiveStyle(event.style)(snapshot),
  actions: [({
    event
  }) => [behavior_core.raise({
    type: "style.add",
    style: event.style
  })]]
})], keyIs = {
  lineBreak: (event) => event.key === "Enter" && event.shiftKey
}, raiseInsertSoftBreak = behavior_core.defineBehavior({
  on: "keyboard.keydown",
  guard: ({
    event
  }) => keyIs.lineBreak(event.originEvent),
  actions: [() => [behavior_core.raise({
    type: "insert.soft break"
  })]]
}), raiseDeserializationSuccessOrFailure = behavior_core.defineBehavior({
  on: "deserialize",
  guard: ({
    snapshot,
    event
  }) => {
    let success;
    const failures = [];
    for (const converter of snapshot.context.converters) {
      const data = event.originEvent.originEvent.dataTransfer.getData(converter.mimeType);
      if (!data)
        continue;
      const deserializeEvent = converter.deserialize({
        snapshot,
        event: {
          type: "deserialize",
          data
        }
      });
      if (deserializeEvent.type === "deserialization.success") {
        success = deserializeEvent;
        break;
      } else
        failures.push(deserializeEvent);
    }
    return success || {
      type: "deserialization.failure",
      mimeType: "*/*",
      reason: failures.map((failure) => failure.reason).join(", ")
    };
  },
  actions: [({
    event
  }, deserializeEvent) => [behavior_core.raise({
    ...deserializeEvent,
    originEvent: event.originEvent
  })]]
}), raiseSerializationSuccessOrFailure = behavior_core.defineBehavior({
  on: "serialize",
  guard: ({
    snapshot,
    event
  }) => {
    if (snapshot.context.converters.length === 0)
      return !1;
    const serializeEvents = snapshot.context.converters.map((converter) => converter.serialize({
      snapshot,
      event: {
        ...event,
        originEvent: event.originEvent.type
      }
    }));
    return serializeEvents.length === 0 ? !1 : serializeEvents;
  },
  actions: [({
    event
  }, serializeEvents) => serializeEvents.map((serializeEvent) => behavior_core.raise({
    ...serializeEvent,
    originEvent: event.originEvent
  }))]
}), defaultBehaviors = [
  behavior_core.defineBehavior({
    on: "clipboard.copy",
    guard: ({
      snapshot
    }) => {
      const focusSpan = selector_isOverlappingSelection.getFocusSpan(snapshot), selectionCollapsed = selector_isOverlappingSelection.isSelectionCollapsed(snapshot);
      return focusSpan && selectionCollapsed;
    },
    actions: []
  }),
  behavior_core.defineBehavior({
    on: "clipboard.copy",
    actions: [({
      event
    }) => [behavior_core.raise({
      type: "serialize",
      originEvent: event
    })]]
  }),
  behavior_core.defineBehavior({
    on: "clipboard.cut",
    guard: ({
      snapshot
    }) => {
      const focusSpan = selector_isOverlappingSelection.getFocusSpan(snapshot), selectionCollapsed = selector_isOverlappingSelection.isSelectionCollapsed(snapshot);
      return focusSpan && selectionCollapsed;
    },
    actions: []
  }),
  behavior_core.defineBehavior({
    on: "clipboard.cut",
    guard: ({
      snapshot
    }) => snapshot.context.selection ? {
      selection: snapshot.context.selection
    } : !1,
    actions: [({
      event
    }, {
      selection
    }) => [behavior_core.raise({
      type: "serialize",
      originEvent: event
    }), behavior_core.raise({
      type: "delete",
      at: selection
    })]]
  }),
  behavior_core.defineBehavior({
    on: "drag.dragstart",
    actions: [({
      event
    }) => [behavior_core.raise({
      type: "serialize",
      originEvent: event
    })]]
  }),
  behavior_core.defineBehavior({
    on: "serialization.success",
    actions: [({
      event
    }) => [{
      type: "effect",
      effect: () => {
        event.originEvent.originEvent.dataTransfer.setData(event.mimeType, event.data);
      }
    }]]
  }),
  behavior_core.defineBehavior({
    on: "serialization.failure",
    actions: [({
      event
    }) => [{
      type: "effect",
      effect: () => {
        console.warn(`Serialization of ${event.mimeType} failed with reason "${event.reason}"`);
      }
    }]]
  }),
  behavior_core.defineBehavior({
    on: "drag.drop",
    guard: ({
      snapshot,
      event
    }) => {
      const dragOrigin = snapshot.beta.internalDrag?.origin, dropPosition = event.position.selection;
      return dragOrigin ? selector_isOverlappingSelection.isOverlappingSelection(dropPosition)({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragOrigin.selection
        }
      }) : !1;
    },
    actions: []
  }),
  behavior_core.defineBehavior({
    on: "drag.drop",
    actions: [({
      event
    }) => [behavior_core.raise({
      type: "select",
      at: event.position.selection
    }), behavior_core.raise({
      type: "deserialize",
      originEvent: event
    })]]
  }),
  behavior_core.defineBehavior({
    on: "deserialization.success",
    guard: ({
      snapshot,
      event
    }) => {
      if (event.originEvent.type !== "drag.drop" || snapshot.beta.internalDrag === void 0)
        return !1;
      const dragOrigin = snapshot.beta.internalDrag.origin, dropPosition = event.originEvent.position.selection, droppingOnDragOrigin = dragOrigin ? selector_isOverlappingSelection.isOverlappingSelection(dropPosition)({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragOrigin.selection
        }
      }) : !1, draggingEntireBlocks = selector_isSelectingEntireBlocks.isSelectingEntireBlocks({
        context: {
          ...snapshot.context,
          selection: dragOrigin.selection
        }
      }), draggedBlocks = selector_isOverlappingSelection.getSelectedBlocks({
        context: {
          ...snapshot.context,
          selection: dragOrigin.selection
        }
      });
      return droppingOnDragOrigin ? !1 : {
        draggingEntireBlocks,
        draggedBlocks,
        dragOrigin,
        originEvent: event.originEvent
      };
    },
    actions: [({
      event
    }, {
      draggingEntireBlocks,
      draggedBlocks,
      dragOrigin,
      originEvent
    }) => [...draggingEntireBlocks ? draggedBlocks.map((block) => behavior_core.raise({
      type: "delete.block",
      at: block.path
    })) : [behavior_core.raise({
      type: "delete",
      at: dragOrigin.selection
    })], behavior_core.raise({
      type: "insert.blocks",
      blocks: event.data,
      placement: draggingEntireBlocks ? originEvent.position.block === "start" ? "before" : originEvent.position.block === "end" ? "after" : "auto" : "auto"
    })]]
  }),
  /**
   * If we are pasting text/plain into a text block then we can probably
   * assume that the intended behavior is that the pasted text inherits
   * formatting from the text it's pasted into.
   */
  behavior_core.defineBehavior({
    on: "deserialization.success",
    guard: ({
      snapshot,
      event
    }) => {
      if (selector_isOverlappingSelection.getFocusTextBlock(snapshot) && event.mimeType === "text/plain" && event.originEvent.type === "clipboard.paste") {
        const activeDecorators = snapshot.context.activeDecorators;
        return {
          activeAnnotations: selector_isSelectingEntireBlocks.getActiveAnnotations(snapshot),
          activeDecorators,
          textRuns: event.data.flatMap((block) => parseBlocks.isTextBlock(snapshot.context.schema, block) ? [util_sliceBlocks.getTextBlockText(block)] : [])
        };
      }
      return !1;
    },
    actions: [(_, {
      activeAnnotations,
      activeDecorators,
      textRuns
    }) => textRuns.flatMap((textRun, index) => index !== textRuns.length - 1 ? [behavior_core.raise({
      type: "insert.span",
      text: textRun,
      decorators: activeDecorators,
      annotations: activeAnnotations.map(({
        _key,
        _type,
        ...value
      }) => ({
        name: _type,
        value
      }))
    }), behavior_core.raise({
      type: "insert.break"
    })] : [behavior_core.raise({
      type: "insert.span",
      text: textRun,
      decorators: activeDecorators,
      annotations: activeAnnotations.map(({
        _key,
        _type,
        ...value
      }) => ({
        name: _type,
        value
      }))
    })])]
  }),
  behavior_core.defineBehavior({
    on: "deserialization.success",
    actions: [({
      event
    }) => [behavior_core.raise({
      type: "insert.blocks",
      blocks: event.data,
      placement: "auto"
    })]]
  }),
  behavior_core.defineBehavior({
    on: "deserialization.failure",
    actions: [({
      event
    }) => [{
      type: "effect",
      effect: () => {
        console.warn(`Deserialization of ${event.mimeType} failed with reason "${event.reason}"`);
      }
    }]]
  }),
  behavior_core.defineBehavior({
    on: "clipboard.paste",
    guard: ({
      snapshot
    }) => snapshot.context.selection && selector_isOverlappingSelection.isSelectionExpanded(snapshot) ? {
      selection: snapshot.context.selection
    } : !1,
    actions: [({
      event
    }, {
      selection
    }) => [behavior_core.raise({
      type: "delete",
      at: selection
    }), behavior_core.raise({
      type: "deserialize",
      originEvent: event
    })]]
  }),
  behavior_core.defineBehavior({
    on: "clipboard.paste",
    actions: [({
      event
    }) => [behavior_core.raise({
      type: "deserialize",
      originEvent: event
    })]]
  }),
  behavior_core.defineBehavior({
    on: "input.*",
    actions: [({
      event
    }) => [behavior_core.raise({
      type: "deserialize",
      originEvent: event
    })]]
  }),
  ...abstractAnnotationBehaviors,
  ...abstractDecoratorBehaviors,
  ...abstractDeleteBehaviors,
  ...abstractInsertBehaviors,
  ...abstractListItemBehaviors,
  ...abstractMoveBehaviors,
  ...abstractStyleBehaviors,
  ...abstractSelectBehaviors,
  ...abstractSplitBehaviors,
  raiseDeserializationSuccessOrFailure,
  raiseSerializationSuccessOrFailure,
  raiseInsertSoftBreak
], abstractBehaviorEventTypes = ["annotation.toggle", "decorator.toggle", "delete.text", "deserialize", "deserialization.success", "deserialization.failure", "insert.blocks", "insert.break", "insert.soft break", "list item.add", "list item.remove", "list item.toggle", "move.block down", "move.block up", "select.previous block", "select.next block", "serialize", "serialization.success", "serialization.failure", "split", "style.add", "style.remove", "style.toggle"];
function isAbstractBehaviorEvent(event) {
  return abstractBehaviorEventTypes.includes(event.type);
}
const nativeBehaviorEventTypes = ["clipboard.copy", "clipboard.cut", "clipboard.paste", "drag.dragstart", "drag.drag", "drag.dragend", "drag.dragenter", "drag.dragover", "drag.dragleave", "drag.drop", "input.*", "keyboard.keydown", "keyboard.keyup", "mouse.click"];
function isNativeBehaviorEvent(event) {
  return nativeBehaviorEventTypes.includes(event.type);
}
function isCustomBehaviorEvent(event) {
  return event.type.startsWith("custom.");
}
const debug$2 = debugWithName("behaviors:event");
function eventCategory(event) {
  return isNativeBehaviorEvent(event) ? "native" : isAbstractBehaviorEvent(event) ? "synthetic" : isCustomBehaviorEvent(event) ? "custom" : "synthetic";
}
function performEvent({
  mode,
  behaviors,
  remainingEventBehaviors,
  event,
  editor,
  keyGenerator,
  schema: schema2,
  getSnapshot,
  nativeEvent
}) {
  debug$2(`(${mode}:${eventCategory(event)})`, JSON.stringify(event, null, 2));
  const defaultAction = isCustomBehaviorEvent(event) || isNativeBehaviorEvent(event) || isAbstractBehaviorEvent(event) ? void 0 : {
    ...event,
    editor
  }, eventBehaviors = [...remainingEventBehaviors, ...defaultBehaviors].filter((behavior) => {
    if (behavior.on === "*")
      return !0;
    const [listenedNamespace] = behavior.on.includes("*") && behavior.on.includes(".") ? behavior.on.split(".") : [void 0], [eventNamespace] = event.type.includes(".") ? event.type.split(".") : [void 0];
    return listenedNamespace !== void 0 && eventNamespace !== void 0 && listenedNamespace === eventNamespace || listenedNamespace !== void 0 && eventNamespace === void 0 && listenedNamespace === event.type ? !0 : behavior.on === event.type;
  });
  if (eventBehaviors.length === 0) {
    if (!defaultAction)
      return;
    withApplyingBehaviorActions(editor, () => {
      try {
        performAction({
          context: {
            keyGenerator,
            schema: schema2
          },
          action: defaultAction
        });
      } catch (error) {
        console.error(new Error(`Performing action "${defaultAction.type}" as a result of "${event.type}" failed due to: ${error.message}`));
      }
    }), editor.onChange();
    return;
  }
  const guardSnapshot = getSnapshot();
  let nativeEventPrevented = !1, defaultBehaviorOverwritten = !1, eventBehaviorIndex = -1;
  for (const eventBehavior of eventBehaviors) {
    eventBehaviorIndex++;
    const shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({
      snapshot: guardSnapshot,
      event
    });
    if (shouldRun) {
      defaultBehaviorOverwritten = !0;
      for (const actionSet of eventBehavior.actions) {
        const actionsSnapshot = getSnapshot(), actions = actionSet({
          snapshot: actionsSnapshot,
          event
        }, shouldRun);
        if (actions.length !== 0) {
          if (actions.some((action) => action.type === "execute")) {
            withUndoStep(editor, () => {
              for (const action of actions) {
                if (action.type === "effect") {
                  nativeEventPrevented = !0, performAction({
                    context: {
                      keyGenerator,
                      schema: schema2
                    },
                    action: {
                      ...action,
                      editor
                    }
                  });
                  continue;
                }
                if (action.type === "forward") {
                  const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);
                  performEvent({
                    mode: "forward",
                    behaviors,
                    remainingEventBehaviors: remainingEventBehaviors2,
                    event: action.event,
                    editor,
                    keyGenerator,
                    schema: schema2,
                    getSnapshot,
                    nativeEvent
                  });
                  continue;
                }
                if (action.type === "raise") {
                  nativeEventPrevented = !0, performEvent({
                    mode: "raise",
                    behaviors,
                    remainingEventBehaviors: behaviors,
                    event: action.event,
                    editor,
                    keyGenerator,
                    schema: schema2,
                    getSnapshot,
                    nativeEvent
                  });
                  continue;
                }
                if (isAbstractBehaviorEvent(action.event))
                  nativeEventPrevented = !0, performEvent({
                    mode: "execute",
                    behaviors,
                    remainingEventBehaviors: behaviors,
                    event: action.event,
                    editor,
                    keyGenerator,
                    schema: schema2,
                    getSnapshot,
                    nativeEvent: void 0
                  });
                else {
                  const internalAction = {
                    ...action.event,
                    editor
                  };
                  let actionFailed = !1;
                  if (withApplyingBehaviorActions(editor, () => {
                    try {
                      performAction({
                        context: {
                          keyGenerator,
                          schema: schema2
                        },
                        action: internalAction
                      });
                    } catch (error) {
                      console.error(new Error(`Performing action "${action.event.type}" as a result of "${event.type}" failed due to: ${error.message}`)), actionFailed = !0;
                    }
                  }), actionFailed)
                    break;
                  editor.onChange();
                }
              }
            });
            continue;
          }
          for (const action of actions) {
            if (action.type === "effect") {
              nativeEventPrevented = !0, performAction({
                context: {
                  keyGenerator,
                  schema: schema2
                },
                action: {
                  ...action,
                  editor
                }
              });
              continue;
            }
            if (action.type === "forward") {
              const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);
              performEvent({
                mode: "forward",
                behaviors,
                remainingEventBehaviors: remainingEventBehaviors2,
                event: action.event,
                editor,
                keyGenerator,
                schema: schema2,
                getSnapshot,
                nativeEvent
              });
              continue;
            }
            if (action.type === "raise") {
              nativeEventPrevented = !0, performEvent({
                mode: "raise",
                behaviors,
                remainingEventBehaviors: behaviors,
                event: action.event,
                editor,
                keyGenerator,
                schema: schema2,
                getSnapshot,
                nativeEvent
              });
              continue;
            }
            action.type === "execute" && console.error("Unexpected action type: `execute`");
          }
        }
      }
      break;
    }
  }
  !defaultBehaviorOverwritten && defaultAction ? (nativeEvent?.preventDefault(), withApplyingBehaviorActions(editor, () => {
    try {
      performAction({
        context: {
          keyGenerator,
          schema: schema2
        },
        action: defaultAction
      });
    } catch (error) {
      console.error(new Error(`Performing action "${defaultAction.type}" as a result of "${event.type}" failed due to: ${error.message}`));
    }
  }), editor.onChange()) : nativeEventPrevented && nativeEvent?.preventDefault();
}
function createEditorSnapshot({
  converters,
  editor,
  keyGenerator,
  readOnly,
  schema: schema2,
  hasTag,
  internalDrag
}) {
  const value = slateChildrenToBlocks(schema2, editor.children), selection = editor.selection ? slateRangeToSelection({
    schema: schema2,
    editor,
    range: editor.selection
  }) : null;
  return {
    context: {
      activeDecorators: getActiveDecorators({
        schema: schema2,
        slateEditorInstance: editor
      }),
      converters,
      keyGenerator,
      readOnly,
      schema: schema2,
      selection,
      value
    },
    beta: {
      hasTag,
      internalDrag
    }
  };
}
const editorMachine = xstate.setup({
  types: {
    context: {},
    events: {},
    emitted: {},
    input: {},
    tags: {}
  },
  actions: {
    "add behavior to context": xstate.assign({
      behaviors: ({
        context,
        event
      }) => (xstate.assertEvent(event, "add behavior"), /* @__PURE__ */ new Set([...context.behaviors, event.behavior]))
    }),
    "remove behavior from context": xstate.assign({
      behaviors: ({
        context,
        event
      }) => (xstate.assertEvent(event, "remove behavior"), context.behaviors.delete(event.behavior), /* @__PURE__ */ new Set([...context.behaviors]))
    }),
    "assign behaviors": xstate.assign({
      behaviors: ({
        event
      }) => (xstate.assertEvent(event, "update behaviors"), /* @__PURE__ */ new Set([...event.behaviors]))
    }),
    "assign schema": xstate.assign({
      schema: ({
        event
      }) => (xstate.assertEvent(event, "update schema"), event.schema)
    }),
    "emit patch event": xstate.enqueueActions(({
      event,
      enqueue
    }) => {
      xstate.assertEvent(event, "internal.patch"), enqueue.emit(event), enqueue.emit({
        type: "patch",
        patch: event.patch
      });
    }),
    "emit mutation event": xstate.emit(({
      event
    }) => (xstate.assertEvent(event, "mutation"), event)),
    "emit read only": xstate.emit({
      type: "read only"
    }),
    "emit editable": xstate.emit({
      type: "editable"
    }),
    "defer event": xstate.assign({
      pendingEvents: ({
        context,
        event
      }) => (xstate.assertEvent(event, ["internal.patch", "mutation"]), [...context.pendingEvents, event])
    }),
    "emit pending events": xstate.enqueueActions(({
      context,
      enqueue
    }) => {
      for (const event of context.pendingEvents)
        event.type === "internal.patch" ? (enqueue.emit(event), enqueue.emit({
          type: "patch",
          patch: event.patch
        })) : enqueue.emit(event);
    }),
    "emit ready": xstate.emit({
      type: "ready"
    }),
    "clear pending events": xstate.assign({
      pendingEvents: []
    }),
    "handle blur": ({
      event
    }) => {
      xstate.assertEvent(event, "blur");
      try {
        slateReact.ReactEditor.blur(event.editor);
      } catch (error) {
        console.error(new Error(`Failed to blur editor: ${error.message}`));
      }
    },
    "handle focus": ({
      context
    }) => {
      if (!context.slateEditor) {
        console.error("No Slate editor found to focus");
        return;
      }
      try {
        const currentSelection = context.slateEditor.selection;
        slateReact.ReactEditor.focus(context.slateEditor), currentSelection && slate.Transforms.select(context.slateEditor, currentSelection);
      } catch (error) {
        console.error(new Error(`Failed to focus editor: ${error.message}`));
      }
    },
    "handle behavior event": ({
      context,
      event,
      self: self2
    }) => {
      xstate.assertEvent(event, ["behavior event"]), performEvent({
        mode: "raise",
        behaviors: [...context.behaviors.values()],
        remainingEventBehaviors: [...context.behaviors.values()],
        event: event.behaviorEvent,
        editor: event.editor,
        keyGenerator: context.keyGenerator,
        schema: context.schema,
        getSnapshot: () => createEditorSnapshot({
          converters: [...context.converters],
          editor: event.editor,
          keyGenerator: context.keyGenerator,
          readOnly: self2.getSnapshot().matches({
            "edit mode": "read only"
          }),
          schema: context.schema,
          hasTag: (tag) => self2.getSnapshot().hasTag(tag),
          internalDrag: context.internalDrag
        }),
        nativeEvent: event.nativeEvent
      });
    }
  },
  guards: {
    "slate is busy": ({
      context
    }) => context.slateEditor ? context.slateEditor.operations.length > 0 : !1
  }
}).createMachine({
  id: "editor",
  context: ({
    input
  }) => ({
    behaviors: /* @__PURE__ */ new Set([...input.behaviors ?? behavior_core.coreBehaviors]),
    converters: new Set(input.converters ?? []),
    getLegacySchema: input.getLegacySchema,
    keyGenerator: input.keyGenerator,
    pendingEvents: [],
    schema: input.schema,
    selection: null,
    initialReadOnly: input.readOnly ?? !1,
    maxBlocks: input.maxBlocks,
    incomingValue: input.initialValue
  }),
  on: {
    "notify.blurred": {
      actions: xstate.emit(({
        event
      }) => ({
        ...event,
        type: "blurred"
      }))
    },
    "notify.done loading": {
      actions: xstate.emit({
        type: "done loading"
      })
    },
    "notify.error": {
      actions: xstate.emit(({
        event
      }) => ({
        ...event,
        type: "error"
      }))
    },
    "notify.invalid value": {
      actions: xstate.emit(({
        event
      }) => ({
        ...event,
        type: "invalid value"
      }))
    },
    "notify.focused": {
      actions: xstate.emit(({
        event
      }) => ({
        ...event,
        type: "focused"
      }))
    },
    "notify.selection": {
      actions: [xstate.assign({
        selection: ({
          event
        }) => event.selection
      }), xstate.emit(({
        event
      }) => ({
        ...event,
        type: "selection"
      }))]
    },
    "notify.unset": {
      actions: xstate.emit(({
        event
      }) => ({
        ...event,
        type: "unset"
      }))
    },
    "notify.loading": {
      actions: xstate.emit({
        type: "loading"
      })
    },
    "notify.value changed": {
      actions: xstate.emit(({
        event
      }) => ({
        ...event,
        type: "value changed"
      }))
    },
    "add behavior": {
      actions: "add behavior to context"
    },
    "remove behavior": {
      actions: "remove behavior from context"
    },
    patches: {
      actions: xstate.emit(({
        event
      }) => event)
    },
    "update behaviors": {
      actions: "assign behaviors"
    },
    "update key generator": {
      actions: xstate.assign({
        keyGenerator: ({
          event
        }) => event.keyGenerator
      })
    },
    "update schema": {
      actions: "assign schema"
    },
    "update value": {
      actions: xstate.assign({
        incomingValue: ({
          event
        }) => event.value
      })
    },
    "update maxBlocks": {
      actions: xstate.assign({
        maxBlocks: ({
          event
        }) => event.maxBlocks
      })
    }
  },
  type: "parallel",
  states: {
    "edit mode": {
      initial: "read only",
      states: {
        "read only": {
          initial: "determine initial edit mode",
          on: {
            "behavior event": {
              actions: "handle behavior event",
              guard: ({
                event
              }) => event.behaviorEvent.type === "clipboard.copy" || event.behaviorEvent.type === "mouse.click" || event.behaviorEvent.type === "serialize" || event.behaviorEvent.type === "serialization.failure" || event.behaviorEvent.type === "serialization.success" || event.behaviorEvent.type === "select"
            }
          },
          states: {
            "determine initial edit mode": {
              on: {
                "done syncing initial value": [{
                  target: "#editor.edit mode.read only.read only",
                  guard: ({
                    context
                  }) => context.initialReadOnly
                }, {
                  target: "#editor.edit mode.editable"
                }]
              }
            },
            "read only": {
              on: {
                "update readOnly": {
                  guard: ({
                    event
                  }) => !event.readOnly,
                  target: "#editor.edit mode.editable",
                  actions: ["emit editable"]
                }
              }
            }
          }
        },
        editable: {
          on: {
            "update readOnly": {
              guard: ({
                event
              }) => event.readOnly,
              target: "#editor.edit mode.read only.read only",
              actions: ["emit read only"]
            },
            "behavior event": {
              actions: "handle behavior event"
            },
            blur: {
              actions: "handle blur"
            },
            focus: {
              target: ".focusing",
              actions: [xstate.assign({
                slateEditor: ({
                  event
                }) => event.editor
              })]
            }
          },
          initial: "idle",
          states: {
            idle: {
              on: {
                dragstart: {
                  actions: [xstate.assign({
                    internalDrag: ({
                      event
                    }) => ({
                      ghost: event.ghost,
                      origin: event.origin
                    })
                  })],
                  target: "dragging internally"
                }
              }
            },
            focusing: {
              initial: "checking if busy",
              states: {
                "checking if busy": {
                  always: [{
                    guard: "slate is busy",
                    target: "busy"
                  }, {
                    target: "#editor.edit mode.editable.idle",
                    actions: ["handle focus"]
                  }]
                },
                busy: {
                  after: {
                    10: {
                      target: "checking if busy"
                    }
                  }
                }
              }
            },
            "dragging internally": {
              exit: [({
                context
              }) => {
                if (context.internalDrag?.ghost)
                  try {
                    context.internalDrag.ghost.parentNode?.removeChild(context.internalDrag.ghost);
                  } catch (error) {
                    console.error(new Error(`Removing the internal drag ghost failed due to: ${error.message}`));
                  }
              }, xstate.assign({
                internalDrag: void 0
              })],
              tags: ["dragging internally"],
              on: {
                dragend: {
                  target: "idle"
                },
                drop: {
                  target: "idle"
                }
              }
            }
          }
        }
      }
    },
    setup: {
      initial: "setting up",
      states: {
        "setting up": {
          exit: ["emit ready"],
          on: {
            "internal.patch": {
              actions: "defer event"
            },
            mutation: {
              actions: "defer event"
            },
            "done syncing initial value": {
              target: "pristine"
            }
          }
        },
        pristine: {
          initial: "idle",
          states: {
            idle: {
              on: {
                normalizing: {
                  target: "normalizing"
                },
                "internal.patch": {
                  actions: "defer event",
                  target: "#editor.setup.dirty"
                },
                mutation: {
                  actions: "defer event",
                  target: "#editor.setup.dirty"
                }
              }
            },
            normalizing: {
              on: {
                "done normalizing": {
                  target: "idle"
                },
                "internal.patch": {
                  actions: "defer event"
                },
                mutation: {
                  actions: "defer event"
                }
              }
            }
          }
        },
        dirty: {
          entry: ["emit pending events", "clear pending events"],
          on: {
            "internal.patch": {
              actions: "emit patch event"
            },
            mutation: {
              actions: "emit mutation event"
            }
          }
        }
      }
    }
  }
}), PortableTextEditorContext = React.createContext(null), usePortableTextEditor = () => {
  const editor = React.useContext(PortableTextEditorContext);
  if (!editor)
    throw new Error("The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.");
  return editor;
}, PortableTextEditorSelectionContext = React.createContext(null), usePortableTextEditorSelection = () => {
  const selection = React.useContext(PortableTextEditorSelectionContext);
  if (selection === void 0)
    throw new Error("The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.");
  return selection;
}, debug$1 = debugWithName("component:PortableTextEditor:SelectionProvider");
function PortableTextEditorSelectionProvider(props) {
  const $ = reactCompilerRuntime.c(6), [selection, setSelection] = React.useState(null);
  let t0, t1;
  $[0] !== props.editorActor ? (t0 = () => {
    debug$1("Subscribing to selection changes");
    const subscription = props.editorActor.on("selection", (event) => {
      React.startTransition(() => {
        setSelection(event.selection);
      });
    });
    return () => {
      debug$1("Unsubscribing to selection changes"), subscription.unsubscribe();
    };
  }, t1 = [props.editorActor], $[0] = props.editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), React.useEffect(t0, t1);
  let t2;
  return $[3] !== props.children || $[4] !== selection ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }), $[3] = props.children, $[4] = selection, $[5] = t2) : t2 = $[5], t2;
}
const debug = debugWithName("component:PortableTextEditor");
class PortableTextEditor extends React.Component {
  static displayName = "PortableTextEditor";
  /**
   * An observable of all the editor changes.
   */
  change$ = new rxjs.Subject();
  /**
   * A lookup table for all the relevant schema types for this portable text type.
   */
  /**
   * The editor instance
   */
  /*
   * The editor API (currently implemented with Slate).
   */
  constructor(props) {
    if (super(props), props.editor)
      this.editor = props.editor, this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.getLegacySchema();
    else {
      const legacySchema = createLegacySchema(props.schemaType.hasOwnProperty("jsonType") ? props.schemaType : compileType(props.schemaType)), schema2 = legacySchemaToEditorSchema(legacySchema), editorActor = xstate.createActor(editorMachine, {
        input: {
          converters: createCoreConverters(legacySchema),
          getLegacySchema: () => legacySchema,
          initialValue: props.value,
          keyGenerator: props.keyGenerator ?? defaultKeyGenerator,
          maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),
          readOnly: props.readOnly,
          schema: schema2
        }
      });
      editorActor.start(), this.editor = createInternalEditor(editorActor), this.schemaTypes = legacySchema;
    }
    this.editable = this.editor._internal.editable;
  }
  componentDidUpdate(prevProps) {
    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = createLegacySchema(this.props.schemaType.hasOwnProperty("jsonType") ? this.props.schemaType : compileType(this.props.schemaType)), this.editor._internal.editorActor.send({
      type: "update schema",
      schema: legacySchemaToEditorSchema(this.schemaTypes)
    })), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({
      type: "update readOnly",
      readOnly: this.props.readOnly ?? !1
    }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({
      type: "update maxBlocks",
      maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)
    }), this.props.value !== prevProps.value && this.editor._internal.editorActor.send({
      type: "update value",
      value: this.props.value
    }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));
  }
  setEditable = (editable) => {
    this.editor._internal.editable = {
      ...this.editor._internal.editable,
      ...editable
    };
  };
  render() {
    const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      legacyPatches ? /* @__PURE__ */ jsxRuntime.jsx(RoutePatchesObservableToEditorActor, { editorActor: this.editor._internal.editorActor, patches$: legacyPatches }) : null,
      /* @__PURE__ */ jsxRuntime.jsx(RouteEventsToChanges, { editorActor: this.editor._internal.editorActor, onChange: (change) => {
        this.props.editor || this.props.onChange(change), this.change$.next(change);
      } }),
      /* @__PURE__ */ jsxRuntime.jsx(Synchronizer, { editorActor: this.editor._internal.editorActor, slateEditor: this.editor._internal.slateEditor.instance }),
      /* @__PURE__ */ jsxRuntime.jsx(EditorActorContext.Provider, { value: this.editor._internal.editorActor, children: /* @__PURE__ */ jsxRuntime.jsx(slateReact.Slate, { editor: this.editor._internal.slateEditor.instance, initialValue: this.editor._internal.slateEditor.initialValue, children: /* @__PURE__ */ jsxRuntime.jsx(PortableTextEditorContext.Provider, { value: this, children: /* @__PURE__ */ jsxRuntime.jsx(PortableTextEditorSelectionProvider, { editorActor: this.editor._internal.editorActor, children: this.props.children }) }) }) })
    ] });
  }
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)
   * ```
   */
  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))
   * ```
   */
  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.add',
   *  annotation: {
   *    name: '...',
   *    value: {...},
   *  }
   * })
   * ```
   */
  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'blur',
   * })
   * ```
   */
  static blur = (editor) => {
    debug("Host blurred"), editor.editable?.blur();
  };
  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);
  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);
  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'focus',
   * })
   * ```
   */
  static focus = (editor) => {
    debug("Host requesting focus"), editor.editable?.focus();
  };
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)
   * ```
   */
  static focusBlock = (editor) => editor.editable?.focusBlock();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)
   * ```
   */
  static focusChild = (editor) => editor.editable?.focusChild();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selection = useEditorSelector(editor, selectors.getSelection)
   * ```
   */
  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const value = useEditorSelector(editor, selectors.getValue)
   * ```
   */
  static getValue = (editor) => editor.editable?.getValue();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))
   * ```
   */
  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))
   * ```
   */
  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)
   * ```
   */
  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)
   * ```
   */
  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))
   * ```
   */
  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.span',
   *  text: '...',
   *  annotations: [{name: '...', value: {...}}],
   *  decorators: ['...'],
   * })
   * editor.send({
   *  type: 'insert.inline object',
   *  inlineObject: {
   *    name: '...',
   *    value: {...},
   *  },
   * })
   * ```
   */
  static insertChild = (editor, type, value) => (debug("Host inserting child"), editor.editable?.insertChild(type, value));
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.block object',
   *  blockObject: {
   *    name: '...',
   *    value: {...},
   *  },
   *  placement: 'auto' | 'after' | 'before',
   * })
   * ```
   */
  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.break',
   * })
   * ```
   */
  static insertBreak = (editor) => editor.editable?.insertBreak();
  static isVoid = (editor, element) => editor.editable?.isVoid(element);
  static isObjectPath = (_editor, path) => {
    if (!path || !Array.isArray(path)) return !1;
    const isChildObjectEditPath = path.length > 3 && path[1] === "children";
    return path.length > 1 && path[1] !== "children" || isChildObjectEditPath;
  };
  static marks = (editor) => editor.editable?.marks();
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'select',
   *  selection: {...},
   * })
   * ```
   */
  static select = (editor, selection) => {
    debug("Host setting selection", selection), editor.editable?.select(selection);
  };
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.remove',
   *  annotation: {
   *    name: '...',
   *  },
   * })
   * ```
   */
  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'style.toggle',
   *  style: '...',
   * })
   * ```
   */
  static toggleBlockStyle = (editor, blockStyle) => (debug("Host is toggling block style"), editor.editable?.toggleBlockStyle(blockStyle));
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'list item.toggle',
   *  listItem: '...',
   * })
   * ```
   */
  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'decorator.toggle',
   *  decorator: '...',
   * })
   * ```
   */
  static toggleMark = (editor, mark) => {
    debug("Host toggling mark", mark), editor.editable?.toggleMark(mark);
  };
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selectedSlice = useEditorSelector(editor, selectors.getSelectedSlice)
   * ```
   */
  static getFragment = (editor) => editor.editable?.getFragment();
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.undo',
   * })
   * ```
   */
  static undo = (editor) => {
    debug("Host undoing"), editor.editable?.undo();
  };
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.redo',
   * })
   * ```
   */
  static redo = (editor) => {
    debug("Host redoing"), editor.editable?.redo();
  };
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))
   * ```
   */
  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);
}
function RoutePatchesObservableToEditorActor(props) {
  const $ = reactCompilerRuntime.c(4);
  let t0, t1;
  return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = () => {
    const subscription = props.patches$.subscribe((payload) => {
      props.editorActor.send({
        type: "patches",
        ...payload
      });
    });
    return () => {
      subscription.unsubscribe();
    };
  }, t1 = [props.editorActor, props.patches$], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), React.useEffect(t0, t1), null;
}
function RouteEventsToChanges(props) {
  const $ = reactCompilerRuntime.c(7);
  let t0;
  $[0] !== props ? (t0 = (change) => props.onChange(change), $[0] = props, $[1] = t0) : t0 = $[1];
  const handleChange = useEffectEvent.useEffectEvent(t0);
  let t1;
  $[2] !== handleChange || $[3] !== props.editorActor ? (t1 = () => {
    debug("Subscribing to editor changes");
    const sub = props.editorActor.on("*", (event) => {
      bb5: switch (event.type) {
        case "blurred": {
          handleChange({
            type: "blur",
            event: event.event
          });
          break bb5;
        }
        case "patch": {
          handleChange(event);
          break bb5;
        }
        case "loading": {
          handleChange({
            type: "loading",
            isLoading: !0
          });
          break bb5;
        }
        case "done loading": {
          handleChange({
            type: "loading",
            isLoading: !1
          });
          break bb5;
        }
        case "focused": {
          handleChange({
            type: "focus",
            event: event.event
          });
          break bb5;
        }
        case "value changed": {
          handleChange({
            type: "value",
            value: event.value
          });
          break bb5;
        }
        case "invalid value": {
          handleChange({
            type: "invalidValue",
            resolution: event.resolution,
            value: event.value
          });
          break bb5;
        }
        case "error": {
          handleChange({
            ...event,
            level: "warning"
          });
          break bb5;
        }
        case "mutation": {
          handleChange(event);
          break bb5;
        }
        case "ready": {
          handleChange(event);
          break bb5;
        }
        case "selection": {
          handleChange(event);
          break bb5;
        }
        case "unset":
          handleChange(event);
      }
    });
    return () => {
      debug("Unsubscribing to changes"), sub.unsubscribe();
    };
  }, $[2] = handleChange, $[3] = props.editorActor, $[4] = t1) : t1 = $[4];
  let t2;
  return $[5] !== props.editorActor ? (t2 = [props.editorActor], $[5] = props.editorActor, $[6] = t2) : t2 = $[6], React.useEffect(t1, t2), null;
}
function EditorProvider(props) {
  const editorActor = react.useActorRef(editorMachine, {
    input: editorConfigToMachineInput(props.initialConfig)
  }), internalEditor = React.useMemo(() => createInternalEditor(editorActor), [editorActor]), portableTextEditor = React.useMemo(() => new PortableTextEditor({
    editor: internalEditor
  }), [internalEditor]);
  return /* @__PURE__ */ jsxRuntime.jsxs(EditorContext.Provider, { value: internalEditor, children: [
    /* @__PURE__ */ jsxRuntime.jsx(RouteEventsToChanges, { editorActor, onChange: (change) => {
      portableTextEditor.change$.next(change);
    } }),
    /* @__PURE__ */ jsxRuntime.jsx(Synchronizer, { editorActor, slateEditor: internalEditor._internal.slateEditor.instance }),
    /* @__PURE__ */ jsxRuntime.jsx(EditorActorContext.Provider, { value: editorActor, children: /* @__PURE__ */ jsxRuntime.jsx(slateReact.Slate, { editor: internalEditor._internal.slateEditor.instance, initialValue: internalEditor._internal.slateEditor.initialValue, children: /* @__PURE__ */ jsxRuntime.jsx(PortableTextEditorContext.Provider, { value: portableTextEditor, children: /* @__PURE__ */ jsxRuntime.jsx(PortableTextEditorSelectionProvider, { editorActor, children: props.children }) }) }) })
  ] });
}
function useEditor() {
  const editor = React__default.default.useContext(EditorContext);
  if (!editor)
    throw new Error("No Editor set. Use EditorProvider to set one.");
  return editor;
}
exports.EditorActorContext = EditorActorContext;
exports.EditorProvider = EditorProvider;
exports.KEY_TO_VALUE_ELEMENT = KEY_TO_VALUE_ELEMENT;
exports.PortableTextEditor = PortableTextEditor;
exports.debugWithName = debugWithName;
exports.defaultKeyGenerator = defaultKeyGenerator;
exports.defineSchema = defineSchema;
exports.fromSlateValue = fromSlateValue;
exports.getEditorSnapshot = getEditorSnapshot;
exports.getFirstBlock = getFirstBlock;
exports.getLastBlock = getLastBlock;
exports.getNodeBlock = getNodeBlock;
exports.isEqualToEmptyEditor = isEqualToEmptyEditor;
exports.moveRangeByOperation = moveRangeByOperation;
exports.slateRangeToSelection = slateRangeToSelection;
exports.toSlateRange = toSlateRange;
exports.useEditor = useEditor;
exports.useEditorSelector = useEditorSelector;
exports.usePortableTextEditor = usePortableTextEditor;
exports.usePortableTextEditorSelection = usePortableTextEditorSelection;
//# sourceMappingURL=editor-provider.cjs.map
