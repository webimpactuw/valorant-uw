{"version":3,"file":"util.selection-point-to-block-offset.cjs","sources":["../../src/utils/util.block-offset-to-block-selection-point.ts","../../src/utils/util.block-offset-to-selection-point.ts","../../src/utils/util.block-offsets-to-selection.ts","../../src/utils/util.child-selection-point-to-block-offset.ts","../../src/utils/util.selection-point-to-block-offset.ts"],"sourcesContent":["import type {PortableTextBlock} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function blockOffsetToBlockSelectionPoint({\n  value,\n  blockOffset,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n}): EditorSelectionPoint | undefined {\n  let selectionPoint: EditorSelectionPoint | undefined\n\n  for (const block of value) {\n    if (block._key === blockOffset.path[0]._key) {\n      selectionPoint = {\n        path: [{_key: block._key}],\n        offset: blockOffset.offset,\n      }\n      break\n    }\n  }\n\n  return selectionPoint\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {blockOffsetToSpanSelectionPoint} from './util.block-offset'\nimport {blockOffsetToBlockSelectionPoint} from './util.block-offset-to-block-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetToSelectionPoint({\n  value,\n  blockOffset,\n  direction,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}): EditorSelectionPoint | undefined {\n  const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value,\n    blockOffset,\n    direction,\n  })\n\n  if (!spanSelectionPoint) {\n    return blockOffsetToBlockSelectionPoint({\n      value,\n      blockOffset,\n    })\n  }\n\n  return spanSelectionPoint\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelection} from '..'\nimport type {BlockOffset} from '../types/block-offset'\nimport {blockOffsetToSelectionPoint} from './util.block-offset-to-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetsToSelection({\n  value,\n  offsets,\n  backward,\n}: {\n  value: Array<PortableTextBlock>\n  offsets: {anchor: BlockOffset; focus: BlockOffset}\n  backward?: boolean\n}): EditorSelection {\n  const anchor = blockOffsetToSelectionPoint({\n    value,\n    blockOffset: offsets.anchor,\n    direction: backward ? 'backward' : 'forward',\n  })\n  const focus = blockOffsetToSelectionPoint({\n    value,\n    blockOffset: offsets.focus,\n    direction: backward ? 'forward' : 'backward',\n  })\n\n  if (!anchor || !focus) {\n    return null\n  }\n\n  return {\n    anchor,\n    focus,\n    backward,\n  }\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function childSelectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const childKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !childKey) {\n    return undefined\n  }\n\n  for (const block of value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (child._key === childKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      if (isPortableTextSpan(child)) {\n        offset += child.text.length\n      }\n    }\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {childSelectionPointToBlockOffset} from './util.child-selection-point-to-block-offset'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function selectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  if (\n    selectionPoint.path.length === 1 &&\n    isKeyedSegment(selectionPoint.path[0])\n  ) {\n    return {\n      path: [{_key: selectionPoint.path[0]._key}],\n      offset: selectionPoint.offset,\n    }\n  }\n\n  return childSelectionPointToBlockOffset({\n    value,\n    selectionPoint,\n  })\n}\n"],"names":["blockOffsetToBlockSelectionPoint","value","blockOffset","selectionPoint","block","_key","path","offset","blockOffsetToSelectionPoint","direction","blockOffsetToSpanSelectionPoint","blockOffsetsToSelection","offsets","backward","anchor","focus","childSelectionPointToBlockOffset","blockKey","isKeyedSegment","undefined","childKey","isPortableTextTextBlock","child","children","isPortableTextSpan","text","length","selectionPointToBlockOffset"],"mappings":";;AAOO,SAASA,iCAAiC;AAAA,EAC/CC;AAAAA,EACAC;AAIF,GAAqC;AAC/BC,MAAAA;AAEJ,aAAWC,SAASH;AAClB,QAAIG,MAAMC,SAASH,YAAYI,KAAK,CAAC,EAAED,MAAM;AAC1B,uBAAA;AAAA,QACfC,MAAM,CAAC;AAAA,UAACD,MAAMD,MAAMC;AAAAA,QAAAA,CAAK;AAAA,QACzBE,QAAQL,YAAYK;AAAAA,MACtB;AACA;AAAA,IAAA;AAIGJ,SAAAA;AACT;AClBO,SAASK,4BAA4B;AAAA,EAC1CP;AAAAA,EACAC;AAAAA,EACAO;AAKF,GAAqC;AAOnC,SAN2BC,iBAAAA,gCAAgC;AAAA,IACzDT;AAAAA,IACAC;AAAAA,IACAO;AAAAA,EAAAA,CACD,KAGQT,iCAAiC;AAAA,IACtCC;AAAAA,IACAC;AAAAA,EAAAA,CACD;AAIL;ACxBO,SAASS,wBAAwB;AAAA,EACtCV;AAAAA,EACAW;AAAAA,EACAC;AAKF,GAAoB;AAClB,QAAMC,SAASN,4BAA4B;AAAA,IACzCP;AAAAA,IACAC,aAAaU,QAAQE;AAAAA,IACrBL,WAAWI,WAAW,aAAa;AAAA,EAAA,CACpC,GACKE,QAAQP,4BAA4B;AAAA,IACxCP;AAAAA,IACAC,aAAaU,QAAQG;AAAAA,IACrBN,WAAWI,WAAW,YAAY;AAAA,EAAA,CACnC;AAED,SAAI,CAACC,UAAU,CAACC,QACP,OAGF;AAAA,IACLD;AAAAA,IACAC;AAAAA,IACAF;AAAAA,EACF;AACF;ACzBO,SAASG,iCAAiC;AAAA,EAC/Cf;AAAAA,EACAE;AAIF,GAA4B;AAC1B,MAAII,SAAS;AAEPU,QAAAA,WAAWC,iBAAAA,eAAef,eAAeG,KAAK,CAAC,CAAC,IAClDH,eAAeG,KAAK,CAAC,EAAED,OACvBc,QACEC,WAAWF,iBAAAA,eAAef,eAAeG,KAAK,CAAC,CAAC,IAClDH,eAAeG,KAAK,CAAC,EAAED,OACvBc;AAEA,MAAA,EAAA,CAACF,YAAY,CAACG;AAIlB,eAAWhB,SAASH;AAClB,UAAIG,MAAMC,SAASY,YAIdI,MAAAA,wBAAwBjB,KAAK;AAIvBkB,mBAAAA,SAASlB,MAAMmB,UAAU;AAClC,cAAID,MAAMjB,SAASe;AACV,mBAAA;AAAA,cACLd,MAAM,CAAC;AAAA,gBAACD,MAAMD,MAAMC;AAAAA,cAAAA,CAAK;AAAA,cACzBE,QAAQA,SAASJ,eAAeI;AAAAA,YAClC;AAGEiB,gBAAmBF,mBAAAA,KAAK,MAC1Bf,UAAUe,MAAMG,KAAKC;AAAAA,QAAAA;AAAAA;AAI7B;AC7CO,SAASC,4BAA4B;AAAA,EAC1C1B;AAAAA,EACAE;AAIF,GAA4B;AAExBA,SAAAA,eAAeG,KAAKoB,WAAW,KAC/BR,gCAAef,eAAeG,KAAK,CAAC,CAAC,IAE9B;AAAA,IACLA,MAAM,CAAC;AAAA,MAACD,MAAMF,eAAeG,KAAK,CAAC,EAAED;AAAAA,IAAAA,CAAK;AAAA,IAC1CE,QAAQJ,eAAeI;AAAAA,MAIpBS,iCAAiC;AAAA,IACtCf;AAAAA,IACAE;AAAAA,EAAAA,CACD;AACH;;;;;;"}