{"version":3,"file":"util.slice-blocks.cjs","sources":["../../src/utils/util.is-keyed-segment.ts","../../src/utils/util.block-offset.ts","../../src/utils/util.get-block-end-point.ts","../../src/utils/util.get-block-start-point.ts","../../src/utils/util.get-text-block-text.ts","../../src/utils/util.is-empty-text-block.ts","../../src/utils/util.is-equal-selection-points.ts","../../src/utils/util.is-span.ts","../../src/utils/util.reverse-selection.ts","../../src/utils/util.slice-blocks.ts"],"sourcesContent":["import type {KeyedSegment} from '@sanity/types'\n\n/**\n * @public\n */\nexport function isKeyedSegment(segment: unknown): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  value,\n  blockOffset,\n  direction,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint:\n    | {path: [KeyedSegment, 'children', KeyedSegment]; offset: number}\n    | undefined\n  let skippedInlineObject = false\n\n  for (const block of value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (direction === 'forward') {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (offsetLeft <= child.text.length) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: offsetLeft,\n          }\n          break\n        }\n\n        offsetLeft -= child.text.length\n\n        continue\n      }\n\n      if (!isPortableTextSpan(child)) {\n        skippedInlineObject = true\n        continue\n      }\n\n      if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n        if (skippedInlineObject) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: 0,\n          }\n        }\n        break\n      }\n\n      if (offsetLeft > child.text.length) {\n        offsetLeft -= child.text.length\n        continue\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n\n        offsetLeft -= child.text.length\n\n        if (offsetLeft !== 0) {\n          break\n        }\n      }\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const spanKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isPortableTextSpan(child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getBlockEndPoint({\n  node,\n  path,\n}: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelectionPoint {\n  if (isPortableTextTextBlock(node)) {\n    const lastChild = node.children[node.children.length - 1]\n\n    if (lastChild) {\n      return {\n        path: [...path, 'children', {_key: lastChild._key}],\n        offset: isPortableTextSpan(lastChild) ? lastChild.text.length : 0,\n      }\n    }\n  }\n\n  return {\n    path,\n    offset: 0,\n  }\n}\n","import {\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getBlockStartPoint({\n  node,\n  path,\n}: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelectionPoint {\n  if (isPortableTextTextBlock(node)) {\n    return {\n      path: [...path, 'children', {_key: node.children[0]._key}],\n      offset: 0,\n    }\n  }\n\n  return {\n    path,\n    offset: 0,\n  }\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\n\n/**\n * @public\n */\nexport function getTextBlockText(block: PortableTextTextBlock) {\n  return block.children.map((child) => child.text ?? '').join('')\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport {getTextBlockText} from './util.get-text-block-text'\n\n/**\n * @public\n */\nexport function isEmptyTextBlock(block: PortableTextBlock) {\n  if (!isPortableTextTextBlock(block)) {\n    return false\n  }\n\n  const onlyText = block.children.every(isPortableTextSpan)\n  const blockText = getTextBlockText(block)\n\n  return onlyText && blockText === ''\n}\n","import type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function isEqualSelectionPoints(\n  a: EditorSelectionPoint,\n  b: EditorSelectionPoint,\n) {\n  return (\n    a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path)\n  )\n}\n","import type {PortableTextChild, PortableTextSpan} from '@sanity/types'\nimport type {EditorContext} from '..'\n\n/**\n * @public\n */\nexport function isSpan(\n  context: Pick<EditorContext, 'schema'>,\n  child: PortableTextChild,\n): child is PortableTextSpan {\n  return child._type === context.schema.span.name\n}\n","import type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport function reverseSelection<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n>(selection: TEditorSelection): TEditorSelection {\n  if (!selection) {\n    return selection\n  }\n\n  if (selection.backward) {\n    return {\n      anchor: selection.focus,\n      focus: selection.anchor,\n      backward: false,\n    } as TEditorSelection\n  }\n\n  return {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: true,\n  } as TEditorSelection\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {EditorSelection} from '..'\n\n/**\n * @public\n */\nexport function sliceBlocks({\n  blocks,\n  selection,\n}: {\n  blocks: Array<PortableTextBlock>\n  selection: EditorSelection\n}): Array<PortableTextBlock> {\n  const slice: Array<PortableTextBlock> = []\n\n  if (!selection) {\n    return slice\n  }\n\n  let startBlock: PortableTextBlock | undefined\n  const middleBlocks: PortableTextBlock[] = []\n  let endBlock: PortableTextBlock | undefined\n\n  const startPoint = selection.backward ? selection.focus : selection.anchor\n  const endPoint = selection.backward ? selection.anchor : selection.focus\n\n  const startBlockKey = isKeySegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeySegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n  const startChildKey = isKeySegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endChildKey = isKeySegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return slice\n  }\n\n  for (const block of blocks) {\n    if (!isPortableTextTextBlock(block)) {\n      if (block._key === startBlockKey && block._key === endBlockKey) {\n        startBlock = block\n        break\n      }\n    }\n\n    if (block._key === startBlockKey) {\n      if (!isPortableTextTextBlock(block)) {\n        startBlock = block\n        continue\n      }\n\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if (isPortableTextSpan(child)) {\n              const text =\n                child._key === endChildKey\n                  ? child.text.slice(startPoint.offset, endPoint.offset)\n                  : child.text.slice(startPoint.offset)\n\n              startBlock = {\n                ...block,\n                children: [\n                  {\n                    ...child,\n                    text,\n                  },\n                ],\n              }\n            } else {\n              startBlock = {\n                ...block,\n                children: [child],\n              }\n            }\n\n            if (startChildKey === endChildKey) {\n              break\n            }\n            continue\n          }\n\n          if (startBlock && isPortableTextTextBlock(startBlock)) {\n            if (\n              endChildKey &&\n              child._key === endChildKey &&\n              isPortableTextSpan(child)\n            ) {\n              startBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n            } else {\n              startBlock.children.push(child)\n            }\n\n            if (\n              block._key === endBlockKey &&\n              endChildKey &&\n              child._key === endChildKey\n            ) {\n              break\n            }\n          }\n        }\n\n        if (startBlockKey === endBlockKey) {\n          break\n        }\n\n        continue\n      }\n\n      startBlock = block\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n    }\n\n    if (block._key === endBlockKey) {\n      if (!isPortableTextTextBlock(block)) {\n        endBlock = block\n        break\n      }\n\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: [],\n        }\n\n        for (const child of block.children) {\n          if (endBlock && isPortableTextTextBlock(endBlock)) {\n            if (child._key === endChildKey && isPortableTextSpan(child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n\n              break\n            }\n\n            endBlock.children.push(child)\n\n            if (endChildKey && child._key === endChildKey) {\n              break\n            }\n          }\n        }\n\n        break\n      }\n\n      endBlock = block\n\n      break\n    }\n\n    if (startBlock) {\n      middleBlocks.push(block)\n    }\n  }\n\n  return [\n    ...(startBlock ? [startBlock] : []),\n    ...middleBlocks,\n    ...(endBlock ? [endBlock] : []),\n  ]\n}\n"],"names":["isKeyedSegment","segment","blockOffsetToSpanSelectionPoint","value","blockOffset","direction","offsetLeft","offset","selectionPoint","skippedInlineObject","block","_key","path","isPortableTextTextBlock","child","children","isPortableTextSpan","text","length","spanSelectionPointToBlockOffset","blockKey","undefined","spanKey","getBlockEndPoint","node","lastChild","getBlockStartPoint","getTextBlockText","map","join","isEmptyTextBlock","onlyText","every","blockText","isEqualSelectionPoints","a","b","JSON","stringify","isSpan","context","_type","schema","span","name","reverseSelection","selection","backward","anchor","focus","sliceBlocks","blocks","slice","startBlock","middleBlocks","endBlock","startPoint","endPoint","startBlockKey","isKeySegment","endBlockKey","startChildKey","endChildKey","push"],"mappings":"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"}