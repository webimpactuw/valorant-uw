"use strict";
function isTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function parseBlocks({
  context,
  blocks,
  options
}) {
  return Array.isArray(blocks) ? blocks.flatMap((block) => {
    const parsedBlock = parseBlock({
      context,
      block,
      options
    });
    return parsedBlock ? [parsedBlock] : [];
  }) : [];
}
function parseBlock({
  context,
  block,
  options
}) {
  return parseTextBlock({
    block,
    context,
    options
  }) ?? parseBlockObject({
    blockObject: block,
    context,
    options
  });
}
function parseBlockObject({
  blockObject,
  context,
  options
}) {
  if (!isTypedObject(blockObject))
    return;
  const schemaType = context.schema.blockObjects.find(({
    name
  }) => name === blockObject._type);
  if (schemaType)
    return parseObject({
      object: blockObject,
      context: {
        keyGenerator: context.keyGenerator,
        schemaType
      },
      options
    });
}
function isTextBlock(schema, block) {
  return parseTextBlock({
    block,
    context: {
      schema,
      keyGenerator: () => ""
    },
    options: {
      refreshKeys: !1
    }
  }) !== void 0;
}
function parseTextBlock({
  block,
  context,
  options
}) {
  if (!isTypedObject(block) || block._type !== context.schema.block.name)
    return;
  const _key = options.refreshKeys ? context.keyGenerator() : typeof block._key == "string" ? block._key : context.keyGenerator(), unparsedMarkDefs = Array.isArray(block.markDefs) ? block.markDefs : [], markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = unparsedMarkDefs.flatMap((markDef) => {
    if (!isTypedObject(markDef))
      return [];
    const schemaType = context.schema.annotations.find(({
      name
    }) => name === markDef._type);
    if (!schemaType)
      return [];
    if (typeof markDef._key != "string")
      return [];
    const parsedAnnotation = parseObject({
      object: markDef,
      context: {
        schemaType,
        keyGenerator: context.keyGenerator
      },
      options
    });
    return parsedAnnotation ? (markDefKeyMap.set(markDef._key, parsedAnnotation._key), [parsedAnnotation]) : [];
  }), children = (Array.isArray(block.children) ? block.children : []).map((child) => parseSpan({
    span: child,
    context,
    markDefKeyMap,
    options
  }) ?? parseInlineObject({
    inlineObject: child,
    context,
    options
  })).filter((child) => child !== void 0), parsedBlock = {
    _type: context.schema.block.name,
    _key,
    children: children.length > 0 ? children : [{
      _key: context.keyGenerator(),
      _type: context.schema.span.name,
      text: "",
      marks: []
    }],
    markDefs
  };
  if (typeof block.style == "string" && context.schema.styles.find((style) => style.name === block.style))
    parsedBlock.style = block.style;
  else {
    const defaultStyle = context.schema.styles.at(0)?.name;
    defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : console.error("Expected default style");
  }
  return typeof block.listItem == "string" && context.schema.lists.find((list) => list.name === block.listItem) && (parsedBlock.listItem = block.listItem), typeof block.level == "number" && (parsedBlock.level = block.level), parsedBlock;
}
function parseSpan({
  span,
  context,
  markDefKeyMap,
  options
}) {
  if (!isTypedObject(span) || span._type !== context.schema.span.name || span._type !== "span")
    return;
  const marks = (Array.isArray(span.marks) ? span.marks : []).flatMap((mark) => {
    if (typeof mark != "string")
      return [];
    const markDefKey = markDefKeyMap.get(mark);
    return markDefKey !== void 0 ? [markDefKey] : context.schema.decorators.some((decorator) => decorator.name === mark) ? [mark] : [];
  });
  return {
    _type: "span",
    _key: options.refreshKeys ? context.keyGenerator() : typeof span._key == "string" ? span._key : context.keyGenerator(),
    text: typeof span.text == "string" ? span.text : "",
    marks
  };
}
function parseInlineObject({
  inlineObject,
  context,
  options
}) {
  if (!isTypedObject(inlineObject))
    return;
  const schemaType = context.schema.inlineObjects.find(({
    name
  }) => name === inlineObject._type);
  if (schemaType)
    return parseObject({
      object: inlineObject,
      context: {
        keyGenerator: context.keyGenerator,
        schemaType
      },
      options
    });
}
function parseAnnotation({
  annotation,
  context,
  options
}) {
  if (!isTypedObject(annotation))
    return;
  const schemaType = context.schema.annotations.find(({
    name
  }) => name === annotation._type);
  if (schemaType)
    return parseObject({
      object: annotation,
      context: {
        keyGenerator: context.keyGenerator,
        schemaType
      },
      options
    });
}
function parseObject({
  object,
  context,
  options
}) {
  const values = context.schemaType.fields.reduce((fieldValues, field) => {
    const fieldValue = object[field.name];
    return fieldValue !== void 0 && (fieldValues[field.name] = fieldValue), fieldValues;
  }, {});
  return {
    _type: context.schemaType.name,
    _key: options.refreshKeys ? context.keyGenerator() : typeof object._key == "string" ? object._key : context.keyGenerator(),
    ...values
  };
}
exports.isTextBlock = isTextBlock;
exports.isTypedObject = isTypedObject;
exports.parseAnnotation = parseAnnotation;
exports.parseBlock = parseBlock;
exports.parseBlocks = parseBlocks;
exports.parseInlineObject = parseInlineObject;
//# sourceMappingURL=parse-blocks.cjs.map
