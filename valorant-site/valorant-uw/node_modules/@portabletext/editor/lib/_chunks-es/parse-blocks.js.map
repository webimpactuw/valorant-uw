{"version":3,"file":"parse-blocks.js","sources":["../../src/internal-utils/asserters.ts","../../src/internal-utils/parse-blocks.ts"],"sourcesContent":["import type {TypedObject} from '@sanity/types'\n\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n","import type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n  TypedObject,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isTypedObject} from './asserters'\n\nexport function parseBlocks({\n  context,\n  blocks,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  blocks: unknown\n  options: {\n    refreshKeys: boolean\n  }\n}): Array<PortableTextBlock> {\n  if (!Array.isArray(blocks)) {\n    return []\n  }\n\n  return blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({context, block, options})\n\n    return parsedBlock ? [parsedBlock] : []\n  })\n}\n\nexport function parseBlock({\n  context,\n  block,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  block: unknown\n  options: {\n    refreshKeys: boolean\n  }\n}): PortableTextBlock | undefined {\n  return (\n    parseTextBlock({block, context, options}) ??\n    parseBlockObject({blockObject: block, context, options})\n  )\n}\n\nfunction parseBlockObject({\n  blockObject,\n  context,\n  options,\n}: {\n  blockObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(blockObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.blockObjects.find(\n    ({name}) => name === blockObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: blockObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function isTextBlock(\n  schema: EditorSchema,\n  block: unknown,\n): block is PortableTextTextBlock {\n  return (\n    parseTextBlock({\n      block,\n      context: {schema, keyGenerator: () => ''},\n      options: {refreshKeys: false},\n    }) !== undefined\n  )\n}\n\nfunction parseTextBlock({\n  block,\n  context,\n  options,\n}: {\n  block: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextTextBlock | undefined {\n  if (!isTypedObject(block)) {\n    return undefined\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return undefined\n  }\n\n  const _key = options.refreshKeys\n    ? context.keyGenerator()\n    : typeof block._key === 'string'\n      ? block._key\n      : context.keyGenerator()\n\n  const unparsedMarkDefs: Array<unknown> = Array.isArray(block.markDefs)\n    ? block.markDefs\n    : []\n  const markDefKeyMap = new Map<string, string>()\n  const markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef)) {\n      return []\n    }\n\n    const schemaType = context.schema.annotations.find(\n      ({name}) => name === markDef._type,\n    )\n\n    if (!schemaType) {\n      return []\n    }\n\n    if (typeof markDef._key !== 'string') {\n      // If the `markDef` doesn't have a `_key` then we don't know what spans\n      // it belongs to and therefore we have to discard it.\n      return []\n    }\n\n    const parsedAnnotation = parseObject({\n      object: markDef,\n      context: {\n        schemaType,\n        keyGenerator: context.keyGenerator,\n      },\n      options,\n    })\n\n    if (!parsedAnnotation) {\n      return []\n    }\n\n    markDefKeyMap.set(markDef._key, parsedAnnotation._key)\n\n    return [parsedAnnotation]\n  })\n\n  const unparsedChildren: Array<unknown> = Array.isArray(block.children)\n    ? block.children\n    : []\n\n  const children = unparsedChildren\n    .map(\n      (child) =>\n        parseSpan({span: child, context, markDefKeyMap, options}) ??\n        parseInlineObject({inlineObject: child, context, options}),\n    )\n    .filter((child) => child !== undefined)\n\n  const parsedBlock: PortableTextTextBlock = {\n    _type: context.schema.block.name,\n    _key,\n    children:\n      children.length > 0\n        ? children\n        : [\n            {\n              _key: context.keyGenerator(),\n              _type: context.schema.span.name,\n              text: '',\n              marks: [],\n            },\n          ],\n    markDefs,\n  }\n\n  if (\n    typeof block.style === 'string' &&\n    context.schema.styles.find((style) => style.name === block.style)\n  ) {\n    parsedBlock.style = block.style\n  } else {\n    const defaultStyle = context.schema.styles.at(0)?.name\n\n    if (defaultStyle !== undefined) {\n      parsedBlock.style = defaultStyle\n    } else {\n      console.error('Expected default style')\n    }\n  }\n\n  if (\n    typeof block.listItem === 'string' &&\n    context.schema.lists.find((list) => list.name === block.listItem)\n  ) {\n    parsedBlock.listItem = block.listItem\n  }\n\n  if (typeof block.level === 'number') {\n    parsedBlock.level = block.level\n  }\n\n  return parsedBlock\n}\n\nexport function isSpan(\n  schema: EditorSchema,\n  child: PortableTextSpan | PortableTextObject,\n): child is PortableTextSpan {\n  return (\n    parseSpan({\n      span: child,\n      markDefKeyMap: new Map(),\n      context: {schema, keyGenerator: () => ''},\n      options: {refreshKeys: false},\n    }) !== undefined\n  )\n}\n\nexport function parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  span: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {refreshKeys: boolean}\n}): PortableTextSpan | undefined {\n  if (!isTypedObject(span)) {\n    return undefined\n  }\n\n  // In reality, the span schema name is always 'span', but we only the check here anyway\n  if (span._type !== context.schema.span.name || span._type !== 'span') {\n    return undefined\n  }\n\n  const unparsedMarks: Array<unknown> = Array.isArray(span.marks)\n    ? span.marks\n    : []\n  const marks = unparsedMarks.flatMap((mark) => {\n    if (typeof mark !== 'string') {\n      return []\n    }\n\n    const markDefKey = markDefKeyMap.get(mark)\n\n    if (markDefKey !== undefined) {\n      return [markDefKey]\n    }\n\n    if (\n      context.schema.decorators.some((decorator) => decorator.name === mark)\n    ) {\n      return [mark]\n    }\n\n    return []\n  })\n\n  return {\n    _type: 'span',\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof span._key === 'string'\n        ? span._key\n        : context.keyGenerator(),\n    text: typeof span.text === 'string' ? span.text : '',\n    marks,\n  }\n}\n\nexport function parseInlineObject({\n  inlineObject,\n  context,\n  options,\n}: {\n  inlineObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(inlineObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.inlineObjects.find(\n    ({name}) => name === inlineObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: inlineObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function parseAnnotation({\n  annotation,\n  context,\n  options,\n}: {\n  annotation: TypedObject\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(annotation)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.annotations.find(\n    ({name}) => name === annotation._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: annotation,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nfunction parseObject({\n  object,\n  context,\n  options,\n}: {\n  object: TypedObject\n  context: Pick<EditorContext, 'keyGenerator'> & {\n    schemaType: EditorSchema['blockObjects'][0]\n  }\n  options: {refreshKeys: boolean}\n}): PortableTextObject {\n  // Validates all props on the object and only takes those that match\n  // the name of a field\n  const values = context.schemaType.fields.reduce<Record<string, unknown>>(\n    (fieldValues, field) => {\n      const fieldValue = object[field.name]\n\n      if (fieldValue !== undefined) {\n        fieldValues[field.name] = fieldValue\n      }\n\n      return fieldValues\n    },\n    {},\n  )\n\n  return {\n    _type: context.schemaType.name,\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof object._key === 'string'\n        ? object._key\n        : context.keyGenerator(),\n    ...values,\n  }\n}\n"],"names":["isTypedObject","object","isRecord","_type","value","parseBlocks","context","blocks","options","Array","isArray","flatMap","block","parsedBlock","parseBlock","parseTextBlock","parseBlockObject","blockObject","schemaType","schema","blockObjects","find","name","parseObject","keyGenerator","isTextBlock","refreshKeys","undefined","_key","unparsedMarkDefs","markDefs","markDefKeyMap","Map","markDef","annotations","parsedAnnotation","set","children","map","child","parseSpan","span","parseInlineObject","inlineObject","filter","length","text","marks","style","styles","defaultStyle","at","console","error","listItem","lists","list","level","mark","markDefKey","get","decorators","some","decorator","inlineObjects","parseAnnotation","annotation","values","fields","reduce","fieldValues","field","fieldValue"],"mappings":"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"}