{"version":3,"file":"behavior.markdown.js","sources":["../../src/behaviors/behavior.markdown.ts"],"sourcesContent":["import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport * as selectors from '../selectors'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getTextBlockText} from '../utils/util.get-text-block-text'\nimport {execute} from './behavior.types.action'\nimport {defineBehavior} from './behavior.types.behavior'\n\n/**\n * @beta\n */\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: (context: {\n    schema: EditorSchema\n  }) => {name: string; value?: {[prop: string]: unknown}} | undefined\n  defaultStyle?: (context: {schema: EditorSchema}) => string | undefined\n  headingStyle?: (context: {\n    schema: EditorSchema\n    level: number\n  }) => string | undefined\n  blockquoteStyle?: (context: {schema: EditorSchema}) => string | undefined\n  unorderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n  orderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n}\n\n/**\n * @beta\n * Create markdown behaviors for common markdown actions such as converting ### to headings, --- to HRs, and more.\n *\n * @example\n * Configure the bundled markdown behaviors\n * ```ts\n * import {EditorProvider} from '@portabletext/editor'\n * import {createMarkdownBehaviors, coreBehaviors} from '@portabletext/editor/behaviors'\n *\n * function App() {\n *  return (\n *   <EditorProvider\n *    initialConfig={{\n *    behaviors: [\n *    ...coreBehaviors,\n *    ...createMarkdownBehaviors({\n *        horizontalRuleObject: ({schema}) => {\n *          const name = schema.blockObjects.find(\n *            (object) => object.name === 'break',\n *          )?.name\n *          return name ? {name} : undefined\n *        },\n *        defaultStyle: ({schema}) => schema.styles[0].value,\n *        headingStyle: ({schema, level}) =>\n *          schema.styles.find((style) => style.value === `h${level}`)\n *            ?.value,\n *        blockquoteStyle: ({schema}) =>\n *          schema.styles.find((style) => style.value === 'blockquote')\n *            ?.value,\n *        unorderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'bullet')?.value,\n *        orderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'number')?.value,\n *      }),\n *      ]\n *    }}\n *    >\n *    {...}\n *    </EditorProvider>\n *  )\n * }\n * ```\n *\n */\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticBlockquoteOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: snapshot.context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (previousInlineObject || !blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const caretAtTheEndOfQuote = blockOffset.offset === 1\n      const looksLikeMarkdownQuote = /^>/.test(blockText)\n      const blockquoteStyle = config.blockquoteStyle?.(snapshot.context)\n\n      if (\n        caretAtTheEndOfQuote &&\n        looksLikeMarkdownQuote &&\n        blockquoteStyle !== undefined\n      ) {\n        return {focusTextBlock, style: blockquoteStyle}\n      }\n\n      return false\n    },\n    actions: [\n      () => [\n        execute({\n          type: 'insert.text',\n          text: ' ',\n        }),\n      ],\n      (_, {focusTextBlock, style}) => [\n        execute({\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        }),\n        execute({\n          type: 'block.set',\n          props: {style},\n          at: focusTextBlock.path,\n        }),\n        execute({\n          type: 'delete.text',\n          at: {\n            anchor: {\n              path: focusTextBlock.path,\n              offset: 0,\n            },\n            focus: {\n              path: focusTextBlock.path,\n              offset: 2,\n            },\n          },\n        }),\n      ],\n    ],\n  })\n  const automaticHr = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const hrCharacter =\n        event.text === '-'\n          ? '-'\n          : event.text === '*'\n            ? '*'\n            : event.text === '_'\n              ? '_'\n              : undefined\n\n      if (hrCharacter === undefined) {\n        return false\n      }\n\n      const hrObject = config.horizontalRuleObject?.(snapshot.context)\n      const focusBlock = selectors.getFocusTextBlock(snapshot)\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n      if (!hrObject || !focusBlock || !selectionCollapsed) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const textBefore = selectors.getBlockTextBefore(snapshot)\n      const hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0,\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3,\n        },\n      }\n\n      if (\n        !previousInlineObject &&\n        textBefore === `${hrCharacter}${hrCharacter}`\n      ) {\n        return {hrObject, focusBlock, hrCharacter, hrBlockOffsets}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {hrCharacter}) => [\n        execute({\n          type: 'insert.text',\n          text: hrCharacter,\n        }),\n      ],\n      (_, {hrObject, hrBlockOffsets}) => [\n        execute({\n          type: 'insert.block',\n          placement: 'before',\n          block: {\n            _type: hrObject.name,\n            ...(hrObject.value ?? {}),\n          },\n        }),\n        execute({\n          type: 'delete.text',\n          at: hrBlockOffsets,\n        }),\n      ],\n    ],\n  })\n  const automaticHrOnPaste = defineBehavior({\n    on: 'clipboard.paste',\n    guard: ({snapshot, event}) => {\n      const text = event.originEvent.dataTransfer.getData('text/plain')\n      const hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.(snapshot.context)\n      const focusBlock = selectors.getFocusBlock(snapshot)\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        execute({\n          type: 'insert.text',\n          text: hrCharacters,\n        }),\n      ],\n      ({snapshot}, {hrObject, focusBlock}) =>\n        isPortableTextTextBlock(focusBlock.node)\n          ? [\n              execute({\n                type: 'insert.block',\n                block: {\n                  _type: snapshot.context.schema.block.name,\n                  children: focusBlock.node.children,\n                },\n                placement: 'after',\n              }),\n              execute({\n                type: 'insert.block',\n                block: {\n                  _type: hrObject.name,\n                  ...(hrObject.value ?? {}),\n                },\n                placement: 'after',\n              }),\n              execute({\n                type: 'delete.block',\n                at: focusBlock.path,\n              }),\n            ]\n          : [\n              execute({\n                type: 'insert.block',\n                block: {\n                  _type: hrObject.name,\n                  ...(hrObject.value ?? {}),\n                },\n                placement: 'after',\n              }),\n            ],\n    ],\n  })\n  const automaticHeadingOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: snapshot.context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const markdownHeadingSearch = /^#+/.exec(blockText)\n      const level = markdownHeadingSearch\n        ? markdownHeadingSearch[0].length\n        : undefined\n      const caretAtTheEndOfHeading = blockOffset.offset === level\n\n      if (previousInlineObject || !caretAtTheEndOfHeading) {\n        return false\n      }\n\n      const style =\n        level !== undefined\n          ? config.headingStyle?.({schema: snapshot.context.schema, level})\n          : undefined\n\n      if (level !== undefined && style !== undefined) {\n        return {\n          focusTextBlock,\n          style: style,\n          level,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [execute(event)],\n      (_, {focusTextBlock, style, level}) => [\n        execute({\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        }),\n        execute({\n          type: 'block.set',\n          props: {style},\n          at: focusTextBlock.path,\n        }),\n        execute({\n          type: 'delete.text',\n          at: {\n            anchor: {\n              path: focusTextBlock.path,\n              offset: 0,\n            },\n            focus: {\n              path: focusTextBlock.path,\n              offset: level + 1,\n            },\n          },\n        }),\n      ],\n    ],\n  })\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({snapshot}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        snapshot.context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.(snapshot.context)\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        execute({\n          type: 'block.set',\n          props: {style: defaultStyle},\n          at: focusTextBlock.path,\n        }),\n      ],\n    ],\n  })\n  const automaticListOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: snapshot.context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (previousInlineObject || !blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const defaultStyle = config.defaultStyle?.(snapshot.context)\n      const looksLikeUnorderedList = /^(-|\\*)/.test(blockText)\n      const unorderedListStyle = config.unorderedListStyle?.(snapshot.context)\n      const caretAtTheEndOfUnorderedList = blockOffset.offset === 1\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfUnorderedList &&\n        looksLikeUnorderedList &&\n        unorderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle,\n        }\n      }\n\n      const looksLikeOrderedList = /^1\\./.test(blockText)\n      const orderedListStyle = config.orderedListStyle?.(snapshot.context)\n      const caretAtTheEndOfOrderedList = blockOffset.offset === 2\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfOrderedList &&\n        looksLikeOrderedList &&\n        orderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: orderedListStyle,\n          listItemLength: 2,\n          style: defaultStyle,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [execute(event)],\n      (_, {focusTextBlock, style, listItem, listItemLength}) => [\n        execute({\n          type: 'block.set',\n          props: {\n            listItem,\n            level: 1,\n            style,\n          },\n          at: focusTextBlock.path,\n        }),\n        execute({\n          type: 'delete.text',\n          at: {\n            anchor: {\n              path: focusTextBlock.path,\n              offset: 0,\n            },\n            focus: {\n              path: focusTextBlock.path,\n              offset: listItemLength + 1,\n            },\n          },\n        }),\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [\n    automaticBlockquoteOnSpace,\n    automaticHeadingOnSpace,\n    automaticHr,\n    automaticHrOnPaste,\n    clearStyleOnBackspace,\n    automaticListOnSpace,\n  ]\n\n  return markdownBehaviors\n}\n"],"names":["createMarkdownBehaviors","config","automaticBlockquoteOnSpace","defineBehavior","on","guard","snapshot","event","text","selectionCollapsed","selectors","focusTextBlock","focusSpan","previousInlineObject","blockOffset","spanSelectionPointToBlockOffset","value","context","selectionPoint","path","_key","node","offset","selection","focus","blockText","getTextBlockText","caretAtTheEndOfQuote","looksLikeMarkdownQuote","test","blockquoteStyle","undefined","style","actions","execute","type","_","props","at","anchor","automaticHr","hrCharacter","hrObject","horizontalRuleObject","focusBlock","textBefore","hrBlockOffsets","placement","block","_type","name","automaticHrOnPaste","originEvent","dataTransfer","getData","hrRegExp","hrCharacters","match","isPortableTextTextBlock","schema","children","automaticHeadingOnSpace","markdownHeadingSearch","exec","level","length","caretAtTheEndOfHeading","headingStyle","clearStyleOnBackspace","atTheBeginningOfBLock","defaultStyle","automaticListOnSpace","looksLikeUnorderedList","unorderedListStyle","caretAtTheEndOfUnorderedList","listItem","listItemLength","looksLikeOrderedList","orderedListStyle","caretAtTheEndOfOrderedList"],"mappings":"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"}