{"version":3,"file":"selector.is-selecting-entire-blocks.js","sources":["../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-selected-text-blocks.ts","../../src/selectors/selector.get-trimmed-selection.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-selecting-entire-blocks.ts"],"sourcesContent":["import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextSpan,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }> = []\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlockKey = isKeySegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeySegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startSpanKey = isKeySegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endSpanKey = isKeySegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  let startBlockFound = false\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (startBlockFound) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import {isPortableTextTextBlock, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusSpan, getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const selectedSpans = getSelectedSpans(snapshot)\n  const focusSpan = getFocusSpan(snapshot)\n\n  if (selectedSpans.length === 0 || !focusSpan) {\n    return []\n  }\n\n  if (selectedSpans.length === 1 && isSelectionCollapsed(snapshot)) {\n    if (snapshot.context.selection.focus.offset === 0) {\n      return []\n    }\n    if (\n      snapshot.context.selection.focus.offset === focusSpan.node.text.length\n    ) {\n      return []\n    }\n  }\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isPortableTextTextBlock(block.node) ? (block.node.markDefs ?? []) : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    selectedSpans.some((span) => span.node.marks?.includes(markDef._key)),\n  )\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(snapshot.context)\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(snapshot.context)\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import type {KeyedSegment, PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {isKeyedSegment} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: [KeyedSegment]}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: [KeyedSegment]\n  }> = []\n  const startKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = snapshot.context.selection.backward\n    ? isKeyedSegment(snapshot.context.selection.anchor.path[0])\n      ? snapshot.context.selection.anchor.path[0]._key\n      : undefined\n    : isKeyedSegment(snapshot.context.selection.focus.path[0])\n      ? snapshot.context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedTextBlocks\n  }\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startKey) {\n      if (isTextBlock(snapshot.context.schema, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      if (isTextBlock(snapshot.context.schema, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context.schema, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextSpan,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {isEmptyTextBlock, isKeyedSegment} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getTrimmedSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return snapshot.context.selection\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot)\n  const endPoint = getSelectionEndPoint(snapshot)\n\n  if (!startPoint || !endPoint) {\n    return snapshot.context.selection\n  }\n\n  const startBlockKey = isKeyedSegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : null\n  const startChildKey = isKeyedSegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : null\n  const endBlockKey = isKeyedSegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : null\n  const endChildKey = isKeyedSegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : null\n\n  if (!startBlockKey || !endBlockKey) {\n    return snapshot.context.selection\n  }\n\n  let startBlockFound = false\n  let adjustedStartPoint: EditorSelectionPoint | undefined\n  let trimStartPoint = false\n  let adjustedEndPoint: EditorSelectionPoint | undefined\n  let trimEndPoint = false\n  let previousPotentialEndpoint:\n    | {blockKey: string; span: PortableTextSpan}\n    | undefined\n\n  for (const block of snapshot.context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n\n      if (isPortableTextTextBlock(block) && isEmptyTextBlock(block)) {\n        continue\n      }\n    }\n\n    if (!startBlockFound) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    if (block._key === endBlockKey && isEmptyTextBlock(block)) {\n      break\n    }\n\n    for (const child of block.children) {\n      if (child._key === endChildKey) {\n        if (!isPortableTextSpan(child) || endPoint.offset === 0) {\n          adjustedEndPoint = previousPotentialEndpoint\n            ? {\n                path: [\n                  {_key: previousPotentialEndpoint.blockKey},\n                  'children',\n                  {_key: previousPotentialEndpoint.span._key},\n                ],\n                offset: previousPotentialEndpoint.span.text.length,\n              }\n            : undefined\n\n          trimEndPoint = true\n          break\n        }\n      }\n\n      if (trimStartPoint) {\n        const lonelySpan =\n          isPortableTextSpan(child) && block.children.length === 1\n\n        if (\n          (isPortableTextSpan(child) && child.text.length > 0) ||\n          lonelySpan\n        ) {\n          adjustedStartPoint = {\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n            offset: 0,\n          }\n          previousPotentialEndpoint = {blockKey: block._key, span: child}\n          trimStartPoint = false\n        }\n\n        continue\n      }\n\n      if (child._key === startChildKey) {\n        if (!isPortableTextSpan(child)) {\n          trimStartPoint = true\n          continue\n        }\n\n        if (startPoint.offset === child.text.length) {\n          trimStartPoint = true\n          previousPotentialEndpoint =\n            child.text.length > 0\n              ? {blockKey: block._key, span: child}\n              : previousPotentialEndpoint\n          continue\n        }\n      }\n\n      previousPotentialEndpoint =\n        isPortableTextSpan(child) && child.text.length > 0\n          ? {blockKey: block._key, span: child}\n          : previousPotentialEndpoint\n    }\n\n    if (block._key === endBlockKey) {\n      break\n    }\n  }\n\n  const trimmedSelection = snapshot.context.selection.backward\n    ? {\n        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n        focus: adjustedStartPoint ?? startPoint,\n        backward: true,\n      }\n    : {\n        anchor: adjustedStartPoint ?? startPoint,\n        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n      }\n\n  if (\n    isSelectionCollapsed({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n  ) {\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n\n    if (focusTextBlock && !isEmptyTextBlock(focusTextBlock.node)) {\n      return null\n    }\n  }\n\n  return trimmedSelection\n}\n","import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusSpan, getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const focusSpan = getFocusSpan(snapshot)\n\n    const selectedSpans = isSelectionExpanded(snapshot)\n      ? getSelectedSpans(snapshot)\n      : focusSpan\n        ? [focusSpan]\n        : []\n\n    if (selectedSpans.length === 0) {\n      return false\n    }\n\n    if (\n      selectedSpans.some(\n        (span) => !span.node.marks || span.node.marks?.length === 0,\n      )\n    ) {\n      return false\n    }\n\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isPortableTextTextBlock(block.node) ? (block.node.markDefs ?? []) : [],\n    )\n\n    return selectedSpans.every((span) => {\n      const spanMarkDefs =\n        span.node.marks?.flatMap((mark) => {\n          const markDef = selectionMarkDefs.find(\n            (markDef) => markDef._key === mark,\n          )\n\n          return markDef ? [markDef._type] : []\n        }) ?? []\n\n      return spanMarkDefs.includes(annotation)\n    })\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    return snapshot.context.activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {getSelectionEndBlock, getSelectionStartBlock} from './selectors'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = utils.getBlockStartPoint(startBlock)\n  const endBlockEndPoint = utils.getBlockEndPoint(endBlock)\n\n  return (\n    utils.isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    utils.isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n"],"names":["getSelectedSpans","snapshot","context","selection","selectedSpans","startPoint","backward","focus","anchor","endPoint","startBlockKey","isKeySegment","path","_key","undefined","endBlockKey","startSpanKey","endSpanKey","startBlockFound","block","value","isPortableTextTextBlock","child","children","isPortableTextSpan","offset","text","length","push","node","getActiveAnnotations","selectedBlocks","getSelectedBlocks","focusSpan","getFocusSpan","isSelectionCollapsed","flatMap","markDefs","filter","markDef","some","span","marks","includes","getActiveListItem","guards","createGuards","selectedTextBlocks","map","isTextBlock","firstTextBlock","at","firstListItem","listItem","every","getActiveStyle","firstStyle","style","getSelectedTextBlocks","startKey","isKeyedSegment","endKey","schema","getTrimmedSelection","getSelectionStartPoint","getSelectionEndPoint","startChildKey","endChildKey","adjustedStartPoint","trimStartPoint","adjustedEndPoint","trimEndPoint","previousPotentialEndpoint","isEmptyTextBlock","blockKey","lonelySpan","trimmedSelection","focusTextBlock","getFocusTextBlock","isActiveAnnotation","annotation","isSelectionExpanded","selectionMarkDefs","mark","find","_type","isActiveDecorator","decorator","activeDecorators","isActiveListItem","isActiveStyle","isSelectingEntireBlocks","startBlock","getSelectionStartBlock","endBlock","getSelectionEndBlock","startBlockStartPoint","utils","endBlockEndPoint"],"mappings":"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"}