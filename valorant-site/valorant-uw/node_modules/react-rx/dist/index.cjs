"use client";
"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var reactCompilerRuntime = require("react-compiler-runtime"), react = require("react"), rxjs = require("rxjs"), operators = require("rxjs/operators"), observableCallback = require("observable-callback"), useEffectEvent = require("use-effect-event");
function getValue(value) {
  return typeof value == "function" ? value() : value;
}
const cache = /* @__PURE__ */ new WeakMap();
function useObservable(observable, initialValue) {
  const $ = reactCompilerRuntime.c(9);
  let t0;
  if (!cache.has(observable)) {
    const state = {
      didEmit: !1
    }, entry = {
      state,
      observable: observable.pipe(operators.map(_temp$1), rxjs.catchError(_temp2), operators.tap((t12) => {
        const {
          snapshot,
          error: error_0
        } = t12;
        state.didEmit = !0, state.snapshot = snapshot, state.error = error_0;
      }), operators.map(_temp3), rxjs.finalize(() => cache.delete(observable)), rxjs.share({
        resetOnRefCountZero: _temp4
      })),
      getSnapshot: (initialValue_0) => {
        if (state.error)
          throw state.error;
        return state.didEmit ? state.snapshot : getValue(initialValue_0);
      }
    };
    entry.observable.subscribe().unsubscribe(), cache.set(observable, entry);
  }
  let t1;
  $[0] !== observable ? (t1 = cache.get(observable), $[0] = observable, $[1] = t1) : t1 = $[1], t0 = t1;
  const instance = t0;
  let t2;
  $[2] !== instance.observable ? (t2 = (onStoreChange) => {
    const subscription_0 = instance.observable.subscribe(onStoreChange);
    return () => {
      subscription_0.unsubscribe();
    };
  }, $[2] = instance.observable, $[3] = t2) : t2 = $[3];
  const subscribe = t2;
  let t3;
  $[4] !== initialValue || $[5] !== instance ? (t3 = () => instance.getSnapshot(initialValue), $[4] = initialValue, $[5] = instance, $[6] = t3) : t3 = $[6];
  let t4;
  return $[7] !== initialValue ? (t4 = typeof initialValue > "u" ? void 0 : () => getValue(initialValue), $[7] = initialValue, $[8] = t4) : t4 = $[8], react.useSyncExternalStore(subscribe, t3, t4);
}
function _temp4() {
  return rxjs.timer(0, rxjs.asapScheduler);
}
function _temp3(value_0) {
}
function _temp2(error) {
  return rxjs.of({
    snapshot: void 0,
    error
  });
}
function _temp$1(value) {
  return {
    snapshot: value,
    error: void 0
  };
}
function useObservableEvent(handleEvent) {
  const $ = reactCompilerRuntime.c(7), [t0] = react.useState(_temp), [calls$, call] = t0;
  let t1;
  $[0] !== handleEvent ? (t1 = (observable) => handleEvent(observable), $[0] = handleEvent, $[1] = t1) : t1 = $[1];
  const onEvent = useEffectEvent.useEffectEvent(t1);
  let t2;
  $[2] !== calls$ || $[3] !== onEvent ? (t2 = () => {
    const subscription = calls$.pipe((observable_0) => onEvent(observable_0)).subscribe();
    return () => subscription.unsubscribe();
  }, $[2] = calls$, $[3] = onEvent, $[4] = t2) : t2 = $[4];
  let t3;
  return $[5] !== calls$ ? (t3 = [calls$], $[5] = calls$, $[6] = t3) : t3 = $[6], react.useEffect(t2, t3), call;
}
function _temp() {
  return observableCallback.observableCallback();
}
exports.useObservable = useObservable;
exports.useObservableEvent = useObservableEvent;
//# sourceMappingURL=index.cjs.map
