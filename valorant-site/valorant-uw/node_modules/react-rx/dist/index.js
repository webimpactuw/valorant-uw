"use client";
import { c } from "react-compiler-runtime";
import { useSyncExternalStore, useState, useEffect } from "react";
import { catchError, finalize, share, timer, asapScheduler, of } from "rxjs";
import { map, tap } from "rxjs/operators";
import { observableCallback } from "observable-callback";
import { useEffectEvent } from "use-effect-event";
function getValue(value) {
  return typeof value == "function" ? value() : value;
}
const cache = /* @__PURE__ */ new WeakMap();
function useObservable(observable, initialValue) {
  const $ = c(9);
  let t0;
  if (!cache.has(observable)) {
    const state = {
      didEmit: !1
    }, entry = {
      state,
      observable: observable.pipe(map(_temp$1), catchError(_temp2), tap((t12) => {
        const {
          snapshot,
          error: error_0
        } = t12;
        state.didEmit = !0, state.snapshot = snapshot, state.error = error_0;
      }), map(_temp3), finalize(() => cache.delete(observable)), share({
        resetOnRefCountZero: _temp4
      })),
      getSnapshot: (initialValue_0) => {
        if (state.error)
          throw state.error;
        return state.didEmit ? state.snapshot : getValue(initialValue_0);
      }
    };
    entry.observable.subscribe().unsubscribe(), cache.set(observable, entry);
  }
  let t1;
  $[0] !== observable ? (t1 = cache.get(observable), $[0] = observable, $[1] = t1) : t1 = $[1], t0 = t1;
  const instance = t0;
  let t2;
  $[2] !== instance.observable ? (t2 = (onStoreChange) => {
    const subscription_0 = instance.observable.subscribe(onStoreChange);
    return () => {
      subscription_0.unsubscribe();
    };
  }, $[2] = instance.observable, $[3] = t2) : t2 = $[3];
  const subscribe = t2;
  let t3;
  $[4] !== initialValue || $[5] !== instance ? (t3 = () => instance.getSnapshot(initialValue), $[4] = initialValue, $[5] = instance, $[6] = t3) : t3 = $[6];
  let t4;
  return $[7] !== initialValue ? (t4 = typeof initialValue > "u" ? void 0 : () => getValue(initialValue), $[7] = initialValue, $[8] = t4) : t4 = $[8], useSyncExternalStore(subscribe, t3, t4);
}
function _temp4() {
  return timer(0, asapScheduler);
}
function _temp3(value_0) {
}
function _temp2(error) {
  return of({
    snapshot: void 0,
    error
  });
}
function _temp$1(value) {
  return {
    snapshot: value,
    error: void 0
  };
}
function useObservableEvent(handleEvent) {
  const $ = c(7), [t0] = useState(_temp), [calls$, call] = t0;
  let t1;
  $[0] !== handleEvent ? (t1 = (observable) => handleEvent(observable), $[0] = handleEvent, $[1] = t1) : t1 = $[1];
  const onEvent = useEffectEvent(t1);
  let t2;
  $[2] !== calls$ || $[3] !== onEvent ? (t2 = () => {
    const subscription = calls$.pipe((observable_0) => onEvent(observable_0)).subscribe();
    return () => subscription.unsubscribe();
  }, $[2] = calls$, $[3] = onEvent, $[4] = t2) : t2 = $[4];
  let t3;
  return $[5] !== calls$ ? (t3 = [calls$], $[5] = calls$, $[6] = t3) : t3 = $[6], useEffect(t2, t3), call;
}
function _temp() {
  return observableCallback();
}
export {
  useObservable,
  useObservableEvent
};
//# sourceMappingURL=index.js.map
