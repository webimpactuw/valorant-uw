import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { createRequire } from 'node:module';
import { dirname, extname, join } from 'node:path';
import { cwd } from 'node:process';
import { BlueprintParserErrorType } from '../../utils/types.js';
import { blueprintParserValidator } from '../../utils/vendor/parser-validator.js';
import { getStack as getStackById } from './stacks.js';
const SUPPORTED_FILE_NAMES_IN_PRIORITY_ORDER = [
    'blueprint.json',
    'blueprint.js',
    'blueprint.mjs',
    'blueprint.cjs',
    'blueprint.ts',
];
export const DEFAULT_BLUEPRINT_CONTENT = {
    blueprintVersion: '2024-10-01',
    resources: [],
};
/**
 * Finds the blueprint file in the given path or current working directory
 * @param blueprintFilePath - The full path of the blueprint file
 * @returns The path, file name, and extension of the blueprint file
 */
export function findBlueprintFile(blueprintFilePath) {
    if (blueprintFilePath) {
        if (existsSync(blueprintFilePath)) {
            return {
                path: blueprintFilePath,
                fileName: blueprintFilePath,
                extension: extname(blueprintFilePath),
            };
        }
        throw Error(`Blueprint file not found: ${blueprintFilePath}`);
    }
    for (const fileName of SUPPORTED_FILE_NAMES_IN_PRIORITY_ORDER) {
        const filePath = join(cwd(), fileName);
        if (existsSync(filePath)) {
            return { path: filePath, fileName, extension: extname(filePath) };
        }
    }
    return null;
}
export async function readBlueprintOnDisk({ blueprintPath, getStack, token, } = {}) {
    try {
        const blueprintFile = findBlueprintFile(blueprintPath);
        if (!blueprintFile)
            throw Error('Could not find Blueprint file! Use the init command.');
        const { path, fileName, extension } = blueprintFile;
        let blueprintString;
        let blueprintJson;
        let blueprintModule;
        switch (extension) {
            case '.json': {
                blueprintString = readFileSync(path, 'utf8').toString();
                blueprintJson = JSON.parse(blueprintString);
                break;
            }
            case '.js':
            case '.mjs': {
                const module = await import(path);
                blueprintModule = module.default;
                break;
            }
            case '.cjs': {
                const require = createRequire(import.meta.url);
                blueprintModule = require(path);
                break;
            }
            case '.ts': {
                console.warn('\x1b[2mSupport for Typescript blueprints is experimental.\x1b[0m');
                try {
                    const { tsImport } = await import('tsx/esm/api');
                    const module = await tsImport(path, dirname(path));
                    blueprintModule = module.default;
                }
                catch (err) {
                    if (err instanceof Error && err.message.includes('Cannot find module')) {
                        throw Error(`TypeScript support requires 'tsx' to be installed. Run: npm install -D tsx`);
                    }
                    throw err;
                }
                break;
            }
            default:
                throw Error(`Unsupported blueprint file extension: ${extension}`);
        }
        if (blueprintModule) {
            if (typeof blueprintModule !== 'function')
                throw Error(`Blueprint ${fileName} must export a default function`);
            blueprintJson = blueprintModule();
        }
        const parserResult = blueprintParserValidator(blueprintJson);
        const { blueprint: parsedBlueprint } = parserResult;
        const errors = parserResult.errors || [];
        // find project and stack IDs from .blueprint/config.json first,
        // then fallback to metadata in blueprint file,
        // finally fallback to resources array...
        let projectId;
        let stackId;
        const configIds = readConfigFile(blueprintPath);
        const blueprintMetadata = parsedBlueprint.metadata;
        // find/create project resource
        if (configIds?.projectId) {
            projectId = configIds.projectId;
        }
        else if (blueprintMetadata?.projectId) {
            projectId = blueprintMetadata.projectId;
        }
        else {
            const projectResource = parsedBlueprint.resources.find((r) => r.type === 'sanity.project');
            if (projectResource)
                projectId = projectResource.id;
        }
        // find/create stack resource
        if (configIds?.stackId) {
            stackId = configIds.stackId;
        }
        else if (blueprintMetadata?.stackId) {
            stackId = blueprintMetadata.stackId;
        }
        else {
            const stackResource = parsedBlueprint.resources.find((r) => r.type === 'sanity.blueprints.stack');
            if (stackResource)
                stackId = stackResource.id;
        }
        let deployedStack;
        if (getStack && token && stackId && projectId) {
            const { stack } = await getStackById({ stackId, auth: { token, projectId } });
            if (!stack) {
                errors.push({
                    message: 'Stack not found',
                    type: BlueprintParserErrorType.InvalidStack,
                });
            }
            deployedStack = stack;
        }
        return {
            fileInfo: { path, fileName, extension },
            errors,
            projectId,
            stackId,
            deployedStack,
            parsedBlueprint,
        };
    }
    catch (err) {
        throw Error(`Unable to parse Blueprint file: ${err}`);
    }
}
export function writeBlueprintToDisk({ path, fileType, content = DEFAULT_BLUEPRINT_CONTENT, }) {
    let blueprintContent;
    switch (fileType) {
        case 'json': {
            blueprintContent = JSON.stringify(content, null, 2);
            break;
        }
        case 'js':
        case 'ts': {
            blueprintContent = `export default function() {
  return ${JSON.stringify(content)}
}`;
            break;
        }
    }
    writeFileSync(path, blueprintContent);
    return blueprintContent;
}
export function readConfigFile(blueprintPath) {
    if (blueprintPath) {
        const blueprintDir = dirname(blueprintPath);
        const configPath = join(blueprintDir, '.blueprint', 'config.json');
        if (existsSync(configPath)) {
            try {
                const config = JSON.parse(readFileSync(configPath, 'utf8'));
                return config || null;
            }
            catch (err) {
                return null;
            }
        }
    }
    const configFilePath = join(cwd(), '.blueprint', 'config.json');
    if (!existsSync(configFilePath))
        return null;
    try {
        const config = JSON.parse(readFileSync(configFilePath, 'utf8'));
        return config || null;
    }
    catch (err) {
        return null;
    }
}
export function writeConfigFile({ blueprintPath, projectId, stackId, }) {
    const blueprintDir = blueprintPath ? dirname(blueprintPath) : cwd();
    const configDir = join(blueprintDir, '.blueprint');
    const configPath = join(configDir, 'config.json');
    if (!existsSync(configDir)) {
        mkdirSync(configDir, { recursive: true });
    }
    let config = {};
    if (existsSync(configPath)) {
        try {
            config = JSON.parse(readFileSync(configPath, 'utf8'));
        }
        catch (err) {
            // config broken, start fresh
        }
    }
    config.projectId = projectId;
    config.stackId = stackId;
    writeFileSync(configPath, JSON.stringify(config, null, 2));
}
export function addResourceToBlueprint({ blueprintFilePath, resource, }) {
    const blueprintFile = findBlueprintFile(blueprintFilePath);
    if (!blueprintFile)
        throw Error('Could not find Blueprint file');
    const { path, extension } = blueprintFile;
    // modify .json files directly
    if (extension === '.json') {
        const blueprintString = readFileSync(path, 'utf8').toString();
        const blueprint = JSON.parse(blueprintString);
        blueprint.resources = blueprint.resources || [];
        blueprint.resources.push(resource);
        writeFileSync(path, JSON.stringify(blueprint, null, 2));
        return;
    }
    return resource;
}
