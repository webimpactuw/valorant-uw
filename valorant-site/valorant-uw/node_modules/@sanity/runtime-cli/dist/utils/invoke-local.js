import { spawn } from 'node:child_process';
import { cwd } from 'node:process';
import { setTimeout } from 'node:timers';
import config from '../config.js';
function getChildProcessWrapperPath() {
    return new URL('./child-process-wrapper.js', import.meta.url).pathname;
}
export default async function invoke(srcPath, data, context, timeout = 5) {
    return new Promise((resolve, reject) => {
        let child;
        let timer;
        function start() {
            child = spawn('node', [getChildProcessWrapperPath()], {
                cwd: cwd(),
                stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
            });
            // Note: start a timeout so child process doesn't run forever
            child.on('message', (data) => {
                const { json, logs } = JSON.parse(data.toString());
                shutdown();
                resolve({ json, logs, error: '' });
            });
            child.on('error', (error) => {
                reject(new Error(`encountered error ${error.message}`));
            });
            child.on('exit', (code) => {
                shutdown();
                if (code !== 0) {
                    reject(new Error(`exited with code ${code}`));
                }
                else {
                    resolve({ json: {}, logs: '', error: '' });
                }
            });
            timer = setTimeout(() => {
                // timedOut = true
                shutdown();
                reject(new Error(`Timed out after hitting its ${timeout}s timeout!`));
            }, timeout * 1000);
            const payload = {
                ...data,
                context: {
                    apiHost: config.apiUrl,
                    token: config.token,
                    ...context,
                },
            };
            child.send(JSON.stringify({ srcPath, payload }, null, 2));
        }
        function shutdown() {
            clearTimeout(timer);
            child.kill();
        }
        start();
    });
}
